# BEGIN
# 14/12/16
# @INC means 'implementation not complete'
SINGLE-LINE COMMENTS
	# Hello, World!

MULTILINE COMMENTS
	#=
		I’m Dexter.
		#=
			Yay, nested comments!
		=#
		And I Rock.
	=#

SUBJECT DECLARATION & DEFINITION
	var a # unitialized subject declaration.
    var b = 25 = 50
    let c = 8

	# var is used for subjects whose values can change.
	# let is used for subjects whose values cannot change.

    # just like subjects, objects can also be let or var
    # new objects assigned to let subjects are let by default
    # new objects assigned to var subjects are var by default
    let beetle = var "BEETLE"
    var mantle = let "MANTLE"

	let b = 5 # covariant subject declaration.
	let c <- 'OroboGenius' # dynamic subject declaration.
	let d # uninitialized dynamic subject declaration.

	var Ω = 5, δ = 6 # multiple subject definition.
	let x, y, z

IDENTIFIERS
	# name of subjects must always start with a character and
	# can be followed with characters, digits or underscore.
	# names must not end with an underscore
	var name
	fun show_99_bottles_of_beer:
		println lyrics

	# by convention, names use camel case style
	fun createMeme:
		println memes.[rand]

	# by convention, subject and function names start with a lowercase character
	# by convention, type names start with an uppercase character.
	type Cat:
		let name, tag

ASSIGNMENT
	let pi, π = 3.141 # pi = 3.141, π = 3.141
	let pi & π = 3.141 # pi = 3.141, π = 3.141

	let one, two = (1, 2) # one = 1, two = 2
	let one & two = (1, 2) # one = (1, 2), two = (1, 2)

	# Bracketless zero-arg initializers are for specifying types only.
 	let count = Int # Int is not a initializer call here. It's a type specification.

	let count = Int.() # Int.() is a initializer call here. count is initialized.

CONSTANTS
	let b # deferred constant initialization
	b = 56

	let d = Int.() # d == 0
	d = 10 # error!

FUNCTION DEFINITION (1)
	# a typical Dexter function usually doesn't need brackets in its signature
	fun add a, b:
		return a + b

	var sum = add 25, 52

	# when brackets are used, there must be space(s) between the name and the open bracket
	fun sub (a, b):
		return a - b

	fun div a, b: # parameters are 'let' by default
		return a + b

	fun mul a, b:
		return a * b

	# you can annotate the argument and return types of a function
	#:: Int, Int -> Int
	fun mod a, b:
		return a % b

BLOCK DECLARATION
	var
		sum = 0
		count = 0

	fun
		add a, b:
			a + b

		sub a, b:
			a - b

		div a, b:
			a / b
	..

	type # type declaration
		Person name, age
		Car make, model, year


EXPRESSION-ORIENTED
	var isNyproCrazy = faveHobby == 'CountingBirds' # returns true or false to isNyproCrazy

	fun add a, b:
		a + b # 'return' is not needed here. result of a + b will be returned to the caller.
	..
	nypro.hieght = add.(aditya.height, -tripleo.height)

	# a semi-colon at the end of a block, stops it from returning its evaluated
	# result
	fun setName var p, name:#:: Person, Str
		p.name = name;
	..

	let name = setName.('John Smith') # error! setName returns no result.

SPECIFYING TYPES
	var number = 5
	var todo <- Str.('Create a programming language')

	let salary = Pay # type specification
	salary = Pay.(5_000, 12) # construction.

	var identifier = Str|Int # optional type specification.

	var address = Int = 506 # initialization
	let job = Str.() # default costruction.

SOME BUILT-IN TYPES
	var index = UInt = 2_000 # UInt represents unsigned integer; no negative values.

	var debt = Int = -100 # Int represents signed integer; you can have negative values.

	let e = F64 = 2.718281828459045
	let dogBreed <- Str = 'German Shepherd' # Str represents immutable UTF-8 string.

	var laptop = Chars = 'Alienware M18' # Chars represents mutable UTF-32 string.

	var listOfGroceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # this is a list.

	var game, year = 'BioShock Infinite', 2014 # this is a tuple.

VALUES & REFERENCES
	# by default primitive objects (UInt, Int, Float, Bool) are passed around by value and
	# by default complex objects (Str, user-defined types) are passed around by reference.
	var number = 502
	var account <- getAccount.('Dumbledore')

	# however, you can change this behavior with 'ref' and 'val'.
	var newAccount = val account # passing a complex object by value.
	var pointer = ref number # passing a primitive object by reference.

	# Dexter uses compile-time reference counting to manage memory, unlike Python or
	# Javascript which use runtime tracing GC.
	# It also does reference cycle breaking at compile-time. :)
	myCompany.affiliate = ref yourCompany
	yourCompany.affiliate = ref myCompany

	let myAccount = iso Account.('Nypro')
	# iso means only the subject can hold a reference to the object.

	let trooperClone = acq trooper # acq is shallow copy operation.

	let player = team.player

	# you can specify a dynamic subject reference beforehand
	let library <- acq

	fun getAmount:
		return rd amount
	# 'rd' means an object is passed by reference, but it cannot be written to,
	# only read from.

	fun swap!(var a = ref, var b = ref):
		a, b = b, a;
	..

NUMBERS
	var index = 5
	var axis = -3
	let meters = 0.25e-5
	let salary = 10_000f
	var color = 0x6FFF00p+12 # hex
	var opCode = 0b10110001 # bin
	var interest = 0o566768 # oct
    let pi = 3.14bf # BigFloat

ACCESS MODIFIERS
	var money = 0 # subjects, functions, types, etc. are public by default.

	fun `sub a, b: # becomes inaccessible outside module
		a - b

	var *pi =  3.14 # becomes read-only outside module

TUPLES
	var name, age = 'Emeka Okorafor', 27 # this is an open tuple
    # name and age are assigned to 'Emeka Okorafor' and 27 correspondingly.
	var game, year = ('Uncharted 4', 2016) # this is a closed tuple
    # game and year are assigned to 'Uncharted 4' and 2016 correspondingly.

	# NOTE: an open tuple is passed by value, a closed tuple is not
	name, age = age, name

	let make, year = car.details.()

	let index, car = 15, ('Ferrari', 1995) # car is a tuple.

	let map = () # empty tuple

	# named tuple
	let http200Status = (statusCode: 200, description: 'Ok')

PROPERTIES
	# properties provide getter/setter behavior.
	var age =
		set value:
			this = value # this refers to the property itself
		get:
			this

	# `this = <arg>` is always provided for set unless overridden.
	# a closing `this` is always provided for get unless overridden.

	var age = set \\ get # same as above

	var delegatedProperty =  set x: delegateSet \\ get: delegateGet

LAZY EVALUATION
	# an operation marked lazy will only execute on access, not before
	let appComponent = lazy iso self.getAppComponent
	var lazyField = lazy
		set x: println "I'm lazy!"


LISTS
	var unorderedList = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

	var emptyList =  []

	var names = [Str] # list of type specified

	var contestants = [Str]['Steve', 'Aditya', 'Sizwe', 'Pierre']

	# Dexter uses 1-based indexing, so every list indices start at 1.
	var disqualified = contestants.[1..4]

	var reversed = contestants.[-1..] # -1 is the 1st index from behind, i.e. the last index.

	let myGarage = [Car][.('Mustang'), .('Eleanor'), .('Bugatti'), .('Lamborghini')]

	let yearSalary = [12 Int][] # you can specify a size for the list.

	yearSalary.[1..3] = [2_000, 2_000, 2_500]

	let calendar = [12][]

	# proposed operations with lists.
	var concatenate = [1, 2] ++ [3] # [1, 2, 3]
	var multiply = [1, 2] ** 2 # [1, 2, 1, 2]
	let subtract = [1, 2, 3, 4, 3] -- [4, 3] # [1, 2]
	let divide = [1, 2, 5, 6, 3, 4] // [5, 6] # [[1, 2], [3, 4]]

MATRICES
	# Dexter lists can be used as matrices
	let a = [
		1, 2
		[3, 4, # this line is [3, 4, 5, 6]
		5, 6]
	]

	var matrix = [2 2 Int][
		1, 0
		0, 1
	]
	var column2 = matrix.[1.., 2] # content on row 1 to end, on column 2.

	var matA = [2 age] [,] # 2 rows with unknown column length

	matA.[.., ..] = [
		[1, 6, 3]
		[3, 7, 4]
	]

	let subset = mat4.[1.., 1..2]
	var matB = matA * 2

	# vectorised operations
	var matA = matB _* matC # the preceding `_` signifies an element-wise operation.
	matA _dot matB

	# Dexter's lists are by default, row-major order, but you can make it
	# column major by using the transpose function
	let y = [1, 2, 3]
	# 1 2 3

	let z = [1, 2, 3].tr
	# 1
	# 2
	# 3

	let x = y.[..2].tr

	# splatting a list
	let a = [
		1, 2
		0, 4
	].tr

	...a
	# 1 0
	# 2 4

	# splatting a list exposes the content of the matrix as an open tuple
	# splatting a returns a 2-dimensional open tuple.
	let b = [
		...a.tr, ...a.tr
		...a.tr, ...a.tr
	]
	# 1 0 1 2
	# 2 4 0 4
	# 1 2 1 0
	# 0 4 2 4

DICTIONARIES
	# dictionaries are basically key-value lists.
	let family = [
		'mum':
			'name': 'Esther Williams'
			'age' : 41
		dad: # unquoted keys are taken as strings
			name: 'Sunday Williams'
			age : 46
		sister:
			name: 'Shade Williams'
			age: 15
	]

	let sisterName = family.['sister', 'name']

	# to use variables from the outer scope, the variable name needs to be escaped wit `\`
	var professor = [
		\id1: 'Charles Xavier'
		\id2: 56
	]

	var name = house.['dad', 'name']

	let testScores = [
		'class room 1': [0, 15, 30, 15, 76, 50],
		'class room 2': 45, 50, 83, 9, 39, 81
	]
	var class1Scores = testScores.['class room 1']

	var contacts <- [:] # empty dictionary
	var user = [2 2 Str:User][:]
	var scoreList = [Str:Int]

LISTS, DICTS, INCLUSION, DIMENSIONS # NEEDS REVIEW !!!!!
    var a = [] # a list
    var b = [,] # a list containing another list
    var x = [:] # a dict
    var y = [::] # a dict containing another dict
    var z = [:,] # a dict containing a list
    var b = [,:] # a list containing another list, which contains a dict.
    var t = [12 Str Int] [:]
    var u = [7 5 Str Str Int][::]
    var u = [60 5 Str Int][:,]

OTHER TYPES OF LISTS
	var range = [1..20] # range is a type of list
	var indexer = list.[1..] # indexer is a type of list.
	# it holds ref to a subset of another list

PACKING & UNPACKING
	var list = [for x in 10: yield x] # [ ] turns a generator into a list.
	var open = ...list # ... turns a generator, list or closed tuple to an open tuple.
	var dict = [:tuple] # [:] turns a closed tuple or a tuple generator to a table.
	var closed = (a, b, c) # turn an open tuple to closed tuple

	let primes = [2, 3, 5, 7, 11]
	let numbers = [2, 4, 8, ...primes]

REST
    var a, ...b = 1, 2, 3, 4

    fun sum a, ...b:
        a + b.foldLeft 0, |a, b| => a + b
    ..

RANGED VALUE
	var lowercase = 'a'``'z'
	lowercase = 'a'
	lowercase = 'A' # error

STRINGS
	let language = 'Dexter'
	let year <- 2015
	var story = "[language] was started in [year]" # string interpolation.

	let calc = '5 * 50 = [5 * 50]'
	# both single and double quotes can be used to represent a string literal.

	# String formatting
	println "The price is [price.%2f]"

	# non-standard string literals preceded by characters are not affected
	# by escape sequences, because they are processed verbatim.
	var verbatimStr = r_"Use '\t' to represent tab"

	# here string (DEPRECATED). first and last new lines are always ignored.
	var verbatimStr = '''
	Hello, World!
	'''

	var string = 'Hello' # Str
	var chars = ch.'Hello' # Chars

	# proposed operations with strings.
	var concatenate = 'ab' + 'c' # 'abc'
	var multiply = 'ab' * 2 # 'abcabc'
	let subtract = 'abcac' - 'ca' # 'abc'
	let divide = 'abcdeabc' / 'de' # ['abc', 'abc']
	let escapeSequences = '\t \n \' \" \[ \# \\'

	var greeting = # multiline string.
	'Hello,'
	'World!'

MULTILINE EXPRESSIONS
	# expressions that spread accross multiple lines must be enclosed in brackets
	# or used with an isolated three dots ending the previous line.
	var zero = - 100 ...
	+ 100

	# notable exceptions :
	# statements expecting a bock-begin punctuator ':'
	if x < y
	& a == b:
		doTask.()

	# assignment operator
    var x =
    	25 + 6 # should be indented

	# fragmented string
	var greeting = 'Hello,'
	' World!'

	# comma operator
	sum 1, 2, 3, 4, 5, 6, 7, 8,
	9, 10, 11, 12

BLOCK SCOPE
	# a block represents a scope
	let country = 'India'
	block:
		let country = 'Nigeria'
		println country # Nigeria

	println country # India

	# multiple statements can be written on one line separated by semi-colons.
	var temp = a ; a = b ; b = temp

	# multiple blocks can also be written on the same line using the '\\' punctuator.
	if studio.isLive: blockAccess \\ else: openAccess

INDENTATION # NEEDS REVIEW!!!!!!
	# Dexter is an indentation-based language
	if x == y:
		if a == b:
			doTask
	# indentation is used here to disambigute if-else association
	else:
		doNothing

	let myName = " Nypro "
		->trim!
		->reverse!
		# indented dot/arrow notation links with the argument of the previous  line.
	->println

	play music
		'Asa',
		'Jailer'
		# arguments to function can be laid out on the next indented lines
	.rewind 2

	var x =
    	25 + 6
		# a continued line following an assignemnt operator should be indented


SANDWICHED STATEMENTS
	var faveSoccerClub =
	(team == 'Manchester United' ? (println 'You suck!'; team) : _)

	# you can sandwich multiple expressions where a single expression is expected.
	# by putting them in brackets.
	println.('Hello, ', (println.('World'); '!'))
	var add = ()

IF STATEMENT
	if isAdrianRich:
		spendAll.('on parties')

	elif isOroboRich:
		spendAll.('on legos')

	elif isSyconRich:
		spendAll.('on suits')

	else:
		cry.('we are broke')

	if phoneNumber == nil:
		useEmail.()

	if let stockCode = getStockCode.('APPLE'): # block is evaluated if stockCode is not nil
		println 'APPLE: [stockCode]'

	if copy = getCopy:
		println copy

	# nested if statements can be written together with their corresponding
	# else statements stacked accordingly
	if tim.age > 16; if car.state == 'good':
		tim.drive car
	else:
		raise Error 'Driver must over the age of 16'
	else:
		raise Error 'Car is in bad state. Repair immediately!'

NIL
	# sometimes, it is important to represent an empty or missing state, this can be
	# achieved in Dexter with optional typing.
	var code = Str # cannot be nil
	var program = Str|Nil = 'println \"Hello World\"'
	var anotherProgram = Str? = nil

	# a nilable cannot be assigned to a non-nilable subject without a proper nil coalescing with a fallback value.
	var programList = Str.()?
	var cartoonList = [Str?]

	let profile = server
		.user.('Name')?{Account 'default'}
		.profile?{Profile 'default'}

	if feeds: println 'no feeds' # = if feeds equals nil or false.

	(getAccount "default")?

	# nil-then-raise operator
	getAccount.("Default")?! # if result is nil, raise NilError
	game.fix?!

	if isRecieving == nil:
		println 'remote server stopped recieving'

	let john = Person dave?.name # unwrapping a nilable object

	var isNight = true?

	if isNight:  # error # disambiguation needed
		wake dracula

	if isNight = true:
		wake dracula

CONDITIONS
	# Dexter discourages reptition in conditional expression.
	x < y & y < z # deprecation warning!
	x < y < z

	x == y & y == z # deprecation warning!
	x and y == z # if both x and y equals z.
	x == y == z

	x == y | y < z # deprecation warning!
	x == y or < z # if x equals y and also greater than z.

	x == y & a == b # no warning

	if x != y: println 'x does not equal y'
	if x not in list: println 'x is not inside list'
	if !x:  println 'x is not nil'

    a.trim == b.trim
	|a == b|.trim

	#:: Node -> Bool
	fun isSymmetric node:
		node.|right == left|.height

FOR LOOP
	for i in [1..10]:
		println i

	let interestingNumbers = [
		'prime' : 2, 3, 5, 7, 11, 13
		'square' : 1, 2, 4, 9, 25, 36
		'fibonacci' : 1, 1, 2, 3, 5, 8
	]

	for kind, number in interestingNumbers: # parallel pairing through a dictionary.
		println '[kind]: [number]'

	# an extra tuple param serves as the iteration index
	for names, index in register:
		println index, names

	for name, (key, value), index in nameList, table:
		println name, key, value, index

	# looping through a number
	for num in 50: num

	for up, down in [1..20], [20..1]: # parallel pairing through ranges.
		println '[up] :: [down]'

	for upper in [1..20]; for lower in [1..20]: # nested iterations through ranges.
		println '[upper] :: [lower]'

	for i in [1..20]:
		i += 1 # error! immutable subject.
		j = i
	..

	for var i in [1..20]:
		i += 1
		j = i
	..

	for _ in [1..fifty]:
		println 'Hello'

LIST COMPREHENSION
	var oddList = [for i in [1..20] where i .mod 2 != 0: yield x]
	var oddList = x || x <- [1..20] ~ x .mod 2 != 0
	fun times: x * y || x <- [1..10]; y <- [20..1] ~ even y

BLOCK SUBJECTS
	for color in colors:
		var hold i = 1 # a block subject's state persist for the duration of the loop.
		printl=i, color)
		i += 1
	..

	fun sum list:
		var hold index = 1 # you can also have block subjects for recursive functions.
		if x.size < 1:
			return 0
		else:
			list.[index] + sum.(list.[++index:])
	..

EXT
	# `ext` is used to refer to the outside scope
	for class in classes:
		for student in students:
			if student.position == 'captain':
				record.save.(student.name)
				continue ext # refers to parent loop scope
		..
	..

    fun add a, b:
        fun plus:
            if a and b > 0:
                return ext a + b
        plus
    ..

	new view.addListener obj Listener:
		fun onScroll view, dX, dY: #:: View?, Int, Int
			scrollList.each |it| =>
				it.invoke ext.self
	..

BREAK WITH
	for names in register:
		if name == 'Tony':
			break name
		""

IN
	if student.name in defaulterList:
		println '[student.name] hasn\'t paid yet. Contact parents'

	if 'ps4' not in birthdayPresents:
		println 'Aaargh! Everyone hates me'

	if /dollar[s]?/ in sentence:
		println 'Change occurrences of "Dollar" to "Pound"'

WHERE # @INC
	# where is used to establish an extensive condition especially where it is
	# not expected.
	if person in auditionRoster where person.mark > 40.0:
		acceptanceList.add person

	for book in library where book.title.contains.('adventure'):
		personalLibrary.add book

WHILE LOOP & LOOP
	while file.hasNext:
		println file.next
	..
	# loop
	loop: # synonymous with while true
		println '>>> '
		let input = scan
		let tokens = lex input
		let ast = parse tokens
		let bytecodes = compile ast
		let result = interpret bytecodes
		println result

	loop:
		lines = gen.readLine # evaluated at least once.
	while gen.hasNext

	while var user = genRandomUser:
		println user.name

	while list.size > 0 for name in list:
		print name, sp
		list .removeTop

TERNARY OPERATOR
	# ternary operator is a summarized if-else clause.
	var absValue = if a > 0: a \\ else: -a

	var absValue = a > 0 ? a : -a

	song in playlist ? play playlist.[song] : _

	# a ternary operator statement needs to be encapsulated in brackets
	# where a semicolon is expected
	if a == (b > c ? b : c): print a

FUNCTION DEFINITION (2)
	fun multiply a, b:
		a * b

	# if a function returns nothing, it's return type may be `!` or left empty
	#:: Str -> !
	fun greet name:
		println "Hello [name]"

	# to make sure nothing is returned from a function you can use `;` to terminate an exit expression or `!` as the exit expression.
	fun effect mood:
		if mood.isHappy:
			happySong->play;
		else:
			sadSong->play
			!
	..

	# varargs.
	#:: Int -> F64
	fun arithMean ...numbers:
		var total = 0d
		for number in numbers:
			total += number
		total / numbers.size
	..

	# there are two ways of calling a function in Dexter
	arithMean 1, 2, 3, 4
	arithMean.(1, 2, 3, 4)

	# GOTCHA: this two function call return different results
	toUppercase ('hello ' + name).toLowerCase
	toUppercase.('hello ' + name).toLowerCase

	# anonymous functions ae nameless fuinctions
	# and they are excuted at the point its declared.
	fun _:
		return a + b

	# the states of `keep` subjects are preserved between function calls.
	fun callCount:
		var keep count = 0
		println '[count += 1]'

	callCount # 1
	callCount # 2

	# functions that change values of arguments must be annotated with `!`.
	#:: ref Person, ref Person
	fun swap! var a, b:
		a, b = b, a;

	swap! john, jane

	# when an argument name isn't given, they can be referred to with their argument notation
	fun add _, _: $1 + $2

	# default parameter values and shared value with `&` binder
	fun login email & username & password = 'demo':
		access Account username, password

	login.(_, 'nyprothegeek', 'bazinga!')
	login.('nyprothegeek@gmail.com', 'nyprothegeek')

	# compulsory named arguments
	fun signUp .username, .password:
		access Account username, password

	signUp username:'appcypher', password:'bazinga'

	fun sendMessage message, to.recipient:
		println (message + recipient).toUppercase

	sendMessage 'Hello', to:'Cantell'

CONSECUTIVE CALL CHAIN
	greet 'John'; greet 'Jane' ; greet 'Lagbaja'
	greet 'John' >> 'Jane' >> 'Lagbaja'
	greet->('John')->('Jane')->('Lagbaja')

	list.getPerson 'Anthony', >> 'Barney', >> 'Rodney'

FIRST-CLASS FUNCTIONS
	# creating new functions from existing functions
	var details = getDetails$ User
	var plus = add$ 0, 0
	fun times = mul F64, F64

	var binaryOp = (Number, Number -> Number)
	var binaryOp = Func{Number, Number, Number}

	var range = fun _:
		for i in [..11]:
			yield ++i

	# passing functions to functions
	fun compress image, f = (Int, Str -> Int):
		f image

FUNCTIONS AS ARGUMENTS & LAMBDAS
	let scoreListWithExtraMarks = scoreList.map (fun _ score: score + 5)
	let scoreListWithExtraMarks = scoreList.map markFilter$ Int

	fixtureList.filter |game| => !game.isCancelled
	fixtureList.filter => !$1.isCancelled

	var pplBelow25 = census.filter |person| => (
        person.age += 1
        person.age < 25
    )

CLOSURE
	# a closure is an inner function.
	fun genDBConnector .host, .username, .password:
		return fun makeDBConection: # a closure can be returned.
			db.connect.(host, username, password)
	..
	var dbCallback = genDBConnector.(host:'localhost', username:'nypro', password:'willdiearobot')

COFUNCTIONS
	fun remove! var list, index:
		list -= list.[index]

	(remove$ [F64], Int) += refreshUI$ # attaching a cofunction.
	emit movieList.remove.(2) # emit is used to run the function along with its cofunctions.

FUNCTION PATTERN MATCHING
	fun fact 0: 1
	fun fact n: n * fact n  - 1
	fun head [x, ...y]: x
	fun vecAdd (x, y), (a, b): (a + a, y + b)
	fun keys [a:b]: a
	fun range [a..b]: a, b
	fun height 1``20: 10
	fun add _, _: $1 + $2
	fun fact \zero: 1 # bad idea! NEEDS REVIEW!!!!

	# named pattern
	fun width x .1``20: println x
	fun array all .[x, ...xs]: println all
	fun integer num ./[-+]\d+/: Int num

	# mixing pattern and parameters
	#:: Int, Int -> Int
	fun multiply x .1``1_000, y:
		x * y

EXT SUBJECTS
	let state = 'Idle'

	fun changeState state:
		if state != nil:
			activateState.(state)
		else:
			activateState.(ext.state) # ext refers to the parent scope.
	..

USEFUL FUNCTIONS
	typeOf.(24)
	size [1, 2, 3, 4] # size is a constant-time operation.
	count.("Hello, world!") # count may be a linear-time operation.
	iter array, 5 # array{5:3}
	enumerate array # for x, y in array
	map names, => $1 + ' '
	filter.(list, |a| => isPrime a)
	each list, => (println $1, ', ')
    eachIndex list, |i, e| => println "[i]: [e]"
	noneMatch numbers, |a| => isEven a
	printf.('The circumference of a circle with radius 5 is %f', pi * 5^2)]
	respondsTo.(object, add$)
	getHighest list
	getLowest list
	getRank list, 21

USEFUL CONSTANTS
	nl == '\n'
	sp == ' '
	tb == '\t'
	cm == ', '
	bk == '\b'
	pi == 3.1415926535897
	e == 2.7182818284590

CACHED EXPRESSION
# sometimes one needs to cache an expression for an iterative task, without declaring a variable.
for i in [1..keep 35*2]:
	println i

PATTERN MATCHING
	# match block is like switch-case statement, and it matches against the expression on the previous line.
	#:: Str, List, Int, Int -> _
	fun opCodeDispatch opCode, args, var index & result:
		result = 0
        opCode
		| 'ADD' : return result = args.[index] + args.[index += 1]
		| 'SUB' : return result = args.[index] - args.[index += 1]
		| 'MUL' : return result = args.[index] * args.[index += 1]
		| 'DIV' : return result = args.[index] / args.[index += 1]
		| 'EQ'  : return args.[index] == args.[index+1] ? index += 3 : spill
		| 'JUMP' or 'SKIP' : index += args.[index += 2]
		println 'Opcode error!'
	..

	# more pattern matching
	char
	| 'A'     : 'bing'
	| \b      : 'bang'
	| 'C'     : 'bung'
	| 'D'``'E': 'beng'
	| _       : 'bong'

	# it can also match against the arguments of a function and loop
	fun status message:
		| Int: println message
		| Started.("Fail"): println message.info
		| Started.(info): println info # named match
		| Started.(\info): println message.info
		| Terminated.("Success"): println message.info

	while turn != 'y' or 'Y' or 'n' or 'N':
		| 'y' or 'Y': return 1
        | 'n' or 'N': return 0
        | _: print "its an invalid choice."


COROUTINES # NEEDS REVIEW !!!!!!
	# Coroutines run concurrently, but cannot run parallely.
	fun genRandRange num:
		yield rand.range num
	..

	var don = for i in [1..45]: yield i

	let bin = don.([..]) # synonymous with yield from
	let bon = don.([1..3])

ASYNC AND AWAIT # NEEDS REVIEW !!!!!!
	fun asyn getPerson name:
	    let p = await getPersonFromServer name.split /\s+/
	    yield p->name, ->age
	..

TASKS, also ACTORS # NEEDS REVIEW !!!!!!
task Task:
	var name, time = Str, Int

	fun init name:
		self.name = name
		self.time = random.([1:1_000])

	fun task sleep:
		println "[name] is sleeping for [time]ms"
	    sleep time
	    println "[name] is done"
..

var
	t1 = Task.("Task-1") ->sleep
	t2 = Task.("Task-2") ->sleep
	t3 = Task.("Task-3") ->sleep

STREAM
	ones.twos.threes.collect
	collect.(threes.(twos.(ones.())))

	fun ones: yield 1
	fun twos generator: yield gen + 2
	fun threes generator: yield gen + 3

	fun collect generator:
	    list = []
	    for i in gen: list .append i
	    list
	..

TYPE DEFINITION
	type Car:
		var make, model = Str

	fun move car: #:: Car
		"Moving"

	# initializer
	fun Car make, model: #:: Str
		new.(make, model)
	# new is a special function that creates a new object and maps
	# the arguments to corresponding fields

	fun Car maker, model, year
	fun Car ~ # normal # called on Car object during destruction.
	fun Car ! # exception # called on Car object during an exception.

	type Person var name & age # Person is a initializer type.
	# Initializer types have just main initializer and the parameters
	# of the initializer are mapped to fields.

	var john = Person.('John Connor', 23)

	type Lamp var color
	var yellowLamp = Lamp 'Yellow'

	# initializer overloading
	fun Lamp:
		Lamp 'White'

	type DataProviderManager:
		# a `keep` field is a type level field
		let keep allDataProviders = get \\ set

	# associated type
	type Person.Pet var name & age

	let pet = Person.Pet 'maddison', 2

FIELD EXTENSION
	type Programmer specializedLanguages <: Person:
		let languages = [Str]

	let orobogenius = Programmer
	orobogenius.languages = ["Java", "PHP", "JavaScript"]

	let appcypher = Programmer ["Dexter", "Java", "C++"]
	appcypher.+philosophies = ["Open Source", "Transhumanism"]
	appcypher.+resume = "chicken.poop.com/appcypher"
	appcypher.+mentor = "Captain Jack Sparrow"

	var nypro = appcypher

TYPE EXTENSION
	type Programmer specializedLanguages <: Person:
		let languages = [Str]

	# the `fork` keyword allows a type to be extended within a scope.
	type fork Programmer:
		var philosophies, resume, mentor

INHERITANCE
	type Animal
	fun sound animal: #:: Animal
		println 'Nothing'

	type Bird <: Animal
	fun sound bird: #:: Bird # overrides supertype function.
		println 'Chirp!'

	type Horse <: Animal:
	fun sound horse: #:: Horse
		println 'Neigh!'

	# Dexter supports multiple inheritance.
	type Pegasus <: Horse, Bird:
	fun sound pegasus: #:: Pegasus
		sound pegasus as Horse

	# due to Dexter's multiple dispatch, Inheritance applies equally to all
	# arguments of a function.
	type A
	type B <: A

	fun
		foo a, x #:: A, X
		foo b, x #:: B, X # this overrides top

	fun
		bar x, a #:: X, A
		bar x, b #:: X, B # this also overrides top

	# a super method can be called directly or by using super
	fun baz x, b: #:: X, B
		baz x, b as base

INITIALIZER TRAIN
	# initializer train is the way Dexter ensures the initialization of all declared and inherited fields of a particular type.

	# it's basically about making each type responsible for the initialisation of the fields it introduced.

	type Person name

	type Teacher name, subject <: Person
	type Student name, course <: Person
	# the initializer train of an initializer type is created automatically

	type TeachingStudent <: Teacher, Student:
		var schedule

	fun TeachingStudent name, subject, course, schedule:
		new base.(name, subject : name, course), schedule
		# (name, subject) is passed to Teacher
		# (<delegated>, course) is passed to Student

	# a sub type should not assign to inherited fields in the initializer.
	# if the compiler finds out an initializer doesn't initialize a field, it complains.

DIAMOND PROBLEM
	fun register teacher: #:: Teacher
		staffList teacher.name

	fun register student: #:: Student
		studentList student.name

	# when TeachingStudent type is declared, an ambiguity error will be issued about `register`.

	# the function needs to be overridden
	fun register teachingStudent: #:: TeachingStudent
		staffList teachingStudent.name
		studentList teachingStudent.name

	var john = TeachingStudent 'John Smith'
	john.register

	# as a result of these MI issues, Dexter advocates favoring single inheritance and composition over multiple inheritance.


ABSTRACT TYPES & FUNCTIONS # @INC
	type abst Player # abstract types cannot be instantiated.

	# a function without a body (apart from initializers) is an abstract function and an error is raised if it is called directly.
	# An abstract function is expected to be implemented by a corresponding subtype function.
	fun play pl #:: Player
	fun rewind pl #:: Player
	fun fastForward pl #:: Player

	type DigitalPlayer <: Player
	fun play dpl: #:: DigitalPlayer # this overrides and implements play.
		initPlaylist
		playPlaylist

	# Here is an example using abstract types to simulate Algebraic Data Types.
	type abst Tree

	#:: $T -> Leaf
	type Leaf value <: Tree

	#:: Leaf, Tree -> Node
	type Node l, r <: Tree

	#:: Tree -> _
	fun sum t:
		| Leaf: t.value
		| Node: (sum t.l) + (sum t.r)
	..

	var x = Node.(Leaf.(1), Node.(Leaf.(2), Leaf.(3)))

ANONYMOUS TYPES # @INC
	# an anonymous type is a singleton with an ad hoc type definition.
	# which include the type's fields and functions.
	(obj Thread state:
		var state = 'Paused'
		fun start:
			println 'Thread: [self.state]'
	..
	).('Working')

	var currentShow = (obj _ show, host) 'DareDevil', 'Netflix'

	println currentShow.host

	window.addMouseListener obj MouseAdapter:
		#:: MouseEvent
		fun mouseClicked e: !
		#:: MouseEvent
		fun mouseEntered e: !

TYPE CHECKING
	if myCar :: Car:
		println 'myCar is a Car'

	if myCar == Car:
		println 'myCar is a Car or its subtype'

	if myCar <: Car:
		println 'myCar is a supertype of Car'

	if myCar !>: Car:
		println 'myCar is not a supertype of Car'

	(head$ List) :: ([_] -> _)

REFERENCE CHECKING
	let a = Person 'John Smith', 25
	let b = a
	let c = val a
	a =:= b # true
	a =:= c # false
	(one =:= other) == (one.ref == other.ref) # true

FUNCTION == METHODS (UFCS)
	fun show p: #:: Person
		println.(self.name, self.age)
	..

	show nigel
	# In Dexter, a function is a method of its first argument.
	nigel.show

	# The only two set of functions that cannot be used with dot operator are
	# contructor functions and new functions.
	type Robot:
		var name, uniqueID
	..

	fun Robot name, uniqueID:
		new name, uniqueID

	var wall_e = Robot 'Wall•E', 215


ACCESS CHAINING/SHRINKING
	# return chain.
	var result = 8.plus.(6).minus.(4).times.(2)

	# tail object chain
	# a convenience syntax in which the intial associated object forms a long chain of access.
	profile ->open ->deleteMsgs ->close

	# returned object forwarding.
	buffer ->resize!.(13) ->fill!.(0, $0)

	# consecutive call chain
	var nameList = [Str]
	nameList.add 'Badmus' >> 'Travis' >> 'Gabriel'

	# chain tupling
	var name, version = haskell ->name, ->version
	var first, second = getPerson 'Seamus', >> 'Flinn'

	# shared dot or arrow
	|a == b|.size ? a : b
	println john.|name, addrress|.toUppercase

COVARIANCE
	type Person (name, age)
	type Employee base.(name, age), job <: Person
	type Teacher base.(name, age), course <: Person

	fun show p: #:: Person # a covariant parameter can take a subtype too.
		println p.name, p.age

	show Person 'Tony Stark', 36
	show Employee 'Peter Parker', 17, 'Photographer'
	show Teacher 'Diana Lane', 12, 'Biology'

	var people = [Person][Teacher.(), Employee.(), Employee.()] # a covariant list.

TYPE CASTING
	var radianInt = Int.(2 * pi) # the resulting value Float of 2*pi is casted to Int.

	fun Employee person: #:: Person
		Employee.(self->name, ->age)

	var deitel = Person.('Paul Deitel', 57)
	var editor = Employee dietel

	var yearStr = Str 1990
	let sorted = Int yearStr.sort!

	#:: Float -> MyInteger
	fun MyInteger num: new.(Int num)
	let cost = (MyInteger price) * qty

NAME ALIASES
	type Number = Integer|Float|Complex
	fun cheb = chebyshevCoefficient
	let pi = thisIsAPiConstant

FUNCTIONS OBJECTS & SUBJECTS
	fun foo = bar.(5, 6)

	var
		qux = 5
		doo = bar$.('a', 0)

	fun mix a:
		| 1: fun add a, b: a + b
		| 2: 25

	fun baz = mix 1 # error
	var bin = mix 1

MODULES AND IMPORTS
	# when you import a module, every public member is imported into the namespace.
	import
		com.appy.BananaTree
		com.nypro.[AppleTree, GuavaTreeTree]

	# if you want to import members namespaced
	import
		com.appy.BananaTree!
		com.nypro.[AppleTree!, GuavaTree!]

	# import all
	import
		com.appy.BananaTree
		com.nypro.[?]

	# import some
	import
		com.appy.BananaTree.(Trunk, grow)
		com.nypro.[AppleTree.(Leaf, Apple), GuavaTree!.(grow, Seed)]

	# import by category
	import com.appy.BananaTree.(var, let, fun, type)

	# don't import
	import com.appy.BananaTree.(fun : grow)
	# names on the left of the `;` are not imported

	# global subjects can only be passed by value from one module to another.

GENERICS
	# declaring a generic type T.
	#:: $T<:Number, T, T -> T
	fun add a, b, c:
		var d = T
		d = a + b + c

	var sum = add{Int} 2, 4, 6
	# if the generic parameter can be readily inferred, then type argument can be ommited.
	var sum = add 2, 4, 6

	type MyList:
		let list = [len $T][]
		let size = @len::Int # generic constant value.

	var list = MyList{Int, 5}

	#:: MyList{$T}, $U[MyList.U] -> T
	fun getItem list, index:
		list.[index]

	let identifier = $T<:Identfiable

	var pegasus = $U(=Horse, =Bird)

	var x = 10
	let y = $(x) # this makes y have the same type as x

TYPE OBJECTS # @INC
	# unconventionally, Dexter has Type objects which can be held by subjects.
	# Sometimes, this concept may clash with generics, but they are basically different
	# constructs with overlapping features.

	var number = $(Bool) # covariant subject
	# number can hold Bool.type or its subtypes.

	Int <: Integer # true

    fun haveSameTypes x, y:
        x and y == $(x)
    ..


ENUMS
	# in a way, enums are types that contain declaration of subtypes.
	enum Days:
		Sunday, Monday, Tuesday, Wednesday, Thursday, Friday

	var today = Days = Friday
	today = Tuesday

	# using allows an enum element to be used without the parent namespace.
	# hiding disallows it. enum elements are using by default.
	using Days
	using Days Sunday, Monday
	hiding Days

	fun todo day = Days:
		| Sunday: sleep
		| Monday: work
		| Friday: tgif
	..

	enum Integral:
		UnsignedIntegral.(value = Unsigned)
		SignedIntegral.(value = Signed)
	..

	# enums can have field too, which enum elements inherit
	enum Cars:
		let make, model
		Mustang
		Ford
	..

	# enums can inherit from other enums and types.
	# it's more of inclusion than inheritance
	enum NewTools <: OldTools:
		Unity
		Django
		SASS
	..

	# Algebraic Data Types
	enum Tree:
	    Leaf value = Int
	    Node left = Tree, right = Tree
	..

	fun sum t = Tree:
	    | Leaf v: v
	    | Node.(l, r): sum.(l) + sum.(r)
	..

MODIFIER BLOCK
	fun
	    asyn foo zee:
	        parametricAngular 35 / zee

		task grope:
			ping pong

	    norm grun zoom, ping:
	        ping = ping + sieze zoom
	        pandora ping

	var
	    keep xafora = await foo
	    norm generativePlug = yen 45.6 * pi
	    # hold fred = Person zenithName, zenithAge

	type
	    abst Pandora galacticConstellationNumber

	    norm BananaRepublic state, country

	    enum Days:
	        Sunday, Monday, Tuesday, Wednesday,
	        Thursday, Friday, Saturday
	    ..

	    task NewTask

OPERATOR OVERLOADING
	# special characters
	# these are characters that cannot be combined with conventional identifier
	# characters to form new identifiers. The only exclusions to this are
	and, or, not, in # they can be used in conventional identifiers
	# special operators are to be infixed without the dot notation.

	# indefinite characters
	# these characters can only be used with other special characters of
	# the same set to create new special identifier.
	= <- + - * / ^ √ & | > < =(special_chars)

	# definite characters
	# these group of characters cannot be overloaded as is, but can be combined
	# to form new identifiers.
	(special_chars)= :: <: >: >> << . ~ => !

	# language-level characters
	# this group of characters cannot be overloaded nor can they be combined
	# with other special characters to form new characters.
	-> , . $ || \\

	# reserved operstors
	\ = prefix
	| = prefix and postfix
	/ = prefix and postfix

	# you can call an operator like a function
	println (+ 56)
	println +.(56)

	operator 40, "left", "infix":
	#:: Rango, List{$A[Rango.T]}
	fun = rango, list:
		rango.populate = list
	var x = Rango = [1, 2, 3, 4]

    # identifier characters can be used as operators must be surrounded by spaces.
    operator 20:
    fun ϵ(a, b):
        a in b

    if a ϵ b: println "Booyah!"

	call.() # callable
	getIndex.() # indexable

	let greet, list = Greeter.(), MyList.(1, 2, 3)
	greet.('Banji')
	list.[3]

TRY, CATCH & ENSURE
	if numerator and denominator == 0:
		raise DomainError.() # raising an exception.

	process.(bigData)
	catch _ divError: #:: DivByZeroError
		println self.msg
	ensure: # a catch can be accompanied by an ensure block.
		rollBack.(bigData)

	# explicit catch function call
	f ->open.('banana.png')`ferr->write.('Hello')
	catch ferr fnfe: #:: FileNotFoundError
		println self.msg

	# error coalescing
	memory.[name]`{0} # catch all
	memory.[name]`{KeyNotFoundError|NoValueError: 0} # catch specific exceptions

	# managed resource
	try let f = open.('/sdcard/db.sql'):
		f.write.(data)

	# the normal try catch is supported
	try:
		f.open.('banana.png')
	catch _ err: #:: FileNotFoundError
		print self.msg


MACROS # NEEDS REVIEW !!!!!!!
	# Dexter macros are resolved at parse time.
    # rather than using the AST, Dexter macros work on parse tree.
	#:: BinaryExpression
	macro reverseExpression binExpr:
		return binExpr->rhs, ->op, ->lhs

	var half = reverseExpression 2 / 4

    macro assert cond = IfExpression:
        let line = cond.lineNumber
        return
        <
            if !<cond>:
                println 'assertion [<cond>] failed on line <line>'
        >
    ..

	assert num and den != 0

    macro class
        params = ParamExpr,
        iden = Identifier,
        colon = <:>?,
        body = TypeBody? # the '?' means optional
    :
        if body and colon != nil:
            return <type>, iden, params
        return <type>, iden, params, colon, body
    ..

    class Person name, age:
        let name, age = Str, Int

OTHER LITERALS # @INC
	let fraction = 3//2 # rational numbers.

	var complex = 1 - 1im # complex numbers.

	var regex = /\d+(.\d+)?/ # regex.

    var block_regex = ///^ (
      ?: [-=]>
       | [-+*/%<>&|^!?=]=
       | >>>=?
       | \.{2,3}
    )
    ///

	# non-standard literals
	var ns_number = 345_NGN
	var ns_str = ns_'1, 2, 3, 4'
	var ns_list = ns_[1, 2, 3, 5]
	var ns_dict = ns_[name: 'Steve', age: 24]
	let ns_tuple = ns_(name: 'Steve')

    # builtin non-standard literals
    var raw_string = r."\t represnts a tab character"

BUFFER TYPE
	# buffer is a base array that types like List, Str, Chars use to build their internal
	# array structure.
	let int5 = Buffer{Int}(5)
	# You can resize and also fill a buffer.
	let buffer = Buffer{Int}(10, 10).fill!(0)
	buffer ->resize!(1, 20) ->fill!(0, $0)

BASIC ARITHMETIC OPERATIONS
	let t = 2 + 2
	let u = 5f * 20d
	var v = 5 / 2 # this returns an F64 even though the operands are Ints
	var w = 5 ~/ 2 # this returns a clamped Int result of the above
	var x = 6 % 5
	let y = 5i16 ^ 2_i8
	let z = I8.(√25)

INTEGER BITWISE FUNCTIONS
	var x = 2 .bitand 5 # and
	var y = 3 .bitor 6 # or
	var z = 6 .bitnot # not
	var a = 7 .bitxor # exclusive or
	var b = a .bitshl b # bit shift left
	var c = b .bitshr a # bit shift right

PREDEFINED TYPE HIERARCHY
	Any
		Type
		Func
		Indie
			Real
				Integer
					Signed
						Int, I8, I16, I32, I64,
					Unsigned
						UInt, U8, U16, U32, U64
				Float
					F32, F64
			Complex
				Cmp64, Cmp128
			Bool
		Array
			Buffer
			List
				AbStr
					Str, Chars
				Range
				Indexer
			Tuple
				Name Tuple
		Generator

POSSIBLE COMPILER DEPENDENCIES
- libffi    (foreign function interface)
- gmp       (bignum)
- libprce   (regex)
# - libmill   (goroutines)

# END
