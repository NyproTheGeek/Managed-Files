# BEGIN
# 14/12/16
# @INC means 'implementation not complete'
SINGLE-LINE COMMENTS
	# Hello, World!

MULTILINE COMMENTS
	#=
		I’m Dexter.
		#=
			Yay, nested comments!
		=#
		And I Rock.
	=#

SUBJECT DECLARATION & DEFINITION
	var a # unitialized subject declaration.
    var b = 25 = 50
    let c = 8

	# var is used for subjects whose values can change.
	# let is used for subjects whose values cannot change.

    # just like subjects, objects can also be let or var
    # new objects assigned to let subjects are let by default
    # new objects assigned to var subjects are var by default
    let beetle = var Car
    var beetle = let Car

	let b = 5 # covariant subject declaration.
	let c <- 'OroboGenius' # dynamic subject declaration.
	let d # uninitialized dynamic subject declaration.

	# the difference between '=' and '<-' is only relevant in declarations
	# they can be used interchangeably for other assignment operations.
	# maybe in the future, '<-' will only be used with dynamic variables and '=' for covariant variables.
	b <- 23
	c = "Name"

	var Ω = 5, δ = 6 # multiple subject definition.
	let x, y, z

IDENTIFIERS
	# name of subjects must always start with a character and
	# can be followed with characters, digits or underscore.
	# names must not end with an underscore
	var name
	def show_99_bottles_of_beer:
		println lyrics

	# by convention, names use camel case style
	def createMeme:
		println memes.[rand]

	# by convention, subject and function names start with a lowercase character
	# by convention, type names start with an uppercase character.
	type Cat:
		let name, tag

ASSIGNMENT
	let pi, π = 3.141 # pi = 3.141, π = 3.141
	let pi & π = 3.141 # pi = 3.141, π = 3.141

	let one, two = (1, 2) # one = 1, two = 2
	let one & two = (1, 2) # one = (1, 2), two = (1, 2)

	# Bracketless zero-arg constructors are for specifying types only.
 	let count = Int # Int is not a constructor call here. It's a type specification.

	let count = Int() # Int() is a constructor call here. count is initialized.

	# elsewhere bracketless zero-arg constructor are constructor calls
	a = Car # also Car()
	print(Label) # also Label()

CONSTANTS
	let b # deferred constant initialization
	b <- 56

	let d = Int() # d == 0
	d = 10 # error!

FUNCTION DEFINITION (1)
	# a typical Dexter function usually doesn't need brackets in its signature
	fun add a, b:
		return a + b

	var sum = add 25, 52

	# when brackets are used, there must be space(s) between the name and the open bracket
	fun sub (a, b):
		return a - b

	fun div a, b: # parameters are 'let' by default
		return a + b

	fun mul a, b:
		return a * b

	# you can annotate the argument and return types of a function
	#:: Int, Int -> Int
	fun mod a, b:
		return a % b

BLOCK DECLARATION
	var
		sum = 0
		count = 0

	def
		add a, b:
			a + b

		sub a, b:
			a - b

		div a, b:
			a / b
	..

	type # type declaration
		Person name, age
		Car make, model, year


EXPRESSION-ORIENTED
	var isNyproCrazy <- faveHobby == 'CountingBirds' # returns true or false to isNyproCrazy

	def add(a, b):
		a + b # 'return' is not needed here. result of a + b will be returned to the caller.
	..
	nypro.hieght = add(aditya.height, -tripleo.height)

	# a semi-colon at the end of a block, stops it from returning its evaluated
	# result
	def setName(var p = Person, var name <- Str()):
		p.name = name;
	..

	let name <- setName('John Smith') # error! setName returns no result.

SPECIFYING TYPES
	var number = 5
	var task <- Str('Create a programming language')

	let salary = Pay # type specification
	salary = Pay(5_000, 12) # construction.

	var identifier = Str|Int # optional type specification.

	var address = Int = 506 # initialization
	let job = Str() # default costruction.
	let task = Str # same as above

SOME BUILT-IN TYPES
	var index = UInt = 2_000 # UInt represents unsigned integer; no negative values.

	var debt <- Int = -100 # Int represents signed integer; you can have negative values.

	let e = F64 = 2.718281828459045
	let dogBreed <- Str = 'German Shepherd' # Str represents immutable UTF-8 string.

	var laptop = Chars = 'Alienware M18' # Chars represents mutable UTF-32 string.

	var listOfGroceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # this is a list.

	var game, year <- 'BioShock Infinite', 2014 # this is a tuple.

VALUES & REFERENCES
	# by default primitive objects (UInt, Int, Float, Bool) are passed around by value and
	# by default complex objects (Str, user-defined types) are passed around by reference.
	var number = 502
	var account <- .getAccount('Dumbledore')

	# however, you can change this behavior with 'ref' and 'val'.
	var newAccount = val account # passing a complex object by value.
	var pointer = ref number # passing a primitive object by reference.

	# Dexter uses compile-time reference counting to manage memory, unlike Python or
	# Javascript which use runtime tracing GC.
	# It also does reference cycle breaking at compile-time. :)
	myCompany.affiliate <- ref yourCompany
	yourCompany.affiliate = ref myCompany

	let myAccount = iso Account('Nypro')
	# iso means only the subject can hold a reference to the object.

	let player <- team.player

	# you can specify a dynamic subject reference beforehand
	let library <- iso

	def getAmount():
		return rd amount
	# 'rd' means an object is passed by reference, but it cannot be written to,
	# only read from.

	def swap!(var a = ref, var b = ref):
		a, b = b, a;
	..

NUMBERS
	var index = 5
	var axis = -3
	let meters <- 0.25e-5
	let salary = 10_000f
	var color = 0x6FFF00p+12 # hex
	var opCode = 0b10110001 # bin
	var interest <- 0o566768 # oct
    let pi = 3.14bf

ACCESS MODIFIERS
	var money = 0 # subjects, functions, types, etc. are public by default.
	var `laptopModel = 'HP Pavilion' # private to a module.

	# hidden functions and fields are accessible only by a type's methods and fields
	def .sub(a & b <- Num): a + b

READ-ONLY/WRITE-ONLY ACCESS MODIFIERS # @INC
	var wr `keep = []
	let rd pi = 3.14

TUPLES
	var name, age = 'Emeka Okorafor', 27 # this is an open tuple
    # name and age are assigned to 'Emeka Okorafor' and 27 correspondingly.
	var game, year = ('Uncharted 4', 2016) # this is a closed tuple
    # game and year are assigned to 'Uncharted 4' and 2016 correspondingly.

	# NOTE: an open tuple is passed by value, a closed tuple is not
	name, age <- age, name

	let make, year <- car.details()

	let index, car = 15, ('Ferrari', 1995) # car is a tuple.

	let map = () # empty tuple

	# named tuple
	let http200Status = (statusCode: 200, description: 'Ok')

PROPERTIES
	# properties provide getter/setter behavior, so that implementation
	# of a subject can be flexible.
	var age =
		set value:
			age = value - 4
		get:
			age
		..

    let name =
        set value: name = value
        get: !name.isEmpty ? name : firstname + lastname

	var name, attribute = 'Daniel Olaniyan', 15


LISTS
	var unorderedList = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

	var names <- [] # empty list

	var contestants = [Str]['Steve', 'Aditya', 'Sizwe', 'Pierre']

	# Dexter uses 1-based indexing, so every list indices start at 1.
	var disqualified = contestants.[mid:last] # 1st index to the 3rd index.

	var reversed = contestants.[-1:] # -1 is the 1st index from behind, i.e. the last index.
	# [-1:] means the last index to the 1st index.

	reversed.[2] # when indexing a list, there shouldn't be any space between
	# the subject identifier and the open (square) bracket.

	let myGarage <- [Car][('Mustang'), ('Eleanor'), ('Bugatti'), ('Lamborghini')]

	let yearSalary = [12 Int][] # you can specify a static size for the list.

	yearSalary.[1..3] = [2_000, 2_000, 2_500] # you can assign to a range of indices.

	let a = [
		1, 2
		[3, 4, # This line is [3, 4, 5, 6]
		5, 6]
	]

	var matrix = [2*2 Int][
		1, 0
		0, 1
	]
	var column2 = matrix.[1:,2] # Content on row 1 to end, on column 2.

	var matA = [2*age] [,] # 2 rows with unknown column length

	matA.[:,:] <- [
		[1, 6, 3]
		[3, 7, 4]
	]

	let subset = mat4.[1:, 1:2]
	var matB = matA * 2
	# vectorised operations
	var matA = matB *. matC # dot here signifies an element-wise operation.

	# Dexter's lists are by default, row-major order, but you can make it
	# column major by using the transpose function
	let y = [1, 2, 3]
	# 1 2 3

	let z = [1, 2, 3].tr
	# 1
	# 2
	# 3

	let x <- y.[..2].tr

	# splatting a list
	let a = [
		1, 2
		0, 4
	].tr

	...a
	# 1 0
	# 2 4

	# splatting a list exposes the content of the matrix as an open tuple
	# splatting a returns a 2-dimensional open tuple.
	let b = [
		...a.tr, ...a.tr
		...a.tr, ...a.tr
	]
	# 1 0 1 2
	# 2 4 0 4
	# 1 2 1 0
	# 0 4 2 4

	# proposed operations with lists.
	var concatenate = [1, 2] ++ [3] # [1, 2, 3]
	var multiply <- [1, 2] ** 2 # [1, 2, 1, 2]
	let subtract <- [1, 2, 3, 4, 3] -- [4, 3] # [1, 2]
	let divide = [1, 2, 5, 6, 3, 4] // [5, 6] # [[1, 2], [3, 4]]


DICTIONARIES
	# dictionaries are basically key-value lists.
	let family = [
		'mum':
			'name': 'Esther Williams'
			'age' : 41
		dad: # unquoted keys are taken as strings
			name: 'Sunday Williams'
			age : 46
		sister:
			name: 'Shade Williams'
			$attribute.[0]: 15
			# to a subject as a key, it should start with '$'
	]

	let sisterName = family.['sister', 'name']

	var professor = [
		$id1: 'Charles Xavier'
		$id2: 56
	]

	var name = house.['dad', 'name']

	let testScores = [
		'class room 1': [0, 15, 30, 15, 76, 50],
		'class room 2': 45, 50, 83, 9, 39, 81
	]
	var class1Scores = testScores.['class room 1']

	var contacts <- [:] # empty dictionary
	var user = [2*2 Str User][:]

LISTS, DICTS, INCLUSION, DIMENSIONS # NEEDS REVIEW !!!!!
    var a = [] # a list
    var b = [,] # a list containing another list
    var x = [:] # a dict
    var y = [::] # a dict containing another dict
    var z = [:,] # a dict containing a list
    var b = [,:] # a list containing another list, which contains a dict.
    var t = [12 Str Int] [:]
    var u = [7*5 Str Str Int][::]
    var u = [60*5 Str Int][:,]

OTHER TYPES OF LISTS
	var range = [1..20] # range is a type of list
	var indexer = list.[1..] # indexer is a type of list.
	# it holds ref to a subset of another list

PACKING & UNPACKING
	var list = [for x in 10: yield x] # [ ] turns a generator into a list.
	var open = ...list # ... turns a generator, list or closed tuple to an open tuple.
	var dict <- [:tuple] # [:] turns a closed tuple or a tuple generator to a table.
	var closed <- (a, b, c) # turn an open tuple to closed tuple

	let primes = [2, 3, 5, 7, 11]
	let numbers = [2, 4, 8, ...primes]

REST
    var a, ...b = 1, 2, 3, 4

    def sum(a, ...b):
        a + b.foldLeft 0, |a, b| => a + b
    ..

STRINGS
	let language = 'Dexter'
	let year <- 2015
	var story = "[language] was started in [year]" # string interpolation.

	let calc = '5 * 50 = [5 * 50]'
	# both single and double quotes can be used to represent a string literal.

	# String formatting
	println "The price is [price.%2f]"

	# non-standard string literals preceded by characters are not affected
	# by escape sequences, because they are processed verbatim.
	var verbatimStr <- r."Use '\t' to represent tab"

	# here string (DEPRECATED). first and last new lines are always ignored.
	var verbatimStr = '''
	Hello, World!
	'''

	var string = 'Hello' # Str
	var chars = ch.'Hello' # Chars

	# proposed operations with strings.
	var concatenate = 'ab' + 'c' # 'abc'
	var multiply <- 'ab' * 2 # 'abcabc'
	let subtract <- 'abcac' - 'ca' # 'abc'
	let divide = 'abcdeabc' / 'de' # ['abc', 'abc']
	let escapeSequences = '\t \n \' \" \[ \# \\'

	var greeting <- # multiline string.
	'Hello,'
	'World!'

MULTILINE EXPRESSIONS # @INC
	# expressions that spread accross multiple lines must be enclosed in brackets
	# or used with an isolated dot ending the previous line.
	var zero = - 100 .
	+ 100

	# notable exceptions :
	# statements expecting a bock-begin punctuator ':'
	if x < y
	& a == b:
		doTask()

	# assignment operator
    var x =
    25 + 6

	# fragmented string
	var greeting = 'Hello,'
	'World!'

	# comma operator
	sum 1, 2, 3, 4, 5, 6, 7, 8,
	9, 10, 11, 12

INDENTATION # NEEDS REVIEW!!!!!!
	let myName = nypro
		->name
		->strip!
		->reverse!
	->println

	if x == y:
		if a == b:
			doTask
	else:
		doNothing

	play music
		'Asa',
		'Jailer'
	.rewind 2

SANDWICHED STATEMENTS
	var faveSoccerClub =
	(team == 'Manchester United' ? (println 'You suck!'; team) : _)

	# you can sandwich multiple expressions where a single expression is expected.
	# by putting them in brackets.
	println('Hello, ', (println('World'); '!'))
	var add = ()

IF STATEMENT
	if isAdrianRich:
		spendAll('on parties')

	elif isOroboRich:
		spendAll('on legos')

	elif isSyconRich:
		spendAll('on suits')

	else:
		cry('we are broke')

	if phoneNumber == nil:
		useEmail()

	if var stockCode <- getStockCode('APPLE'): # block is evaluated if stockCode is not nil
		println('APPLE: [stockCode]')

	if copy = getCopy():
		println(copy)

	# the nesting problem
	# which 'if' does the 'else' belong
	if x > y:
		if y > z: _
	else: _
	# answer is the closest 'if'. To disallow this use a block-end punctuation
	if x > y:
		if y > z: _ ..
	else: _

	# nested if statements can be written together with their corresponding
	# else statements stacked accordingly
	if tim.age > 16 if car.state == 'good':
		tim.drive car
	else:
		raise Error 'Driver must over the age of 16'
	else:
		raise Error 'Car is in bad state. Repair immediately!'

NIL
	# sometimes, it is important to represent an empty or missing state, this can be
	# achieved in Dexter with optional typing.
	var code = Str # cannot be nil
	var program = Str|Nil = 'println \"Hello World\"'
	var anotherProgram = Str? = nil

	# a nilable cannot be assigned to a non-nilable subject without a proper
	# nil coalescing with a fallback value.
	var programList = Str()?
	var cartoonList <- [Str?][]

	let profile = server
		.user('Name')?{Account 'default'}
		.profile?{Profile 'default'}

	if feeds: println('no feeds') # = if feeds equals nil or false.

	(getAccount "default")?

	# nil-then-raise operator
	getAccount("Default")?! # if result is nil, raise NilError
	game.fix?!

	if isRecieving == nil:
		println('remote server stopped recieving')

	let john <- Person dave?.name # unwrapping a nilable object

	var isNight = true?

	if isNight:  # error # disambiguation needed
		wake dracula

	if isNight = true:
		wake dracula

CONDITIONS
	# Dexter discourages reptition in conditional expression.
	if x < y & y < z: doTask() # deprecation warning!
	if x < y < z: doTask()

	if x == y & y == z: doTask() # deprecation warning!
	if x and y == z: doTask() # if both x and y equals z.
	if x == y == z: doTask()

	if x == y | y < z: doTask() # deprecation warning!
	if x == y or < z: doTask() # if x equals y and also greater than z.

	if x == y & a == b: doTask() # no warning

	if x != y: println 'x does not equal y'
	if x not in list: println 'x is not inside list'
	if !x:  println 'x is not nil'

    if a.trim == b.trim: doTask()
	if |a == b|.trim: doTask()

	if x.trim and y.trim = z.trim: doTask()
	if |x and y == z|.trim: doTask()

FOR LOOP
	for i in [1..10]:
		println(i)

	let interestingNumbers = [
		'prime' : 2, 3, 5, 7, 11, 13
		'square' : 1, 2, 4, 9, 25, 36
		'fibonacci' : 1, 1, 2, 3, 5, 8
	]

	for kind, number in interestingNumbers: # parallel pairing through a dictionary.
		println('[kind]: [number]')

	# an extra tuple param serves as the iteration index
	for names, index in register:
		println index, names

	for name, (key, value), index in nameList, table:
		println name, key, value, index

	# looping through a number
	for num in 50: num

	for up, down in [1..20], [20..1]: # parallel pairing through ranges.
		println('[up] <::> [down]')

	for upper in [1..20] for lower in [1..20]: # @INC # nested iterations through ranges.
		println('[upper] -:> [lower]')

	for i in [1..20]:
		i += 1 # error! immutable subject.
		j <- i
	..

	for var i in [1..20]:
		i += 1
		j <- i
	..

	for _ in [1..fifty]:
		println 'Hello'

LIST COMPREHENSION
	var oddList <- [for i in [1..20] where i .mod 2 != 0: yield x]
	var oddList <- x || x <- [1..20] ~ x .mod 2 != 0
	fun times: x * y || x <- [1..10]; y <- [20..1] ~ even y

BLOCK SUBJECTS
	for color in colors:
		var hold i = 1 # a block subject's state persist for the duration of the loop.
		println(i, color)
		i += 1
	..

	def sum(list):
		var hold index = 1 # you can also have block subjects for recursive functions.
		if x.size < 1:
			return 0
		else:
			list.[index] + sum(list.[++index:])
	..

LABELS # @INC
	# labels allow you to break out of or continue a specific loop or block or function.
	for [class] class in classes:
		for student in students:
			if student.position == 'captain':
				record.save(student.name)
				continue class
		..
	..

    # return using a label
    def [addLabel] add a, b:
        def [inner] _:
            if a and b == 0:
                return [addLabel] 0
        a + b
    ..

	block [upper]:
		if x > y:
			play game
		else:
			break [upper]
		save game
	..

BREAK WITH
	for names in register:
		if name == 'Tony':
			break name
		""

IN
	if student.name in defaulterList:
		println('[student.name] hasn\'t paid yet. Contact parents')

	if 'ps4' not in birthdayPresents:
		println('Aaargh! Everyone hates me')

	if /dollar[s]?/ in sentence:
		println('Change occurrences of "Dollar" to "Pound"')

WHERE # @INC
	# where is used to establish an extensive condition especially where it is
	# not expected.
	if person in auditionRoster where person.mark > 40.0:
		acceptanceList.add person

	for book in library where book.title.contains('adventure'):
		personalLibrary.add book

WHILE LOOP & LOOP
	while file.hasNext():
		println(file.next())
	..
	# loop
	loop: # synonymous with while true
		println('>>> ')
		let input = scan()
		let tokens = lex(input)
		let ast = parse(tokens)
		let bytecodes = compile(ast)
		let result = interpret(bytecodes)
		println(result)

	loop:
		lines <- gen.readLine() # evaluated at least once.
	while gen.hasNext()

	while var user = genRandomUser():
		println(user.name)

	while list.size > 0 for name in list:
		print name, sp
		list .removeTop

TERNARY OPERATOR
	# ternary operator is a summarized if-else clause.
	var absValue = if a > 0: a \\ else: -a

	var absValue = a > 0 ? a : -a

	song in playlist ? play playlist.[song] : _

	# a ternary operator statement needs to be encapsulated in brackets
	# where a semicolon is expected
	if a == (b > c ? b : c): print a

BLOCKS AND LINES
	# a block represents a scope
	let country <- 'India'
	block:
		let country = 'Nigeria'
		println country # Nigeria
	..
	println country # India

	# block structures must be closed with a corresponding end punctuator '..'.
	for color in colors:
		var hold i <- 1
		println(i, color)
		++i
	..

	# but if the block only contains one line of statement, an end puntuator is
	# not necessary.
	def mul(a, b):
		a * b

	# a blocks statements can be defined on the same line as the block, with an
	# optional end puntuator.
	def div(a, b): a / b

	# multiple statements can be written on one line separated by semi-colons.
	var temp = a ; a = b ; b = temp

	# multiple blocks can also be written on the same line using the '\\' punctuator.
	if studio.isLive(): blockAccess() \\ else: openAccess()

FUNCTION DEFINITION (2)
	def multiply a, b:
		a * b

	# if a function returns nothing, it's return type may be `!` or left empty
	#:: Str -> !
	fun greet name:
		println "Hello [name]"

	# to make sure nothing is returned from a function you can use `;` to terminate an exit expression or `!` as the exit expression.
	def effect mood:
		if mood.isHappy:
			happySong->play;
		else:
			sadSong->play
			!
	..

	# varargs.
	#:: Int -> F64
	def arithMean ...numbers:
		var total <- 0d
		for number in numbers:
			total += number
		total / numbers.size
	..

	# there are two ways of calling a function in Dexter
	arithMean 1, 2, 3, 4
	arithMean.(1, 2, 3, 4)

	# anonymous functions ae nameless fuinctions
	# and they are excuted at the point its declared.
	def _:
		return a + b

	# the states of `keep` subjects are preserved between function calls.
	def callCount:
		var keep count = 0
		println '[count += 1]'

	callCount # 1
	callCount # 2

	# functions that change values of arguments must be annotated with `!`.
	#:: ref Person, ref Person
	def swap! var a, b:
		a, b = b, a;

	swap! john, jane

	# when an argument name isn't given, they can be referred to with their argument notation
	def add _, _: $1 + $2

	# default parameter values and shared value with `&` binder
	def login email & username & password = 'demo':
		access Account username, password

	login.(_, 'nyprothegeek', 'bazinga!')
	login.('nyprothegeek@gmail.com', 'nyprothegeek')

	# compulsory named arguments
	fun signUp .username, .password:
		access Account username, password

	signUp username:'appcypher', password:'bazinga'

	fun sendMessage message, .to.recipient:
		println (message + recipient).toUppercase

	sendMessage 'Hello', to:'Cantell'

FIRST-CLASS FUNCTIONS
	# creating new functions from existing functions
	var details = getDetails$ User
	var plus = add$ 0, 0
	fun times = mul F64, F64

	var binaryOp = (Number, Number -> Number)
	var binaryOp = Func{Number, Number, Number}

	var range = fun _:
		for i in [..11]:
			yield ++i

	# passing functions to functions
	fun compress image, f = (Int, Str -> Int):
		f image

FUNCTION PATTERN MATCHING

BRACKETLESS CALL
	def plus(a = Numero, b = Numero):
		Numero a.value + b.value
	def minus(a = Numero, b = Numero):
		Numero a.value - b.value
	def sum(...args = Numero):
		Numero args.fold add$

	var numero1 <- Numero 15
	var numero2 <- Numero 70

	var numero3 <- numero1 .plus numero2 .minus Numero(23) # bracketless function call
	var numero4 <- numero1 .sum numero2, numero3 # tuple args passed to a bracketless
	# sum

	5 .plus 6 .minus 7 == 5.plus(6).minus(7) != 5.plus(6.minus(7))
	5 .plus (6 .minus 7) == 5 .plus(6 .minus(7))

	loop: println('>>>', scanln() .lex .parse .compile .interpret)

	# using '(' and ')' to enccpasulate a bracketless call can make it more readable
	profile ->(deleteContact 'Tosin', 'Tunde') ->changeAvatar '/album/grad/0123.png'

	makeCar make:'Toyota', model:'Sienna', date:(Date 1, 1, 17)

	# GOTCHAS to watch out for
	# commas belong to the outermost function call
	foo bar bin, ben # parsed as foo((bar bin), ben)
	foo bar(bin, ben)

	# a function always takes the closest brackets
	print (bin + ben).size # parsed as '(print(bin + ben)).size'
	print((bin + ben).size)

	# when using operator names as a function call, always enclose it in brackets
	foo + bar # parsed as '(foo + bar)'
	foo +(bar)


BRACKETLESS CALL VS ELEMENTWISE
	var mA, mB = rand(5, 5)

	mA + mB
	mA * mB
	mA.plus mB
	mA .times mB

	mA +. mB
	mA *. mB
	mA.plus. mB
	mA .times. mB

	mA.cross.(mB)
	mA .cross. mB

CONSECUTIVE CALL CHAIN
    # consecutive call chain can nly be used with functions with one or more arguments
	check(lhs); check('=') ; check(rhs) # can be shortened to
	check(lhs) >> ('=') >> (rhs)

	println 'Hello' >> '[name.isEmpty?'John Doe':name]' >> '!'

	var e = Employee
	e.setName 'Badmus' >> 'Travis' >> 'Gabriel'

	# consecutive call chain tupling
	let tony, barn, rod <-
		list.getPerson 'Anthony', >> 'Barney', >> 'Rodney'

FUNCTIONS AS ARGUMENTS & LAMBDAS
	# a function can be passed as an argument.
	let scoreListWithExtraMarks = scoreList.map(def _(score): score + 5)
	let scoreListWithExtraMarks = scoreList.map(myFunc$)

	fixtureList .filter |game| => !game.isCancelled
	fixtureList .filter => !$1.isCancelled
.
	var pplBelow25 = census.filter |person| => (
        person.age += 1
        person.age < 25
    )

	greet 45, => (
		println "Hello"
		println "World"
	), true

	var foo = def _(name): println 'Hi [name]'
	var foo = |name| => println 'Hi [name]'
	def foo(name): println 'Hi [name]'

CLOSURE
	# a closure is an inner function.
	def genDBConnector(:host & :username & :password = Str):
		def makeDBConection():
			return db.connect(host, username, password) # a closure can be returned.
		makeDBConection
	..
	var dbCallback = genDBConnector(host:'localhost', username:'nypro', password:'willdiearobot')

	# nameless closures are executed at point of definition.
	def basicOps(number):
		var calc = 0
		def _():
			calc += number
			calc *= number
			calc /= number
			calc -= number
		..
		calc
	..

OUTER SUBJECTS
	let state = 'Idle'

	def changeState(state = Str):
		if state != nil:
			activateState(state)
		else:
			activateState(outer.state) # outer refers to the parent scope.
	..

COFUNCTIONS # @INC
	def remove!(var list = [], index = Int):
		list -= list.[index]

	remove$ += refreshUI$ # attaching a cofunction to a generic overload.
	emit movieList.remove(2) # emit is used to run the function along with its cofunctions.

	remove$(List, Int) += refreshUI$ # attaching a cofunction to a specific overload.

USEFUL FUNCTIONS # @INC
	typeOf(24)
	size [1, 2, 3, 4] # size is a constant-time operation.
	count("Hello, world!") # count may be a linear-time operation.
	iter array, 5 # array{5:3}
	enumerate array # for x, y in array
	map names, => $1 + ' '
	filter(list, |a| => isPrime a)
	each list, => (println $1, ', ')
    eachIndex list, |i, e| => println "[i]: [e]"
	noneMatch numbers, |a| => isEven a
	printf('The circumference of a circle with radius 5 is %f', pi * 5^2)]
	respondsTo(object, add$)
	getHighest list
	getLowest list
	getRank list, 21

USEFUL CONSTANTS
	nl == '\n'
	sp == ' '
	tb == '\t'
	cm == ', '
	bk == '\b'
	pi == 3.1415926535897
	e == 2.7182818284590

CACHED EXPRESSION
# sometimes one needs to cache an expression for an iterative task, without declaring a variable.
var num = 25
for it in [1:*(num*2)]:
	print it

MATCH EXPRESSION & CASE STATEMENT
	# match statement is like switch-case.=
	for char in chars:
		match char
		| '\0': println 'This is a null character'
		# '|', '~' returns immediately after evaluating block.
		# spill is used to go to the next with or where
		~ isNumber(char): println 'This is a null character'; spill
		~ isAlphabet(char): println('[char] is ascii')
		~ isHangul(char): println('[char] is hindu')
		~ _: #= default =# println "This is the default block"
	..

	# there's no need for a 'match' keyword if a match starts a function
	def status message:
		| Int: println message
		| Started("Fail"): println message.info
		| Started(info): println info # named match
		| Started($info): println message.info # using an info subject from outer scope
		| Terminated("Success"): println message.info

	# same applies to loops and if bloocks
	while turn != 'y' or 'Y' or 'n' or 'N':
		| 'y' or 'Y': return 1
        | 'n' or 'N': return 0
        | _: print "its an invalid choice."

	def opCodeDispatch(opCode = Str, args = [], var index & result = Int):
		result <- 0
        match opCode
		| 'ADD' : return result = args.[index] + args.[++index]
		| 'SUB' : return result = args.[index] - args.[++index]
		| 'MUL' : return result = args.[index] * args.[++index]
		| 'DIV' : return result = args.[index] / args.[++index]
		| 'EQ'  : return args.[index] == args.[index+1] ? index += 3 : spill
		| 'JUMP' or 'SKIP' : index += args.[index += 2]
		println 'Opcode error!'
	..

COROUTINES # NEEDS REVIEW !!!!!!
	# Coroutines run concurrently, but cannot run parallely.
	def genRandRange(n = UInt):
		yield rand().range n
	..

	for i in [1..10]:
		yield i

	var don = for i in [1..45]: yield i
	let bin = don([..]) # synonymous with yield from
	let bon = don([1..3])

ASYNC AND AWAIT # NEEDS REVIEW !!!!!!
	def asyn getPerson name:
	    let p = await getPersonFromServer name.split /\s+/
	    yield p->name, ->age
	..

TASKS, also ACTORS # NEEDS REVIEW !!!!!!
task Task:
	var name, time = Str, Int

	def init name:
		self.name = name
		self.time = random([1:1_000])

	def task sleep:
		println "[name] is sleeping for [time]ms"
	    sleep time
	    println "[name] is done"
..

var
	t1 = Task("Task-1") ->sleep
	t2 = Task("Task-2") ->sleep
	t3 = Task("Task-3") ->sleep

STREAM
ones.twos.threes.collect
collect(threes(twos(ones())))

def ones: yield 1
def twos(@Generator): yield gen + 2
def threes(@Generator): yield gen + 3

def collect(@Generator):
    list = []
    for i in gen: list .append i
    list
..

TYPE DEFINITION
	type Animal:
		let name & kind = Str

		def
			init name, kind: # constructor
				new name, kind

			eat:
				'Eating'

			sleep:
				'Sleeping'
		..
	..


	# types in Dexter do not necessarily need to have their functions defined inside them.
	# This allows for future extension of a type without touching the type's source code.

	type Car:
		var make, model = Str
		let year = Int
	..

	def move(c = Car):
		"Moving"

	# construtors that call new can only be defined in the same
	# module as the type. Same applies to destructors.
	def Car(make = Str):
		new(make)
		# new is a special function that creates a new object and maps
		# the arguments to corresponding fields
	..

	def Car(maker, model, year)
	def Car(~) # normal # called on Car object during destruction. # @INC
	def Car(!) # exception # called on Car object during an exception. # @INC
	type Person(var .name & age) # Person is a constructor type.
	# Constructor types have just main constructor and the parameters
	# of the constructor are mapped to fields.

	var john = Person('John Connor', 23)

	type Lamp(color)
	var yellowLamp = Lamp('Yellow') # Lamp subject declared with an initialization.
	var blueLamp = Lamp # Lamp subject declared but not initialized.
	blueLamp.color = 'Blue'

FIELD ACCESS MODIFIERS
	type Singleton:
		# hidden fields can only be accessed by type's functions.
		var keep .count = Int = 0
		# the states of pinned fields persist throughout a type's lifetime, and that's
		# the program's lifetime.
		var keep .sole = Singleton
		var value = Int

		def .init:
			if self.count == 0:
				++count
				return self.sole = new value
			..
			self.sole
		..
	..

	def Singleton(value = Int):
		var x <- Singleton
		x.value <- value
	..

FIELD EXTENSION
	type Programmer(specializedLanguages) <: Person:
		let languages = [Str][]

	def main:
		let orobogenius = Programmer
		orobogenius.languages <- ["Java", "PHP", "JavaScript"]

		let appcypher = [Programmer] ["Dexter", "Java", "C++", "Python"]
		appcypher.+philosophies = ["Open Source", "Transhumanism"]
		appcypher.+resume = "chicken.poop.com/appcypher"
		appcypher.+mentor = "Captain Jack Sparrow")
	..

INHERITANCE # @INC
	type Animal
	def sound(@Animal):
		println('Nothing')

	type Bird <: Animal
	def sound(@Bird): # overrides supertype function.
		println('Chirp!')

	type Horse <: Animal:
	def sound(@Horse):
		println('Neigh!')

	# Dexter supports multiple inheritance.
	type Pegasus <: Horse, Bird:
	def sound(@Pegasus):
		Horse.sound(pegasus)

	# due to Dexter's multiple dispatch, Inheritance applies equally to all
	# arguments of a function.
	type A
	type B <: A

	def foo(a = A, x = X):..
	def foo(b = B, x = X):.. # this overrides top

	def bar(x = X, a = A):..
	def bar(x = X, b = B):.. # this also overrides top

	# a super method can be called directly or by using super
	def baz(x = X, a = A):..

	def baz(x = X, b = B):
		baz(x, b as super)

	def baz(x = X, b = B):
		baz(x, b as A)

	type Person(var name & gender = Str, age = Int)

	type Employee(var job & company = Str)<: Person

	def Employee(name, age, job, company):
		new(Person(name, age), job, company) # construction merging.

	def Employee(name, age, job, company):
		new(super(name, age), job, company) # construction merging.

	def print p = Person: print p.name, p.age
	def print e = Employee:
		super.print # or print e as super
		print sp, e.job, e.company
	..

ABSTRACT TYPES & FUNCTIONS # @INC
	type abst Player # abstract types cannot be instantiated.

	# a function without a body (apart from constructors) is an abstract function and
	# an error is raised if it is called directly. An abstract function is expected to
	# be implemented by a corresponding subtype function.
	def play(pl = Player)
	def rewind(pl = Player)
	def fastForward(pl = Player)

	type DigitalPlayer <: Player
	def play(dpl = DigitalPlayer): # this overrides and implements play.
		initPlaylist()
		startPlaylist()
	..

	# Here is an example using abstract types to simulate Algebraic Data Types.
	type abst Tree
	type Leaf(value = $T) <: Tree
	type Node(l = Leaf, r = Tree) <: Tree

	def sum(t = Tree):
		| Leaf: t.value
		| Node: sum(t.l) + sum(t.r)
	..
	var x = Node(Leaf(1), Node(Leaf(2), Leaf(3)))

ANONYMOUS TYPES # @INC
	# an anonymous type is a singleton with an ad hoc type definition.
	# which include the type's fields and functions.
	(
	type _(state) <: Thread:
		var state = 'Paused'
		def start:
			println('Thread: [self.state]')
	..
	)('Working')

	var currentShow =
		(type _(show, host)) 'DareDevil', 'Netflix'

	currentShow.show

TYPE CHECKING
	if myCar :: Car:
		println('myCar is a Car')

	if myCar == Car:
		println('myCar is a Car or its subtype')

	if myCar <: Car:
		println('myCar is a supertype of Car')

	if myCar >: Car:
		println('myCar is a supertype of Car')

REFERENCE CHECKING
	let a = Person 'John Smith', 25
	let b = a
	let c = val a
	a =:= b # true
	a =:= c # false
	(one =:= other) == (one.ref == other.ref) # true

FUNCTION == METHODS (UFCS)
	def show(p = Person):
		println(self.name, self.age)
	..

	show nigel
	# In Dexter, a function is a method of its first argument.
	nigel.show

	# The only two set of functions that cannot be used with dot operator are
	# contructor functions and new functions.
	type Robot:
		var name, uniqueID
	..

	def Robot(name, uniqueID):
		new(name, uniqueID)

	var wall_e = Robot 'Wall•E', 215


CALL CHAINING
	# return chain.
	var result = 8.plus(6).minus(4).times(2)

	# tail object chain
	# a convenience syntax in which the intial associated object is returned to.
	profile->open()->deleteMsgs()->close()

	# returned object forwarding.
	buffer ->resize!(13) ->fill!(0, $)

	# consecutive call chain
	var e = Employee
	e.setName 'Badmus' >> 'Travis' >> 'Gabriel'
	e.setName 'Badmus'; e.setName 'Travis'; e.setName 'Gabriel'

	# chain tupling
	var name, version = haskell ->name, ->version
	var first, second = 8 + 1, >> + 45
	let tony, barn, rod =
		list.getPerson 'Anthony', >> 'Barney', >> 'Rodney'

	# shared dot or arrow
	|a == b|.size ? a : b
	println |topEdit, bottomEdit|.getStr


COVARIANCE  # @INC
	type Person(name, age)
	type Employee(super(name, age), job) <: Person
	type Teacher(super(name, age), course) <: Person

	def show(p = Person): # a covariant parameter can take a subtype too.
		println p.name, p.age

	show Person('Tony Stark', 36)
	show Employee('Peter Parker', 17, 'Photographer')
	show Teacher('Diana Lane', 12, 'Biology')

	var people = [Person][Teacher(), Employee(), Employee(), Teacher()] # a covariant list.

IMPLICIT CONVERSION # NEEDS REVIEW !!!!!!
	# To be removed
	var boolean = Bool = 8 % 2
	var float = Float = false
	false == 0.0 # = true
	0 == 0.0 # = true

TYPE CASTING
	var radianInt = Int(2 * pi) # the resulting value Float of 2*pi is casted to Int.

	# overloading a cast function.
	def Employee(@Person):
		Employee(self->name, ->age)
	..

	var deitel = Person('Paul Deitel', 57)
	var editor = Employee dietel

	var yearStr = Str 1990
	let sorted = Int yearStr.sort!

	def MyInteger num = F64: new(Int num)
	let cost = (MyInteger price) * qty

NAME ALIASES
	type Number = Integer|Float|Complex
	def cheb <- chebyshevCoefficient
	let pi = thisIsAPiConstant

FUNCTIONS, TYPES, SUBJECTS
	type T = Int
	def foo = bar(5, 6)
	var
		qux = 5
		doo = bar$('a', 0)
		day = F64$

	def mix a:
		| 1: Int
		| 2: def add a, b: a + b
		| 3: 25
	..

	type Y = mix 1 # error
	def von = mix 2 # error
	let vim = mix 2 # ok

MODULES AND IMPORTS
	import com.example.(math pi, gcd, abs)

	import com.example.[(math pi, gcd, abs), (test scores, students)]

	import com.example.math ?

	import com.example.[?]

	import com.example.math var, let, enum, type, def

	import com.example.math var ! pi, e # this excludes the import of gcd and abs

    import com.example.math pi = π, gcd = greatestCommonDivisor

	# global subjects and function subjects can only be passed by value from one module to another.

GENERICS # @INC
	def add(a & b & c = $T): # declaring a generic type T.
		var d = T
		d = a + b + c
	..

	var sum = add{Int} 2, 4, 6
	# if the generic parameter can be readily inferred, then a type argument
	# can be ommited.
	var sum = add(2, 4, 6)

	type MyList:
		var list = [$T][]

	# a function can use the generic type of any of its parameters' types.
	def append(ml = MyList, item = $T of ml):
		self.list += item

	# a generic parameter that stands as a value of a particular type.
    type MyList: # NEEDS REVIEW!!!!!!!
        var length = $T($len::T)

	var ch = MyList{Int, 5}

	type Table id:
		var id = $len::?

	var table = Table('Hi')

	let parent = $S{<:Bone} # generic type S where S is a subtype of Bone.

	let identifier = $T{::Str|Int} # generic type T where T is either Str or Int.

	var image = $U{::Image{T}} # generic type U is exactly Image{T}.

	def hello(msg = $T):
		if T != Str:
			println('wrong type, [T]')
		else:
			println('hello, [msg]')
	..

	var x = 10
	let y = ${x} # this makes y have the same type as x


	def secToMin(int = Integer, sec = Float):
		$(int) sec / 60
	..

	Int.secToMin sec:24.45

TYPE OBJECTS # @INC
	# unconventionally, Dexter has Type objects which can be held by subjects.
	# Sometimes, this concept may clash with generics, but they are basically different
	# constructs with overlapping features.

	var number = $(Bool) # covariant subject
	# number can hold Bool.type or its subtypes.

	Int <: Integer # true

    def haveSameTypes(x, y):
        x and y == $(x)
    ..


ENUMS
	# in a way, enums are types that contain declaration of subtypes.
	enum Days:
		Sunday, Monday, Tuesday, Wednesday, Thursday, Friday

	var today = Days = Friday
	today = Tuesday

	# using allows an enum element to be used without the parent namespace.
	# hiding disallows it. enum elements are using by default.
	using Days
	using Days Sunday, Monday
	hiding Days

	def todo day = Days:
		| Sunday: sleep
		| Monday: work
		| Friday: tgif
	..

	enum Integral:
		UnsignedIntegral(value = Unsigned)
		SignedIntegral(value = Signed)
	..

	# enums can have field too, which enum elements inherit
	enum Cars:
		let make, model
		Mustang
		Ford
	..

	# enums can inherit from other enums and types.
	# it's more of inclusion than inheritance
	enum NewTools <: OldTools:
		Unity
		Django
		SASS
	..

	# Algebraic Data Types
	enum Tree:
	    Leaf value = Int
	    Node left = Tree, right = Tree
	..

	def sum t = Tree:
	    | Leaf v: v
	    | Node(l, r): sum(l) + sum(r)
	..

MODIFIER BLOCK
	def
	    asyn foo zee:
	        parametricAngular 35 / zee

		task grope:
			ping pong

	    norm grun zoom, ping:
	        ping = ping + sieze zoom
	        pandora ping

	var
	    keep xafora = await foo
	    norm generativePlug = yen 45.6 * pi
	    hold fred = Person zenithName, zenithAge

	type
	    abst Pandora galacticConstellationNumber

	    norm BananaRepublic state, country

	    enum Days:
	        Sunday, Monday, Tuesday, Wednesday,
	        Thursday, Friday, Saturday
	    ..

	    task NewTask

OPERATOR OVERLOADING # @INC
	call()
	setIndex()
	getIndex()

    object->[1] # object->getIndex(1)
    object->("Hi") # object->call("Hi")

	# special characters
	# these are characters that cannot be combined with conventional identifier
	# characters to form new identifiers. The only exclusions to this are
	and, or, not, in # they can be used in conventional identifiers
	# special operators are to be infixed without the dot notation.

	operator "right", 20: # position, associtivity, precedence level
	def <<<(stream = SumStream, num = Int): stream.add num
	sum <<< 40_290 <<< 5 <<< 70

	def =(r = Rango, list = List): self.populate = list
	var x = Rango = [1, 2, 3, 4]

	# indefinite characters
	# these characters can only be used with other special characters of
	# the same set to create new special identifier.
	=, <-, +, -, *, /, ^, √, &, |, >, <, =(special chars),

	# definite characters
	# these group of characters cannot be overloaded as is, but can be combined
	# to form new identifiers.
	(special chars)=, ::, <:, >:, >>, <<, ., ~, =>, !

	# language-level characters
	# this group of characters cannot be overloaded nor can they be combined
	# with other special characters to form new characters.
	->, ,, ., $,

	# due to their special use in the laguage, some spcial characters cannot be overloaded as a postfix or prefix.
	/, |

	# overloading special characters
	operator "postfix", 20:
	def ++(n = Number): t = n ; ++n ; t

	# calling an operator as a function
	operator 'postfix', 57:
	def +(n = Number): n = n.abs;
	play (+ 56)

    # identifier characters can be used as operators must be surrounded by spaces.
    operator 20:
    def ϵ(a, b):
        a in b

    if a ϵ b: println "Booyah!"


TRY, CATCH & ENSURE
	# try is optional
	file->open('banana.png')->println([1..50])
	catch _(err = Error):
		| FileNotFoundError: printErr(err.msg)
		| IndexOutOfBoundError: printErr(err.msg)
	..

	# a catch function can only be defined after its call sites

	process(bigData)`err
	catch err divError = DivByZeroError:
		println self.msg
	ensure: # a catch can be accompanied by an ensure block.
		rollBack(bigData)
	..

	# error coalescing
	f ->open('banana.png')`ferr->write('Hello')
	catch ferr(fnfe = FileNotFoundError): println self.msg
	# after handling an error, the exec flow continues after the catch declaration.
	# So it can be useful to redeclare a catch function.
	f.open('banana.png')`ferr
	# DO SOMETHING
	catch ferr
	# DO SOMETHING ELSE
	catch ferr(fnfe = FileNotFoundError): println self.msg
	ensure: f.close

	memory.[name]`{0} # catch all
	memory.[name]`{KeyNotFoundError|NoValueError: 0} # catch specific exceptions

	try let f = open('/sdcard/db.sql'): # try's are used for managed resource
		f.write(data)

	# the normal try catch is supported
	try:
		f.open('banana.png')
	catch @FileNotFoundError:
		print self.msg

	if num and den == 0:
		raise DomainError() # raising an exception.

MACROS # @INC # NEEDS SYNTACTIC REVIEW !!!!!!!
	# Dexter macros are resolved at parse time.
    # rather than using the AST, Dexter macros work on parse tree.
	macro reverseExpression(binExpr = BinaryExpression):
		return binExpr->rhs, ->op, ->lhs

	var half = reverseExpression 2 / 4

    macro assert cond = IfExpression:
        let line = cond.lineNumber
        return
        <
            if !<cond>:
                println 'assertion [<cond>] failed on line <line>'
        >
    ..

	assert num and den != 0

    macro class
        params = ParamExpr,
        iden = Identifier,
        colon = <:>?,
        body = TypeBody? # the '?' means optional
    :
        if body and colon != nil:
            return <type>, iden, params
        return <type>, iden, params, colon, body
    ..

    class Person name, age:
        let name, age = Str, Int

OTHER LITERALS # @INC
	let fraction = 3//2 # rational numbers.

	var complex = 1 - 1im # complex numbers.

	var regex = /\d+(.\d+)?/ # regex.

    var block_regex = ///^ (
      ?: [-=]>
       | [-+*/%<>&|^!?=]=
       | >>>=?
       | \.{2,3}
    )
    ///

	# non-standard literals
	var ns_number = 345_NGN
	var ns_str = ns_'1, 2, 3, 4'
	var ns_list = ns_[1, 2, 3, 5]
	var ns_dict = ns_[name: 'Steve', age: 24]
	let ns_tuple = ns_(name: 'Steve')

    # builtin non-standard literals
    var raw_string = r."\t represnts a tab character"

BUFFER TYPE
	# buffer is a base array that types like List, Str, Chars use to build their internal
	# array structure.
	let int5 = Buffer{Int}(5)
	# You can resize and also fill a buffer.
	let buffer = Buffer{Int}(10, 10).fill!(0)
	buffer ->resize!(1, 20) ->fill!(0, $)

BASIC ARITHMETIC OPERATIONS
	let t = 2 + 2
	let u = 5f * 20d
	var v = 5 / 2 # this returns an F64 even though the operands are Ints
	var w = 5 ~/ 2 # this returns a clamped Int result of the above
	var x = 6 % 5
	let y = 5i16 ^ 2_i8
	let z = I8(√25)

INTEGER BITWISE FUNCTIONS
	var x = 2 .bitand 5 # and
	var y = 3 .bitor 6 # or
	var z = 6 .bitnot # not
	var a = 7 .bitxor # exclusive or
	var b = a .bitshl b # bit shift left
	var c = b .bitshr a # bit shift right

PREDEFINED TYPE HIERARCHY # @INC
	Any
		Type
		Func
		Indie
			Real
				Integer
					Signed
						Int, I8, I16, I32, I64,
					Unsigned
						UInt, U8, U16, U32, U64
				Float
					F32, F64
			Complex
				Cmp64, Cmp128
			Bool
		Array
			Buffer
			List
				AbStr
					Str, Chars
				Range
				Indexer
			Tuple
				Name Tuple
		Generator

COMPILER DEPENDENCIES
- libffi    (foreign function interface)
- gmp       (bignum)
- libprce   (regex)
- libmill   (goroutines)

# END
