Revised 11/08/16
# 2016.0.8.2
#=
Major Change:
    Restructuring for Multiple Dispatch
    Import is now module-based, rather than being type-based, due to the introduction of multiple dispatch
    A type's method may be defined outside the type's file
    Added def to function declaration #18/08/16
    Changing assignment operator back to good ol' way, binding to nil-and-one-other-type is still enforced 19/08/16
    The block punstuation is now $, it helps resolve some ambiguity in statements like repeat play() | while state == "Play" | x == y ? y | z
        repeat: play() $ while state == "Play" | x == y ? y $ z
    Added mut for mutable variable declaration; solves some scoping issues
=#

PLUTO's DESIGN PHILOSOPHY
- let it do more with less
- make it fast
- make it legible
- make it consistent
- make it flexible. Dynamic and statically typed
- make it lightweight

DESCRIPTION
Pluto is a compiled/interpreted language that supports optional typing without sacrificing performance as a result.
Pluto is completely object-oriented and procedural at the same time. This is in part achieved by closely associating types with multiple dispatch in functions.
Some of Pluto's features include list comprehenshion, generics, closure, lambdas, mutiple dispatch


--! THE EXAMPLES BELOW ARE MOSTLY STATICALLY TYPED !--
SINGLE-LINE COMMENTS
   # Hello


MULTILINE COMMENTS
   #=
   I'm Pluto
   I'm cool
   =#


DOCUMENTATION
   # <code> Car </code>  class is deprecated # xml
   # [ code: 'Car' ] class is deprecated # deplu


VARIABLE DECLARATION & INITIALIZATION
    # Unlike Python, Pluto requires explicit variable declaration before usage
    mut x # is a mutable
    let y # is a constant
    def add(a, b): rt a + b # function parameters are implicitly mutable
    def swap!(mut a, mut b): a, b = b, a # error! mut should not be specified in their declaration
    mut e ; e = Car('Camaro') # semi-colon is used to separate two statements
    mut y = 12f
    mut z = 'Hello'
    mut a = Car('Camaro')
    mut b = Car('Camaro').setDate(2014) # ok
    mut n = getCar('Camaro')
    mut o = add(2, 4)
    mut p = List<Car>(3) # generics
    def add (a b c = UInt) Int
    def add (a = 1, b = 2, c = UInt(3)) UInt


SPECIFYING TYPES
    # type specification in declaration refers to what types a variable can be bind to appart from None
    # variables are generally bound to two types None and any other one type
    # however type specification can extend the number of types a variable can be bound to
    # p = None & ?
    mut p = Person # Person and Person's subtypes
    mut p =: Person # Person
    mut p <: Person # Person's subtypes
    mut p >: Person # Person's supertypes


VARIABLES AND REFERENCES
    # Value types such as Int, FLoat, et. are passed around by value, reference and container types are passed
    # aroud by reference
    # see pass table below
    mut pet = own getObject() # pet now holds a sole strong ref to the object returned
    mut pet = iso getObject() # pet exclusively exclusively refers to the object returned (if it is a value object)
    mut put = val pet # assigned by value
    let pat = move put # ownership moved from put to pat, put is now nil
    let pen = own move pat
    mut pot = read pat # pot references object but cannot assign to it
    # side effect of read:
    # if later in the future a variable is changed to read, it will lead to having to change code that have assigned to it, which can be a lot. :'(
    let pit = val put

    def subtract(let a let b let c = ref):
        c = a - b
        rt ref c
    ..
    mut dean = val subtract(x, y) # gets a copy
    let cop = subtract(x, y) # gets a ref

    def add(a b = ref):
        rt val a + b
    let alm = ref add(val x, val y) # warning, return a val to a ref

    swap!(val a, val b)


OPTIONAL TYPE DECLARATION
   mut myNumber = Str|Int
   # every varaible is optional implicitly to None and one other type (and its subtypes)
   # however this behavior is changeable using other assignment operators like =:, <:, etc.
   mut myNumber = '01000999'
   # might change the behavior below in the future
   mut myNumber = 23 # error! variable already bound to String


CONSTANT VARIABLE DECLARATION
   let x = 25
   let y = Car('Camaro')


MULTIPLE ASSIGNMENT
   mut a, b, c = arr[2:4]
   mut x, y = y, x
   let a, b, c, d = [1:4]


NUMERIC LITERALS
    mut d = 2 # Int
    let r = 2.5 # Double
    let e = 2f # Float
    let m = 3d # Double
    let y = 4_567.32f # Float
    mut x = 1_000_000 # Int
    let y = 1_999.99 # Double
    mut v = 12_000_i32 # Int32
    mut w = 145_ui18 # UInt16
    mut z = .1 # Double
    mut p = .2e-2f # Float


ARRAYS / LISTS
   # major diff between lists and arrays is that, the type and size of an array are
   # inferrable at compile time, this allows for arrays to be stored like traditional array
   mut fin = Car[('Camaro'), ('Mustang')]
   mut gin = 3 Car[] ; mut gin = Car[('Camaro'), ('Mustang'), ('Maserrati')]
   mut tin = 3 [Car('Camaro'), Car('Mustang'), Car('Maserrati')]
   let ted = [1, 2, 3, 4, 5]
   mut top = ted
   mut go = 5 Vehicle[Car("Camaro"), SuperBike("Ducati Multistrada"), Plane("Boeing 747")] # covariance in container
   mut go[1] = Car("Camaro")
   mut go[2:] = Car[('Mustang'), ('Maserrati')] # starts filling from index 2

   mut pot = Array
   # or better
   mut pot = []

   mut pit = Array{Int, 3} # an Int array with the size of three
   # or better
   mut pit = 3 Int []

   mut pet = [5] # this is an array with one element, 5
   let put = 5 []
   let pat = 4 [1, 2, 3, 4]

   let pat.foldleft(0, def (a, b): rt a + b) # (((0 + 1) + 2) + 3) + 4 = 10
   mut mat = getArray()
   mut net = getArray() # error, array not exposed, so '[]' must be used
   list(go) # list elements row-wise
   list(go[_col]) # list elements col-wise
   mut dean = Array
   mut dean = [10, 8, 6 ,4, 2]


DICTIONARIES / TUPLES
    # the major diff between dict and tuple is that
    # tuples are not key based and don't have colon after their "key" element
    mut tup = ['Tola', 1.2, 50, 'Tola']
    mut dict = [
        'Peter Parker'   : 'Spider-man'     , 20 |
        'Steve Rogers'   : 'Captain America', 32 |
        'Tchaka Tchalla' : 'Black Panther'  , 29
    ]
    let candidate = index, name [
        1 : 'Aditya' |
        2 : 'Nypro'
    ]
    list(candidate.index) # 1, 2
    let aditya = Str Int Int ["Aditya Singh": 19, 6.2]
    let aditya = (name, age, height) Str Int Int ["Aditya Singh", 19, 6.2]


ARRAY SLICING
   arr = [1, 2, 3, 4, 5, 6]
   print(arr[1:3]) # first index to the third
   print(arr[:5]) # first index to the 5th index
   print(arr[3:_last]) # 3rd index to the last
   print(arr[-3:]) # from the 3rd index starting from the back
   newArr = arr[:] # all elements
   list(arr[_last:]) # list from behind


MULTIDIMENSIONAL ARRAY
    mut arr = [,]
    mut arr = 2x2 [1, 2 | 3, 4]
    let arr = 2x2x2 Int [1, 2 | 2, 3 || 4, 5 | 6, 7]
    mut arr = [1, 2 | 3, 4]
    list(arr [:])
    list(arr[2, ]) # list columns in row 2
    list(arr[, 2]) # list rows in col 2
    mut arr = [1, 2] # vcat
    # 1 2
    mut arr = [1, 2 | 3, 4] # vhcat
    # 1 2
    # 3 4
    mut arr = [1 2] # hcat
    # 1
    # 2
    mut arr = [1 2 | 3 4] # hvcat
    # 1 3
    # 2 4


ACCESSING ARRAYS
    list = Person[("Dave", 25), ("Tony", 45), ("Spencer", 18)]
    mut names = list.[name] # returns a list of name fields in the list
    mut ages = list.[age] # returns a list of age fields in the list


ARRAY OBJECT ARITHMETIC AND COMPARISON OPERATIONS
    # Operations are element-wise
    if arr1 == arr2: list(arr1)
    let arr3 = arr1 / arr2


MATRIX-VECTOR OPERATIONS # column major order
    mut mP = 2x2 [2, 4, 3 | 3, 1, 5] * [3, 10 | 4, 2 | 1, 7]
    mut mX = Mat.identity(2, 2)
    mut mY = 4x2 Int [
        1, 1, 1, 0 |
        0, 1, 1, 1 |
    ]

    let mZ = mX / mY
    mut mRows, mCols = m.size()
    let mQ = mXâ€™ # z is assigned transpose of matrix u


STRING TYPE
   mut myStr1 = "Hello"
   mut myStr2 = Str('Hi')
   mut str = AStr("This is an ascii string") # ASCII string
   mut myStr3 = 'Halo'
   mut str2 = Str


STRING INTERPOLATION
   mut name = 'Pluto'
   mut time = 2015
   mut msg = '[name] is a language started in [time]'
   mut hello = 'Hello #= Beautiful =# World'
   print("This is a number: ", 4)


STRING OPERATIONS
   'ab' + 'c' # = 'abc'
   'abc' * 2 # = 'abcabc'
   'abcabc' + 'ca' # = 'abbc'
   'abcabc' / 'c' # = ['ab', 'ab']
   ['ab', 'ab'] * 'c' # = 'abcab'


NON-STANDARD STRING LITERAL
   let byteArr = ba"87004" # 8, 7, 0, 0, 4 repesent the actual byte to be placed in memory
   mut byteArr = bv"data\xff" # converts the values d, a, t, a, \xff into binary that fits in a byte
   mut myRegex = re"^(\w+)$"


ESCAPE SEQUENCE
- .[ .t .n ." .' .#
- \[ \t \n \" \' \# \. \\


MULTILINE STRINGS
   let cap =
   "Hello "
   "World"


VERBATIM STRING
   '''Use \t for tab and \n for newline'''
   """Use \t for tab and \n for newline"""


CONTINUATION ON NEXT LINE
    let men = length == 0 ? 25 $ 0
    let mune = length == 1 ? \
        25 $ 0
    let meter = \
        getMeter()


IF SATEMENT
    if myMoney == 1_000_000:
        print("Yay! I'm rich!")
    ..
    if x == 3 : print('Hello') ..
    if x == 1 :
        print(x)
    elsif x == 2 :
        print(x)
    else :
        print('invalid value')
    ..
    if x : # if x does not equal nil or false
        print('x has been assigned to')
    ..



FOR LOOP
   for i thru [1:10]: # a for variabe is always mutable
      if  i % 2 == 0 :
         print('[i] is an even number')
      else :
         next
   ..


LOOP
   loop :
      if x != 0 :
         print ('Hi')
      else :
         break
      ..
   ..


WHILE LOOP
   while myBool == true :
      print ('Hello ')
   ..


REPEAT WHILE LOOP
   repeat:
      print ("Hello ")
   while myBool == true


UNTIL LOOP # useful because you know the terminating condition but I might remove it tho (??)
   until myBool == true:
      print("Hello ")
   ..


REPEAT UNTIL LOOP
   repeat: print ("Hello ") $ until myBool


CONDITION LIST
   if myVar == a | == b & == c :
      print(myVar)
   ..
   if x == y == z :
      play()
   ..
   if "two-syllable word" == pit & == pot & == pet:
      print("That's wierd")
   ..
   # or better
   if pit and pot and pet == "two-syllable word":
      print("That's wierd")
   ..
   if "two-syllable word" == pit | == pot | == pet:
      print("That's wierd")
   # or better
   if pit or pot or pet == "two-syllable word":
      print("That's wierd")
   # 'and' and 'or' here are used in a different manner
   # than in Python
   if pit or (pot and pet) == "two-syllable word":
      print("That's wierd")
   ..


CONDITIONAL TERNARY OPERATOR
   mut myVar1 = myBool == true ? 5 $ 6
   def divide(num, denom): rt denom == 0 ? nan $ num / denom
   salary = (workYears > 5 ? 10_000 $ 1_000) * rank # when conditional ternary expression appears
   # within another expression, it must be bracketed


RANGE
   let x, y, z = [1:3]
   for x thru [1:(20 - 1)]: print(x)


THRU
   for x thru [1:20 - 1)]: print(x)
   mut y = for x thru [1:30]: x # a for comprehension that returns a list of 1 to 30 same as
   mut y = [1:30]


WHERE
   if p.age == 20 => p.name == "Allen": p # not really useful here
   # same as
   if p.age == 20 & p.name == "Allen": p

   for item thru library ==> item.title.startsWith("The"):
       mut hold x = 0 ; print(x++)


FOR COMPREHENSION
   list = for x thru [1:30] => x % 2 == 0: x * 3
   for b thru books, a thru btitle] => a.startsWith("The"): x


THRU/STEP
   for x thru [1:6] step 2:
      print(x)
   ..


IN
   mut x = 3
   if x in [1:10]:
      print(x)
   ..


NOT IN
   mut arr = for x thru [1:30] => x not in [2:5]: x * 3


NIL CONDITION AND OPERATOR
   if mySalary = getSalary(): buyNewHouse() $ else: borrow() # if variables are implicitly mutable
   if let mySalary = getSalary(), let myAllowance = getAllowance(): party()
   # if any of the if variables is nil, the if block will be skipped
   # unless there is an else block
   if let name = getChars() => name.characters.count in [4:15]:
      print('hello')
   if x = getStr(): print(x) $ else: print('x is nil')
   mut someone = person.getAge() ? _ $ printErr('someone is no one') # problematic if subject of op is a bool object
   # better
   mut someone = person.getAge() == nil ? _ $ printerr('someone is no one')
   # better still
   mut someone = person.getAge() ?? printerr('someone is no one')

   mut penny = purse.change() ?? 0 # expression returns 0 if purse.change() returns nil
   mut myName = me.name ?? "Unknown"
   mut pay = (jobHours ?? 0) * 50 # when nil operator appears within an expression it must be bracketed


ONE-LINE BLOCK
   def addTwo(a b = Int) Int:
      print (a + b)
      rt a + b
   ..
   def addThree(a b c =  Int) Int: print (a + b + c) ; rt a + b + c
   if x == y
   if x == y : print(x)
   if x == y : print(x) $ else : print(y)
   if state == "Play": play() $ if state == "Stop": stop()


NAMELESS BLOCK
   def doSth():
       mut x, y, z = 1, 2, 3
       use x, y: # can only access x znd y
           print("[x] : [y]")
   ..
   def doSth():
       mut x, y, z = 1, 2, 3
       use: # cannot access variabes from outer scope
           print("[x] : [y]") # error!
   ..
   def doSth():
       mut x, y, z = 1, 2, 3
       def(): # can only access any variable from outer scopes
           print("[x] : [y]") # error!
   ..


LABELS
   [label: outer]
   for i thru [1:10]:
      for j thru range(10) :
         print('i : [i] j : [j]')
         if j == 5:
            next outer
         ..
      ..
   ..


SKIPPING BLOCKS
   [skip : 3]
   if x == 5 : print('Hello') # block is skipped after the it has been executed 3 times.


FUNCTION DEFINITION
   def add(a = Int, b = Int) Int:
      rt a + b
   ..

RETURNING A VALUE
   def add(a = Int, b = Int) Int:
      rt a + b
   ..


EXPRESSION
    # Pluto is an epression-based language. If an exprssion evaluates to something, it is returned
    let myBool = myName == "Nypro"
    def add(a, b): rt a + b
    # or
    def add(a, b): a + b
    # sometimes rt is needed to return an evaluation immediately
    # to prevent execution spilling back into parent block when not needed
    def hypot(x, y):
        let x = abs(x)
        let y = abs(y)
        if x > y:
            let r = y/x
            rt x * sqrt(1 + r + r)
        ..
        if y == o:
            rt zero(x)
        let r = x/y
        y * sqrt(1 + r + r)
    ..


GLOBAL FUNCTIONS
   # Pluto comes with some helpful global methods
   mut str = "Hello"
   length(str)
   typeMin(25)
   typeOf(Int)


LIST DECLARATION IN METHOD PARAMETER
   def add(a, b): a + b # parameters a and b are dynamic, their types are known at run-time or inferred at compile-time.
   def add(a, b = Int): rt a + b # a is dynamic, b is Int
   def add(a b =  Int): rt a + b # both a and b are Int, = is left associative here
   def add4(a b, c d = Int) Int: # a and b are dynamic, c and d are Int
      rt a + b + c + d
   ..


CONSTANT PARAMETER
   # guarantees that the parameter won't be changed
   def add(let a, let b): c = a + b ; rt c
   # or
   def let add(mut a, mut b): c = a + b ; rt c
   # with this, not just the params, but the local vars are also constant by default


ARGUMENT NAMING
   def addPerson(name = 'Aditya', age = 28)
   def sum(a, b = 1, c = 0):
      rt a + b + c
   ..
   # arg naming can be used to skip optional args
   sum(3, c = 6) # b skipped


COMPOUND METHODS
   def getValue():
      mut sticky x = 1, y = Int(2)
      def ():
         rt x + y
      ..
      def (a = Int):
         rt x + y + a
      ..
          def (a b =  Int):
         rt x + y + a + b
      ..
   ..


VARIADIC PARAMETERS
   def sum(first = Int, others = Int []):
      mut tmp = first + arr
      for x thru arr:
         tmp += x
      ..
      rt tmp
   ..
   # or better
   def sum(first = Int, others = Int []): rt first + others
   mut lion = sum(1, 2, 3, 4, 5, 6)

   mut dean = [1, 2, 3, 4, 5]
   let jean = sum(0, dean)
   mut joan = sum(0, [1, 2, 3, 4, 5])
   mut jane = sum(0, 1, 2, 3, 4, 5)
   def add(a = 3 []): rt sum(a) # conflicts with the function below
   def add(a, b, c): rt a + b + c # conflicts with the function above



MUTATIVE FUNCTIONS
   def add(x, y): a + b
   <T> def swap!(x y = ref  T): x, y = y, x # use exclamtion mark for functions
   # that can mutate objects passed to them
   mut tip = add(2, 3)
   mut top = add(4, 5)
   swap!(tip, top)


UNOVERLOADABLE FUNCTIONS
   def add(args = [])
   def add<T>(args = [] T) T


RETURNING AN ARRAY
   def addThree (a b c =  Int) 3 Int []:
      mut arr = [a + b, a + c, b + c]
      arr
   ..
   p, q, r= 1, 2, 3
   x, y, z= addThree(p, q, r)
   w= addThree(p, q, r)[1] + z

   def addSubTwo(a b =  Int) Int []:
      let arr = [a + b, a - b]
      arr
   ..


RETURNING A TABLE
   def getDetails(u = User):
      rt name, age [.name, .age ]
   ..
   mut x = getUser()


RETURNING VARIABLES
   # check for pass table in notes
   def getReadOnly() []:
      rt read myList # unmodifiable after it has been returned
   ..
   def getVal():
      rt val myList
   ..
   def getRef():
      rt ref myList
   ..
   def getOwnership() [,]:
      rt array._move
   ..
   mut pat = val getVal() # redundant
   mut put = ref getRef() # redundant
   mut pit = read getReadOnly() # redundant
   let cup = ref getVal() # returned value is moved
   let cap = val getRef() # returned reference is copied
   mut cep = own getRef() # error, already has reference
   mut cip = iso getRef() # error, already has reference
   mut hola = read getVal() # returned value is moved, but cannot write


FUNCTION OBJECTS
   mut add2 = add
   mut add3 = Func{Int Int Int : Int}
   def solve(a, b, c = Func{Int Int : Int}): c(a, b)


CLOSURES
   def outer():
      mut a = 6
      rt def (b = Int) : a + b # a closure can access variables in outer scope
   ..
   mut add = outer
   # nameless closures (except those returned by a function or another closure) are executed at the
   # point they are declared
   # named closures on the other hand are not executed until they are called
   def add (x y =  Int):
      def (): rt x + y
   ..
   mut sum = Func
   mut sum = add
   mut tip = Func{Int Int > Bool}


FUNCTION ARGUMENTS
   def addThree(a, b, c, myFunc = Func{Int Int}):
      rt myFunc(a, b) + c
   ..
   addThree(1, 2, 3, def (a, b): a * b)
   # or
   addThree(1, 2, 3) do a, b: a * b

   def add(a, b): a + b
   addThree(1, 2, 3, add) # passing and already-declared function


ANONYMOUS TYPES
   def keyListener(e = Event): e.printText()
   keyListener(
      Event:
         def printText():
            print ('Hello, World')
         ..
      ..)


LAMBDAS
   def keyListener(e = Event): e.printText()
   keyListener(
      Event:
         def printText():
            print ('Hello, ')
         ..
      ..)
   keyListener(def (): print("World")) # lambda
   keyListener(rt print("World")) # shortened lambda using 'rt'
   arr.filter(def (a): pivot > a) # anonymous functions
   arr.filter() do a: pivot > a # function argument
   arr.filter(rt pivot > _) # lambda


MATCH FUNCTION
    match check30DayMonth(month = Month):
       case _.value == 4 : print("This is April, a 30-day Month!")
       case _.value == 6 : print("This is June, a 30-day Month!")
       case _.value == 9 : print("This is September, a 30-day Month!")
       case _.value == 11 : print("This is November, a 30-day Month!")
       print("Not a 30-day Month!")
    ..


COROUTINES
   # New Proposed Coroutine with Concurrency. Thanks to Go 03/08/16

   # Concurrent Coroutine
   def pinger(pipe p = String):
      loop:
         p <- "ping"

   def printer(n = Int):
      loop:
         mut msg = <- p
      print(msg)
      time.sleep(time.second * 1)
   ..
   def main():
      pipe p = String # pipe creation
      run pinger(p) # run pinger concurrently
      run printer(p) # run printer concurrently
      mut input = String
      scanln(input)
   ..
   doSth(from p = String) # can only send thru the channel
   doSth(to p = String) # can only recieve thru the channel

   # Sequential coroutine
    def coroutine():
        for x thru 1..10:
            yield x
    ..
    print(coroutine()) # 1
    print(coroutine()) # 2
    print(coroutine()) # 3
    coroutine.reset() # resets the coroutine
    list(coroutine()) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # Simulated sequential co-routine using sticky variables
    def addUp(a, b):
        mut sticky x
        if x == _init:
            rt x += b
        else:
            rt x = a + b
    ..
    print(addUp(3, 4))
    print(addUp(0, 5)) # gotcha! only the second argument is summed up.
    print(addUp(0, 6)) # gotcha! only the second argument is summed up.


EVENTS
   mut mathOps = Event{Float Float : Float}
   mut mathOps += add, subtract, divide
   mut mathOps -= divide
   mut buttonPressed = Event(createProject)
   mut buttonPressed += addNewEvent


TYPE DEFINITION
   type Car:
      mut name, model = Str
      def (name = Str):  # Constructor implicitly contains a first parameter of type Car
         self.name = name
      ..
      def (name, model = Str):
         self.name = name
         self.model = model
      ..
   ..


CONSTRUCTOR
    type Person:
        mut name = Str
        mut age = Int
        def (name = Str, age = Int):
            .name = name
            .age = age
        ..
    ..
    # A constructor without body initialises the fields with the corresponding parameter
    type Person:
        mut name = Str
        mut age = Int
        def (name, age) # which means there is no such thing as virtual constructors
    ..


CONSTRUCTOR CLASSES
    # Constructor classes have only one constructor and an optional set of parameters that are also the only fields of the class
    # These fields are mutable by default and are always public.
    type Person (name, age)
    mut dave = Person("Dave", 45)
    dave.age = "David"


SELF REFERENCE
   type Car:
      mut name, model = Str
      def (name = Str):
         .name = name # the self can be ommitted leaving the dot and the field
      ..
      def (name, model)
   ..
   # this is also applicable to methods where its is the type of the first parameter
   def getDetails(car = Car): rt [.name, .model]
   def hasModel(car = Car, model = Str): .model == model


USING A FUNCTION AS METHOD
   def show(p = Person): print("name: [.name], age: [.age]")
   mut nigel = Person("Nigel Nicargua")
   show(nigel)
   mut nigel.show() # using show funtion like a method since Person is the first argument
   # you can also use it on objects directly
   mut a = Person("Nigel Nicargua").getDetail()
   mut b = "hello".upper()
   mut c = 25_000.divideBy(x) # Don't do this though. :)
   mut d = (2f/4f).floor()
   # if a method directly follows its type, then its first parameter can be skipped with a comma
   type Person (name, age)
   def getName(,): .name
   def setName(, name = Str): .name = name


DESTRUCTORS
    type Car:
        mut name, model = Str
        def (name)
        def (name, model)
        def (!) : # Destructor implicitly contains a first parameter of type Car
            print('Object Deleted!')
    ..


MODIFIERS IN CLASS
    # No public modifer, members are all public by default
    mut priv a = 10
    let pack b = 'HELLO'
    mut pass a = true # synon with protected
    let prod let x = 5f # synon with internal
    # proj(ect), prod(uction), prog(ram) clashes with prot(ected)


MODIFIERS CAN BE ON CLASSES AND METHODS Took
   def priv addPerson() # is accessible only within the module
   def pass getNumber() # is accessible within the module and to associated types
   type priv Company # is accessible only within the module
   def prod createSession() # is accessible only to production unit


PACKAGE ACCESS LEVEL # Might remove this, it looks dangerous!!!
   mut pack< date = Date
   mut pack>> isbn = Long


READ-ONLY WRITE-ONLY ACCESS
   rpriv, rpack, rprod, rpub
   wpriv, wpack, wprod, wpub


MODIFIER BLOCK
   # modifier block is the only block in Pluto that may not be indented and it doesn't create a scope
   mod priv let :
   mut x = 4.5f
   mut y = 2.5f
   mut z = 0.0f
   ..
   # you can also chain modifier blocks together
   mod priv let:
   mut x = 4.5f
   mut y = 2.5f
   mut z = 0.0f
   mod pass:
   mut name = getName()
   mut age = getAge()
   ..


MODIFIERS IN LIST DECLARATION
    mut priv let i, j = Int


PROPERTIES / GETTERS SETTERS
    mut myVar1 = def set(a b c =  Int): _ = a * b * c $ def get(): rt _
    myVar1 = (1, 2, 3)
    mut myVar2 =
        def set(a b =  Int): _ = a * b * c
        def get(): rt _
    myVar2 = (1, 2)
    mut myVar3 = def set(a = Int): _ = a $ def get(): rt _
    myVar3 = 1
    mut myVar4 = def set(a = Int) $ get()
    myVar3 = 2
    mut tip = def get(): rt myVar3


TYPE CHECKING
    # Is
    if myCar === Car:
        print('myCar is a Car or its subtype')
    ..
    if myCar ==: Car:
      print('myCar is a Car ')
    ..
    if myCar =<: Car:
      print('myCar is a subtype of Car')
    ..
    if myCar =>: Car:
      print('myCar is a supertype of Car')
    ..
    # Is Not
    if phone !== Phone:
        print("phone is not a Phone or its subtype")
    if phone !=: Phone:
        print("phone is not a Phone")
    if phone !<: Phone:
        print("phone is not a subtype of Phone")
    if phone !>: Phone:
        print("phone is not a supertype of Phone")


IMPORT / USING STATEMENT
Now module-based
   import pluto.io # imports all types and funtions in a module
   import pluto.io: Console # imports a type and its associated methods (where its the type of the first parameter) from a module
   import pluto.io: add(), subtract() # imports only add and subtract function from the module


TYPE ALIAS
   Int as Meter
   import marko.io: SimplifiedRegex as Regex


METHOD CHAINING
- Method chaining is automatic, no need to return self
   type Math:
      mut value = Float
   ..
   def add(a = Math, b c =  Float) Float:
      a.value = b + c
   ..
   def subtract(a = Math, b c =  Float) Float:
      a.value = b - c
   ..
   mut m = Math
   m.add(1, 2).subtract(3, 4)
   mut n = "This is the first string".&"This is another string".reverse().toUpper()


STICKY TYPES
   type sticky TempConv
   def convToFahr(a = TempConv, celsius = Float) Float
   def convToCelsius(a = TempConv, fahr = Float) Float


STICKY TYPES MEMBER
   type Person:
      mut name = Str
      mut age = Int
      sticky let race = 'Mongoloid'
      def (name, age)
   ..
   def sticky getRace(a = Person): .race


STICKY CONSTRUCTOR
   type sticky MyClass:
      mut x, y = Int
      def (): # they can't have parameters. They only initialise class fields at first use
         .x = 2
         .y = 3
      ..
   ..


STICKY LOCAL VARIABLES
  # sticky local variables are promoted to fields implicitly but can only be accessed in their
  # parent method.
  # I like sticky local variables because it brings variables closer to where they are needed
   def add(a = Int) Int:
      sticky sum = a # this variable will maintain its state whenever the function is called
      rt sum += a
   ..


HOLD VARIABLES IN LOOPS
   for x thru [1:50]:
      mut hold x = 1
      print(x * y)
      x++
   ..


INHERITANCE # Not Finalized!
   type Animal
   def move(a = Animal)

   type Bird [Animal]
   def move(a = Bird): print("Soar!") # overides move method for Animal, a super method
   def fly()

   type Horse [Animal]
   def move(a = Horse): print("Gallop!") # overides move method for Animal, a super method
   def gallop()

   type Pegasus [Bird, Horse] # inherits Bird and Horse classes
   def move(a = Pegasus): print("Soar and Gallop!") # overides move method because of CONFLICT in  Bird and Horse

   mut eagle = Bird()
   mut horse = Horse()
   mut pegasus = Pegasus()
   def move(eagle) # "Soar!"
   def move(horse) # "Gallop!"
   def move(pegasus) # "Soar and Gallop!"
   mut animals = Animal[Bird(), Horse(), Pegasus()]
   animals[1].move() # "Soar!"
   animals[2].move() # "Gallop!"
   animals[3].move() # "Soar and Gallop!"


COVARIANCE
    # Pluto supports covariance by default
    type Person (name = Str, age = Int)
    def showDetails(,): print("name: [.name], .age: [.age]")
    type Engineer (type = Str) [Person]
    type Artist (type = Str) [Person]

    mut person = Person("Peter", 16)
    mut engineer = Engineer("Civil Engineer")
    mut artist = Artist("Painting Artist")
    # covariance in assignment
    mut person = Person("Matthew", 25) # home type
    mut person = engineer # guest type
    mut person = artist # guest type
    # covariance in argument passing
    showDetails(person)
    showDetails(engineer)
    showDetails(artist)
    # covariance in container types
    mut arr = Person[]
    mut arr[1:] = [person, artist, engineer]

    mut library = MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
    for x thru library:
        print(x.title)


SUPER METHODS AND SUB METHODS
   type Listener
   type ButtonListener [Listener]
   def respond(a = Listener) # this is a super method to the more specific method below
   def respond(a = ButtonListener): rt # this is a sub method to the method above


CALLING SUPER
    type Person:
        mut name = Str
        mut age = Int
        def (name, age)
    ..
    type Artist [Person]:
        mut kind = Str
        def priv (job)
        def (name, age, kind):
            super(name, age) # calls the parent constructor to initilize parameters
            self(kind)
        ..
    ..
    # or
    type Artist [Person]:
        mut kind = Str
        def ((name, age) , kind)
    ..
    # or better
    type Artist ((name, age) , kind) [Person]


VIRTUAL METHODS
   def respond(a = Listener) # a method without a body is implicitly virtual and cannot be called however.
   # constructors cannot be virtual and therefore use the same syntax for shortening initialisation
   def respond(a = ButtonListener) # error, a virtual super method can't be overriden by a virtual sub method


OVERRIDING METHODS
    # Pluto does not, currently, have an override keyword. Methods are overriden implicitly
    # This might cause some unexpected problems. Important super methods could be overiden without knowing
    # I'm going to look into the problem later
    def play(a = Player): .start()
    def play(a = DigitalPlayer): .startAt(0) # this play overrides its super method implicitly


COVARIANT OVERRIDE
    # You can override an inherited method using by replacing the original agruments with their subtypes
    eat(a = Herbivore, b = Plant)
    eat(a = Cow, b = Grass) # valid override


ABSTRACT TYPES
   type abs Player # cannot be instantiated
   def play(a = Player)
   def rewind(a = Player)
   def fastForward(a = Player)

   type DigitalPlayer [Player]


DOWNCASTING
  # assuming Movie and Song extends MediaItem
   library = MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   for item thru library:
      if item === Song:
         print('Song: [song.name]')
      elsif item === Movie:
         print ('Movie: [movie.name]')
      ..
   ..


CONSTANT CLASS
   type let MyType:
      x = 'is immutable'
      mut y = 'is mutable'
   ..


UNINHERITABLE CLASS
   type solo MyType:
      x = 'Type Cannot Be Inherited'
   ..


GENERICS
    <T[Integer]> # Integer and subtypes
    <T[::Integer]> # Integer exactly
    <T[<:Integer]> # Integer subtypes
    <T[>:Integer]> # Integer supertypes
    <T[Str|Int]> # Str and subtypes or Int and subtypes

    type DataManager<T[Str|Int], U>:
        T dataID
        U dataX
        U dataY
    ..
    mut object DataManager<Str, Car>

    type Ratio <T[<:Integer]>
    mut chan = Ratio(3//2) # uses Integer
    mut chen = Ratio<UInt>(6//4)  # uses subtype UInt

    let myMovies = List<own Movie>
    let favoriteMovie = ref Movie

    def add<T>(a b c = T): a + b + c
    add<Int>(1, 2, 3)
    add(1f, 2f, 3f)
    add(2, 3, 4f) # error, mismatched types


ENUMS
    # enum is an abstract type that contains ONLY its subtypes.
    # its subtypes are all constructor types and only extend the enum
    # also an enum object expects a subtype as value
    enum Friends: Deji, Tosin, Tola # Deji, Tosin and Tola are parameterless conctructor types
    match whichFriend(f = Friend):
        case Deji : print("This is Deji")
        case Tosin : print("This is Tosin")
        case Tola : print("This is Tola")
    ..

    enum Number: IntegerNumber(i <: Integer), RealNumber(r <: Real) # IntegerNumber and RealNumber are constructor types

    # You can access an enum subtype using the access operator
    mut sym = Friends[1] # I can't conclude whether this returns a Symbol object or a DataType object yet.
    # Iterating thru enum
    for x thru Friends:
        print(x)
    ..


PATTERN MATCHING
    # EXAMPLE: How to compute a tree-like expression
    type abs Tree
    type Leaf<T>(val = T) [Tree]
    type Node (l = Leaf, r = Tree) [Tree]
    match sum(t = Tree):
        case a == Leaf: a.val
        case a == Node: sum(a.l) + sum(a.r)
    ..
    mut x = Node(Leaf<Int>(1), Node(Leaf<Int>(2), Leaf<Int>(3)))
    mut y = sum(x)
    # or better
    enum Tree<T>: Leaf(val = T), Node(l = Leaf, r = Tree)
    match sum(t = Tree):
        case Leaf: a.val
        case Node: sum(a.l) + sum(a.r)
    ..
    # you can use this verbose version
    mut x = Tree<Int>.Node(Tree<Int>.Leaf(1), Tree<Int>.Node(Tree<Int>.Leaf(2), Tree<Int>.Leaf(3)))
    # or better
    mut x = Tree<Int>(_.Node(_.Leaf(1), _.Node(_.Leaf(2), _.Leaf(3))))
    mut y = sum(x)


REGEX
    mut x = Regex("\d+")
    mut x = re"\d+"


EXPLICIT TYPE CASTING
   mut x = Int(5)
   mut y = Byte(6)
   let z = y + Int(y)


STACK EXPRESSION
   let a = add (x, y) >>> subtract(_, z) # '_' represent the value passed from preceding method
   let a = subtract(_, z) <<< add (x, y) # same as above


MOVE SEMANTICS
    # Move feature is automatic in areas where it makes sense to do so.
    # for example, returning a value (not reference) to a variable
    # But you can still explicitly specify it.
    let y = move getPerson('Californio')


ATOMIC EXPRESSION
   lock: x = 5; y = x
   lock: if y == 5: print('y is 5')


ATOMIC BLOCKS
   lock block:
      x = 5
      y = x
   ..
   # or better
   lock:
      x = 5
      y = x
   ..
   lock if tip == top:
   print("Hello")
   print(" World!")
   ..


OPERATOR OVERLOADING
   # Old
   _var++ ():
      value++
   ..
   _-var ():
      0 - value
   ..
   _var* (other = MyObj) MyObj:
      rt MyObj(.value * other.value)
   ..
   _var() (other = Int):
      value = other
   ..
   _type() (other = Int) MyObj:
      rt MyObj(other)
   ..
   _var[] (row = Int, col = Int) MyObj:
      rt my2DArr[row, col]
   ..
   _var=[] (args = Int []) MyObj:
      for x thru args:
         hold i = 1
         my1DArr[i] = x
      ..
   ..
   # Proposed
   def +(x, y): tmp;  tmp.value = x.value + y.value
   def ++!(): self.value++
   # others
   [A B C] # hcat()
   [A, B, C] # vcat()
   [A B; C D] # hvcat()
   Aâ€™ # ctranspose()
   [1:n] # thru()
   A[i] # getindex()
   A[i]=x # setindex!()
   A(x) # call()


TRY & ASSOCIATES
   def main():
      ensure:
         file.close()
      ..
      print("I'm about to open a text file and print its first 500 characters")
      mut file = File("C:/Users/Hello/hello.txt")
      try file.open().print([1:500])
      except(fnfe = FileNotFoundErr, ioobe = IndexOutOfBoundErr):
         if fnfe: printErr('Can\'t find file!')
         if ioobe: printErr('Out of index error!')
      ..
   ..

   try:
      file.open()
      file.write('Hello')
   except(fnfe = FileNotFoundErr):
      printErr('Can\'t find file!')
   ..

   try:
      raise Err()
   except(e = Err):
      printErr('Error!')
   ensure:
      file.close()
   ..

   try let x = getObject()
      print('x is nil')
   ..

   try:
      let x = getObject()
      raise NilErr()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   ..

   try:
      let x = getObject()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   ..

   try:
      file.open()
      let x = file.readLine()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   except(fnfe = FileNotFoundErr):
      printErr('Can\'t find file!')
   ensure:
      file.close()
   ..


ERR
    # Err stops application whenever it is evoked
    if num and den == 0:
        err DivideByZeroErr()
    ..


ASSERTION
    @assert(x == nil, "Hello")
    @assert(x == nil)


ITERATORS (?)


FLOATING POINT BITWISE OPERATORS (?)


HINTS
    @deprecated:
        msg: "MediaPlayer class should be used instead"
    @stub
    @if (platform: "Mac"): print("This is a Machintosh Computer") $ @endif
    #------------------------------------
    @compiler # evaluated at compile-time
    @linker # evaluated at link-time
    @runtime # evaluated at runtime
    @if: [] # evaluated at compile, link and run time


COMPILER HINT
    @compiler:
        typing = "static"
        variable = "immutable"
        warn_me = {
            unimplemented_inherited_functions
            unimplemented_inherited_fields
        }
    ..


NON-STANDARD STRING LITERAL HINT
    myRegex = re"^(\w+)$"
    @strLiteral:
        re: {Regex(_str)}


METAVARS CONTEXT SPECIFIC ENVIRONMENT
    arr[_last] = 20
    if(x == _even)
    match check30DayMonth(month = Month):
        case _.value == 4 : print("This is April, a 30-day Month!")
        case _.value == 6 : print("This is June, a 30-day Month!")
        case _.value == 9 : print("This is September, a 30-day Month!")
        case _.value == 11 : print("This is November, a 30-day Month!")
    print("Not a 30-day Month!")
    ..
    mut sum = add(a, b) >>> add(_, x)
    mut tip = def set(a = Int): _ = 25 $ def get(): rt _


LIST OF METAVARS
   _init # to check if sth is initialised
   _
   _last
   _even
   _odd
   _min
   _max


REFLECTION
   # dynmically determining which class to use
   @if (stage = "runtime", condition = "Main.useOldClass == true"): # ????
    type Class:
      mut value = def set(x Str): _ = x $ def get(): rt _
      def (value)
    ..
   @else
    type Class:
      mut str = def set(x Str): _ = x $ def get(): _
      mut num = def set(x Float64): _ = x $ def get(): _
      def (str)
      def (num)
    ..
   @endif


MACROS
    @macro subtract(a, b):
        a - b
    ..
    mut dune = @subtract(50, rune)


COMPLEX, QUATERNION DECLARATION
    mut x = 5 + 2i # complex
    mut y = 5 + 2i + 3j + 4k # quaternion


MATHEMATICAL EXPRESSION
    let top = m{3x - 2y/5 + r(d^5)} # operator precedence still applies
    let tip = m{3x y z^2} # when there is no operator between 2 operands, multiplication is assumed
    mut pat = m{4y - 2x(z^2) getSalary()} # you can use functions and variables directly
    mut pet = m{4d 5f} # MathExpr doesn't support numeric literals with type prefix. 4d and 5f here means 4 * d * 5 * f
    mut pot = m{5y [getSalary().round()] 3e-1 + [4d]} # for complex lang expressions you need to use []. 4d here means a Double literal


SYMBOL, EXPR, HOMOICONICITY & OTHER SYMBOLIC CLASSES
    # Symbol
    # delimited by spaces and commas
    # interpolated using "[]"
    # can also be nested {x, {y, b}}
    mut buck = {1}
    mut back = {1 2 3}
    let beak = {"hello ", [name]}
    let bean = {hello {hi {halo}}}
    # Functions
    let foo = Func{Int Int : Bool}
    # Expressions
    mut pet = Expr({call}, {+}, 1, ({call}, {*}, 2, 3))
    # or better
    mut pat = Expr{call, +, 1, {call, *, 2, 3}}
    mut exp = parse("1 + 2 + 3")
    mut ingrid = eval(exp)
    parse(pat)
    mut ma = m{3x - 2y/5 + r(d^5)}


CPLUSPLUS SYMBOL
    mut str = cpp{ void add(int a, int b) {return a + b;}}
    parse(str)
    let sum = str.add
    mut brim = sum(1, 3)


NON-STANDARD SYMBOL LITERAL HINT
    mut str = cpp{ void main() {printf("Hello")}}
    @symLiteral:
        cpp= {Cpp(_str.toStr())}


NUMERIC CLASS
    let x = UInt.max()
    let y = Int32.min()
    mut z = m{2x + 4y/3}.round() + (24.25/4).floor()


RATIONAL CLASS
    mut xianghou = 2//3
    mut dean = x.toFloat() # rational format can be changed to fp
    mut bean = 4//6 ; print(y) # 2//3
    4//2 == 1//2 # true
    4//2 == 0.5 # true


RAW CLASS
    # bits stored in multiples of 8
    let bits8 = Raw<8>
    let bits16 = Raw<16>


INTEGER BITWISE OPERATORS
    mut myVar = 2.&2 # and
    mut myVar1 = 2.|2 # or
    mut myVar3 = ~2 # exclusive or


SHIFT OPERATORS
    mut myVar = 4<<1
    mut myVar = 2>>2


BINARY LITERALS
    mut myVar = 0b11001001


HEXADECIMAL LITERALS
    let myVar = 0x5eff77


OCTAL LITERALS
    mut myVar = 0o56773


UTF-8 CHARACTERS
    let char = '\u6E'


CLASSES OF OBJECTS
    Obj (0.7), Any (0.8)
    Func (0.7)
    Var (0.7)
    Array (0.7)
    Dict (0.7)
    Exp (0.7), Expr(0.8.2)
    Nil (0.4), None (0.8.1)
    Symbol(0.7)


PREDEFINED TYPES # These types are optimized as part of the lang
    Int, Int16, Int32, Int64
    UInt, UInt16, UInt32, UInt64
    Float16(0.8.2), Float/Float32 (0.4), Float64/Double (0.6.1)
    Bool (0.4)
    Str (0.4), String (0.6.1), Str (0.8.1)
    Char
    Byte
    SByte
    Comp, Comp128
    Quat, Quat256
    Num (0.4) # redefined in 0.8.1 # (combines the features of BigInt, BigFloat)
    Ratio


LOGICAL vs BITWISE OPERATORS
    ! & |
    ~ .& .|


KEYWORDS
    stick (0.4) sticky  (0.6.1)
    # pub (0.4) public (0.6.1) pub
    priv (0.4) private (0.6.1) priv
    pro (0.4) protected (0.6.1) prot
    pack (0.4) package (0.6.1) pack
    pass (0.7.5)
    class (0.4)
    rt (0.7.2)
    def (Rev 0.5.2), def (0.8.2) # reintroduced
    let (Rev 0.5.2)
    get (Rev 0.5.2)
    set (Rev 0.5.2)
    as (0.8)
    if
    else
    elsif
    while  (0.6.1)
    eval (Rev 0.5.2) match (0.8.1)
    for
    do
    until (0.6.1)
    next (0.6.1)
    break
    label (0.7.0)
    use (0.5.2), use (0.8.2) # reintroduced
    # fixed
    thru (0.8)
    in(0.7.2)
    skip(0.8)
    ensure (0.8)
    try
    except
    self
    mut (0.8)
    nan (0.8)
    nil



OPERATORS
    +
    -
    *
    /
    // # for ratios
    ^
    %
    --
    ++
    =
    =:
    <:
    >:
    +=
    -=
    *=
    /=
    //=
    ^=
    %=
    ==
    !=
    ===
    !==
    ==:
    !=:
    =<:
    !<:
    =>:
    !>:
    !
    >
    <
    >=
    <=
    &
    |
    ~
    .|
    .&
    >>
    <<
-   '
    .=


SYNTACTIC SYMBOLS
    |, $ (0.8.2)
    ;
    @
    :
    ..

---------------! NOTES !------------------------
VARIABLE BINDING
- The default assignment binds a variable to None and one more type, however due to
- covariance, a variable can also be bound to the types subtypes
- This behavior can be changed using other assignment operators
    mut pat = Integer
    pat = 25i16
    pat = 750i32 # ok
    pat = "Hello" # error! dat can only be bound to Integer and its subtypes
    mut dat =: Integer
    dat = Int16(25) # error! dat can only be bound to Integer


CONCURRENCY (Still Needs Proper Review)
- All singular +() and associative +=!() operations on variables are atomic by default.
- In an assignment or initialisation operation. The whole expression is singularly atomic
- Variables are volatile by default
- And methods are sychronised by default


CONDITIONALS
- Value
- nil or not
- True or false
- Type (===)


ITERABLES
- Coroutines
- Functions
- Range
- Array objects
- Table objects
- Iterable SubClasses
- String
- Enums


SUBJECT OF OPERATIONS
# is signified by '_'
- Stack
- Match
- Properties


AUTOMATIC REFERENCE COUNTING
- There can only be one strong ref to an object
    type Skeleton:
        bones List<own Bone> # bones contain a list of strong Refs to Bone objects
    ..
    type Bone:
        skel Skeleton
    ..


DECLARATIVE PLUTO ".deplu" #27/06/16
   person:[
      name : "Nypro"
      fat : false
      tall : true
      hobby : 'programming'
      single : _ # underscore as a value signifies empty
      children : [2, 3, 4, 6]
      coord : [x : 5]
      coords : [x : 1, y : 2, z : 3]
      gamesLiked : name, releaseDate, hard [
         ["Crysis", 2007, _],
         ["Unreal Tournament", 1999, true],
         ["Portal 2", 2011, true],
      ]
   ]


DUCK TYPING EXAMPLES
   mut c
   mut a = 25
   mut b = [1, 2, 3, 4, 5] # array
   mut c = [1, 2, 3 | 4, 5, 6] # multi dimen array
   mut d = ['Hello', 25, 1.3f, 'Hi'] # table
   def getArea(length, breadth):
      length * breadth
   ..
   mut length = 10
   mut breadth = 25
   mut rectangleArea = getArea(length, breadth)


NESTED ASSIGNMENT
- Pluto does not support nested assignments.
   mut tip = 5
   mut tap = (tip *= 5)


NIL VARIABLES
- Access to nil variables should be caught at compile time.
- Run-time ones are also caught, NilErr
   mut x
   print(x) # raises NilErr
   print(x ?? "Error! x is nil")


PASS TABLE
#=
   Types                              |   Passed Around By
   ----------------------------------------------------------
   Built-in Ind Types /  Value Types  |   val
   Array Types                          |   ref
   Func Types                         |   ref
   Custom Types                       |   ref
=#


VARIABLE VS PARAMETER
- Variable declaration is nothing like parameter declaration


COMPILER WARNINGS
- When assigning to variables in other modules
- Pluto only warns when about imported naming ambiguities when the names are accessed


RUNTIME WARNINGS


COMPILATION
- '_' is compiled as a placeholder. This will be replaced at run time by a subject of operation
- some symbolic classes are evaluated at compile-time, e.g Func, MathExpr


PUNCTUATION
- Pluto needs proper use of indentations and newline to compile successfully
- This makes code reformatable to original when copied with newlines stripped.
- Pluto only supports 4-space identation


UTILITIES
IDE
- The REPL
- Advanced Refactoring
- Code Completion
- Render/Plot View
-------------------
Network and Streams
- terminals
- files
- TCP sockets
- pipes
-------------------
Virtual Machine
- PlutoMine
-------------------
Compilers
- AOT and JIT Compilers.
- Static and Dynamic Analysis.
