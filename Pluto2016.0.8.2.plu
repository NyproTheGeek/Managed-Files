Revised 11/08/16
# 2016.0.8.2
#=
Major Change:
    Restructuring for Multiple Dispatch
    Import is now module-based, rather than being type-based, due to the introduction of multiple dispatch
    A type's method may be defined outside the type's file
    Added def to function declaration #18/08/16 Changed to func, which was I started with initially #29/06/16
    Changing assignment operator back to good ol' way, binding to nil-and-one-other-type is still enforced 19/08/16 Nl is now a state #30/08/16
    The block punstuation is now $, it helps resolve some ambiguity in statements like repeat play() | while state == "Play" | x == y ? y | z
        repeat: play() $ while state == "Play" | x == y ? y $ z
    Added mut for mutable variable declaration; solves some scoping issues.
    Pluto is an interpreted statically-typed language that requires no type annotation. #31/08/16
    ^^^Scratch that. Pluto is an interpreted hybrid language with a static and dynamic type system. #31/08/16
=#

PLUTO's DESIGN PHILOSOPHY
- let it do more with less
- make it fast
- make it legible
- make it consistent
- make it flexible (dynamic and static)
- make it lightweight

DESCRIPTION
Pluto is an interpreted language that supports optional typing without sacrificing performance as a result.
Pluto is completely object-oriented and procedural at the same time. This is in part achieved by closely associating types with multiple dispatch in functions.
Some of Pluto's features include list comprehenshion, generics, closure, lambdas, mutiple dispatch


--! THE EXAMPLES BELOW ARE MOSTLY STATICALLY TYPED !--
SINGLE-LINE COMMENTS
   # Hello


MULTILINE COMMENTS
    #=
    I'm Pluto
    I'm cool
    =#
    # Pluto's will support nested multiline comments :)


DOCUMENTATION
   # <code> Car </code>  class is deprecated # xml
   # [ code: 'Car' ] class is deprecated # deplu


VARIABLE DECLARATION & INITIALIZATION
    # Unlike Python, Pluto requires explicit variable declaration before usage
    mut x # is a mutable
    let y # is a constant
    func add(a, b): rt a + b # function parameters are implicitly mutable
    func swap!(mut a, mut b): a, b = b, a # error! mut should not be specified in their declaration
    mut e ; e = Car('Camaro') # semi-colon is used to separate two statements
    mut y = 12f
    mut z = 'Hello'
    mut a =: Car('Camaro')
    mut b = Car('Camaro').setDate(2014)
    mut n = getCar('Camaro')
    mut o = add(2, 4)
    mut p = List<Car>(3) # generics


SPECIFYING TYPES
    mut p = Person("Bradley") # Flexible assignment, variable can be assigned another type later.
    mut p = Person # error! You can't do strict binding with '=' operator
    mut p =: Person # Strictly bound to Person and Person's subtypes.
    mut a =: [] # when used with array or dict it means the container must be populated with a particular type only.
    let d = "Hello, world!" # Flexible variables can also be constant, even though they are promoted to Strictly
    mut r = 25, r =: 0.3 # error! flexible variables cannot be canged later to strict variables and vice-versa


VARIABLES AND REFERENCES
    # Value types such as Int, FLoat, et. are passed around by value, reference and container types are passed
    # aroud by reference
    # see pass table below
    mut pet = own getObject() # pet now holds a sole strong ref to the object returned
    mut pet = iso getObject() # pet exclusively exclusively refers to the object returned (if it is a value object)
    let put =: val pet # assigned by value
    mut pot =: read pat # read is a type of ref that allow reading only from referenced object
    # side effect of read:
    # if later in the future a variable is changed to read, it will lead to having to change code that have assigned to it, which can be a lot. :'(
    let pit = val put
    func subtract(let a let b let c =: ref):
        c = a - b
        rt ref c
    ..
    mut dean = val subtract(x, y) # gets a copy
    let cop = subtract(x, y) # gets a ref
    func add(a b = ref):
        rt val a + b
    let alm = ref add(val x, val y) # warning, return a val to a ref
    swap!(val a, val b)
    # there is nothing like ref iso or ref own, there is however val iso and val own.
    mut x = ref iso getName() # error!
    mut y = val own getName() # ok, y gets a copy of name and owns it.


OPTIONAL TYPE DECLARATION
   mut myNumber = Str|Int
   mut myNumber = '01000999'
   mut myNumber = 23


LIST DECLARATION
   mut a, b, c = arr[2:4]
   mut x, y = y, x
   let a, b, c, d = [1:4]
   mut loopTimes loopCount backTrack =: Int # you can omit the commas too


NUMERIC LITERALS
    mut d = 2 # Int
    let r = 2.5 # Double
    let e = 2f # Float
    let m = 3d # DoubleS
    let y = 4_567.32f # Float
    mut x = 1_000_000 # Int
    let y = 1_999.99 # Double
    mut v = 12_000_i32 # Int32
    mut w = 145_ui18 # UInt16
    mut z = .1 # Double
    mut p = .2e-2f # Float
    mut d = 1.56_f32 # Float


ACCESS MODIFIERS
    # No public modifer, members are all public by default
    mut priv a = 10 # accessible only within the module
    mut pack b = 'HELLO' # accessible within the file level
    mut pass c = true # synon with Java's protected
    mut prod d = 5f # synon with C#'s internal # I'm contemplating on its removal
    # access modifiers can be used with types and functions too
    func pack addPerson()
    func pass getNumber()
    type priv Company
    type prod Artist [Person]


ACCESS PACKAGE ACCESS LEVEL # Might remove this, it looks dangerous!!!
    mut pack< date = Date
    mut pack>> isbn = Long


ACCESS READ-ONLY WRITE-ONLY ACCESS
    rpriv, rpass, rpack, rprod # rpub and wpub useless
    wpriv, wpass, wpack, wprod


ACCESS MODIFIER BLOCK
    # modifier block is the only block in Pluto that may not be indented and it doesn't create a scope
    mod let priv:
    mut x = 4.5f
    mut y = 2.5f
    mut z = 0.0f
    ..
    # you can also chain modifier blocks together
    mod let priv:
    mut x = 4.5f
    let y = 2.5f
    mut z = 0.0f
    mod pass:
    mut name = getName()
    let age = getAge()
    ..


ARRAYS / LISTS
   # major diff between lists and arrays is that, the type and size of an array are
   # inferrable at compile time, this allows for arrays to be stored like traditional array
   mut fin = Car[('Camaro'), ('Mustang')]
   mut gin = 3 Car[] ; mut gin = Car[('Camaro'), ('Mustang'), ('Maserrati')]
   mut tin = 3 [Car('Camaro'), Car('Mustang'), Car('Maserrati')]
   let ted = [1, 2, 3, 4, 5]
   mut top = ted
   mut go = 5 Vehicle[Car("Camaro"), SuperBike("Ducati Multistrada"), Plane("Boeing 747")] # covariance in container
   mut go[1] = Car("Camaro")
   mut go[2:] = Car[('Mustang'), ('Maserrati')] # starts filling from index 2

   mut pot = Array
   # or better
   mut pot = []

   mut pit = Array<Int, 3> # an Int array with the size of three
   # or better
   mut pit = 3 Int []

   mut pet = [5] # this is an array with one element, 5
   let put = 5 []
   let pat = 4 [1, 2, 3, 4]

   let pat.foldleft(0, func (a, b): rt a + b) # (((0 + 1) + 2) + 3) + 4 = 10
   mut mat = getArray()
   mut net = getArray() # error, array not exposed, so '[]' must be used
   list(go) # list elements row-wise
   list(go[_col]) # list elements col-wise
   mut dean = Array
   mut dean = [10, 8, 6 ,4, 2]


DICTIONARIES / TUPLES
    # I'm planning on changing this to CSON like representation
    # the major diff between dict and tuple is that
    # tuples are not key based and don't have colon after their "key" element
    mut tup = ['Tola', 1.2, 50, 'Tola']
    mut dict = [
        'Peter Parker'   : 'Spider-man'     , 20 |
        'Steve Rogers'   : 'Captain America', 32 |
        'Tchaka Tchalla' : 'Black Panther'  , 29
    ]
    let candidate = [ # specifying headers
        1 : 'Aditya' |
        2 : 'Nypro'
    ]
    list(candidate.key(1)) # Aditya
    list(candidate.index) # 1, 2
    list(candidate.name) # "Aditya", "Nypro"
    list(candidate[1]) # 1, "Aditya"
    let aditya = Str Int Int ["Aditya Singh": 19, 6.2]
    let aditya = Str Int Int ["Aditya Singh", 19, 6.2]
    for index, name thru candidate:
        print("[index] : [candidate]")


ARRAY SLICING
   arr = [1, 2, 3, 4, 5, 6]
   print(arr[1:3]) # first index to the third
   print(arr[:5]) # first index to the 5th index
   print(arr[3:_last]) # 3rd index to the last
   print(arr[-3:]) # from the 3rd index starting from the back
   newArr = arr[:] # all elements
   list(arr[_last:]) # list from behind


MULTIDIMENSIONAL ARRAY
    mut arr = [,]
    mut arr = 2x2 [1, 2 | 3, 4]
    let arr = 2x2x2 Int [1, 2 | 2, 3 || 4, 5 | 6, 7]
    mut arr = [1, 2 | 3, 4]
    list(arr [:])
    list(arr[2, ]) # list columns in row 2
    list(arr[, 2]) # list rows in col 2
    mut arr = [1, 2] # vcat
    # 1 2
    mut arr = [1, 2 | 3, 4] # vhcat
    # 1 2
    # 3 4
    mut arr = [1 2] # hcat
    # 1
    # 2
    mut arr = [1 2 | 3 4] # hvcat
    # 1 3
    # 2 4


ACCESSING ARRAYS
    list = Person[("Dave", 25), ("Tony", 45), ("Spencer", 18)]
    mut names =: list.[name] # returns a list of name fields in the list
    mut ages = list.[age] # returns a list of age fields in the list


ARRAY OBJECT ARITHMETIC AND COMPARISON OPERATIONS
    # Operations are element-wise
    if arr1 == arr2: list(arr1)
    let arr3 = arr1 / arr2


MATRIX-VECTOR OPERATIONS # column major order
    mut mP = 2x2 [2, 4, 3 | 3, 1, 5] * [3, 10 | 4, 2 | 1, 7]
    mut mX =: Mat.identity(2, 2)
    mut mY = 4x2 Int [
        1, 1, 1, 0 |
        0, 1, 1, 1 |
    ]

    let mZ = mX / mY
    mut mRows, mCols = m.size()
    let mQ = mXâ€™ # z is assigned transpose of matrix u


STRING TYPE
   mut myStr1 = "Hello"
   mut myStr2 = Str('Hi')
   mut str = AStr("This is an ascii string") # ASCII string
   mut myStr3 = 'Halo'
   mut str2 = Str


STRING INTERPOLATION
   mut name = 'Pluto'
   mut time =: 2015
   mut msg =: '[name] is a language started in [time]'
   mut hello = 'Hello #= Beautiful =# World'
   print("This is a number: ", 4)


STRING OPERATIONS
   'ab' + 'c' # = 'abc'
   'abc' * 2 # = 'abcabc'
   'abcabc' + 'ca' # = 'abbc'
   'abcabc' / 'c' # = ['ab', 'ab']
   ['ab', 'ab'] * 'c' # = 'abcab'


NON-STANDARD STRING LITERAL
   let byteArr = ba"87004" # 8, 7, 0, 0, 4 represent the actual byte to be placed in memory
   mut byteArr = bv"data\xff" # converts the values d, a, t, a, \xff into binary that fits in a byte


ESCAPE SEQUENCE
- \[ \t \n \" \' \# \. \\


MULTILINE STRINGS
   let cap =:
   "Hello "
   "World"


VERBATIM STRING
   '''Use \t for tab and \n for newline'''
   """Use \t for tab and \n for newline"""


EXPRESSION CONTINUATION ON NEXT LINE
    # expressions that are not naturally enclosed like arrays or function calls can be continued
    # on separate lines by enclosing the whole expression in a bracket
    # or by ending each line with a backslash before contnuing the expression on the next line.
    mut yay = (2 * (a / 2)
        + b)
    # or
    let mune = length == 1 ? 25 \
        || 0


IF SATEMENT
    if myMoney == 1_000_000:
        print("Yay! I'm rich!")
    ..
    if x == 3 : print('Hello') ..
    if x == 1 :
        print(x)
    elsif x == 2 :
        print(x)
    else :
        print('invalid value')
    ..
    # checking if an object is not nil, requires
    # the '??' operator. This is, in part, due to the ambiguity
    # with Bool objects. "if bool: print(bool)" would have been
    # ambigous otherwise. Not knowing whether it checks for not-nil
    # or it checks for true
    if x??: # if x is not nil
        print('x has a value')
    ..
    if x =: getX()??: print("x is not nil")  # if variables are implicitly mutable
    if !let x =: getX()??: print("x is nil")
    if let mySalary = getSalary()??, let myAllowance = getAllowance()??: letsParty()


FOR LOOP
    for i thru [1:10]: # for variables are implicitly hold and always mutable
        if  i % 2 == 0 :
            print('[i] is an even number')
        else :
            next
    ..
    # thru a dictionary
    mut heroes = (realName, supeheroName, age) [
        'Peter Parker'   : 'Spider-man'     , 16 |
        'Steve Rogers'   : 'Captain America', 32 |
        'Tchaka Tchalla' : 'Black Panther'  , 29
    ]
    for a thru heroes.realName:
        for b thru heroes.key(a):
            print(b)

    let interestingNumbers = (title, numberList) [
        "Prime": 2, 3, 5, 7, 11, 13     |
        "Fibonacci": 1, 1, 2, 3, 5, 8   |
        "Square": 1, 4, 9, 16, 25
    ]
    mut largest
    for x thru interestingNumbers.title:
        for y thru interestingNumbers.key(x):
            if y > largest: largest = y


HOLD VARIABLES IN LOOPS
   for x thru [1:50]:
      mut hold x = 1
      print(x * y)
      x++
   ..


LOOP
   loop :
      if x != 0 :
         print ('Hi')
      else :
         break
      ..
   ..


WHILE LOOP
   while myBool == true :
      print ('Hello ')
   ..


REPEAT WHILE LOOP
   repeat:
      print ("Hello ")
   while myBool == true


UNTIL LOOP # useful because you know the terminating condition but I might remove it tho (??)
   until myBool == true:
      print("Hello ")
   ..


REPEAT UNTIL LOOP
   repeat: print ("Hello ") $ until myBool


CHAINED CONDITION
    # 'and' and 'or' here are used in a different manner
    # than in Python
    if "two-syllable word" == pit and == pot:
        print("That's wierd")
    # or better
    if pit and pot == "two-syllable word":
        print("That's wierd")

    if pit or (pot and pet) == "two-syllable word":
        print("That's wierd")


CONDITIONAL/TERNARY OPERATOR
    # ternary operator
    mut myVar1 = myBool == true ? 5 || 6
    func divide(num, denom): rt denom == 0 ? nan || num / denom
    mut salary = (workYears > 5 ? 10_000 || 1_000) * rank # when conditional ternary expression appears
    # within another expression, it must be bracketed
    # conditional operator
    mut state = isSick == true? # evaluation returns either true or false, not to be used in an if condition
    if isSick == true? : print("go to the doctor") # error! redundancy


RANGE
   let x, y, z = [1:3]
   for x thru [1:(20 - 1)]: print(x)


THRU
   for x thru [1:20 - 1)]: print(x)
   mut y = for x thru [1:30]: x # a for comprehension that returns a list of 1 to 30 same as
   mut y = [1:30]


WHERE
   if p.age == 20 => p.name == "Allen": p # not really useful here
   # same as
   if p.age == 20 & p.name == "Allen": p

   for item thru library => item.title.startsWith("The"):
       mut hold x = 0 ; print(x++)


FOR COMPREHENSION
   list = for x thru [1:30] => x % 2 == 0: x * 3
   for b thru books, a thru btitle] => a.startsWith("The"): x


THRU/STEP
    # Not all iterable have a step method
    for x thru [1:6] step 2:
        print(x)
    ..


IN
    mut x = 3
    if x in [1:10]:
        print(x)
    ..


NOT IN
    mut arr = for x thru [1:30] => x not in [2:5]: x * 3


NIL STATE AND OPERATOR
    # There are two states an object can have, valued state or nil state. An object with valued state can
    # contain primitive values or other objects, but an object with a nil state only has nil.
    mut name = nil # Flexible variables can be assigned nil
    let name =: Str.nil # Strictly bound variables cannot, the nil must be of a particular object
    mut penny = purse.change() ?? 0 # This expression returns 0 if returned value from purse.change() is in a nil object
    mut pay = (jobHours ?? 0) * 50 # when nil operator appears within an expression it should be bracketed
    let balance = remote.(account??Account("Empty")).getBalance() # Needs to be handled if returned nil is not of a particular object


ONE-LINE BLOCK
   func addTwo(a b =: Int) Int:
      print (a + b)
      rt a + b
   ..
   func addThree(a b c =: Int) Int: print (a + b + c) ; rt a + b + c
   if x == y
   if x == y : print(x)
   if x == y : print(x) $ else : print(y)
   if state == "Play": play() $ if state == "Stop": stop()


NAMELESS BLOCK
   func doSth():
       mut x, y, z = 1, 2, 3
       use x, y: # can only access x znd y
           print("[x] : [y]")
   ..
   func doSth():
       mut x, y, z = 1, 2, 3
       use: # cannot access variabes from outer scope
           print("[x] : [y]") # error!
   ..
   func doSth():
       mut x, y, z = 1, 2, 3
       func(): # can only access any variable from outer scopes
           print("[x] : [y]") # error!
   ..


LABELS
   [label: outer]
   for i thru [1:10]:
      for j thru range(10) :
         print('i : [i] j : [j]')
         if j == 5:
            next outer
         ..
      ..
   ..


SKIPPING BLOCKS
   [skip : 3]
   if x == 5 : print('Hello') # block is skipped after the it has been executed 3 times.


FUNCTION DEFINITION
   func add(a =: Int, b =: Int) Int:
      rt a + b
   ..
   # a parameter can have default value. Before nko
   func add(a =: 0, b =: 0) Int:
      rt a + b
   ..


RETURNING A VALUE
   func add(a =: Int, b =: Int) Int:
      rt a + b
   ..


EXPRESSION-ORIENTED
    # Pluto is an epression-based language. If an exprssion evaluates to something, it is returned
    let myBool = myName == "Nypro"?
    func add(a, b): rt a + b
    # or
    func add(a, b): a + b
    # sometimes rt is needed to return an evaluation immediately
    # to prevent execution spilling back into parent block when not needed
    func hypot(x, y):
        let x = abs(x)
        let y = abs(y)
        if x > y:
            let r = y/x
            rt x * sqrt(1 + r + r)
        ..
        if y == o:
            rt zero(x)
        let r = x/y
        y * sqrt(1 + r + r)
    ..


STICKY LOCAL VARIABLES
  # I like sticky local variables because it brings variables closer to where they are needed
   func add(a =: Int) Int:
      sticky sum = a # this variable will maintain its state whenever add function is called
      rt sum += a
   ..


GLOBAL FUNCTIONS
   # Pluto comes with some helpful global methods
   mut str = "Hello"
   length(str)
   typeMin(25)
   typeOf(Int)


LIST DECLARATION IN FUNCTION PARAMETER
   func add(a, b): a + b # parameters a and b are deferred-inferred, their types will be inferred when they are called.
   func add(a, b =: Int): rt a + b # a is deferred-inferred, b is Int
   func add(a b =: Int): rt a + b # both a and b are Int, = is left associative here
   func add4(a b, c d =: Int) Int: # a and b are deferred-inferred, c and d are Int
      rt a + b + c + d
   ..


CONSTANT PARAMETER
    # function parameters are mutable by default, but they can be made immutable by specfying let
    func add(let a, let b): c = a + b ; rt c


ARGUMENT NAMING
   func addPerson(name = 'Aditya', age = 28)
   func sum(a, b = 1, c = 0):
      rt a + b + c
   ..
   # arg naming can be used to skip optional args
   sum(3, c = 6) # b skipped


VARIADIC PARAMETERS
   func sum(first =: Int, others =: Int []):
      mut tmp = first + arr
      for x thru arr:
         tmp += x
      ..
      rt tmp
   ..
   # or better
   func sum(first =: Int, others =: Int []): rt first + others
   mut lion = sum(1, 2, 3, 4, 5, 6)

   mut dean = [1, 2, 3, 4, 5]
   let jean = sum(0, dean)
   mut joan = sum(0, [1, 2, 3, 4, 5])
   mut jane = sum(0, 1, 2, 3, 4, 5)
   func add(a = 3 []): rt sum(a) # conflicts with the function below
   func add(a, b, c): rt a + b + c # conflicts with the function above



MUTATIVE FUNCTIONS
    func add(x, y): a + b
    func swap!<T>(x y =: ref T): x, y = y, x # use exclamtion mark for functions
    # that can mutate objects passed to them
    mut tip = add(2, 3)
    mut top = add(4, 5)
    swap!(tip, top)


UNOVERLOADABLE FUNCTIONS
   func add(args = [])
   func add<T>(args =: [] T) T


RETURNING AN ARRAY
   func addThree (a b c =: Int) 3 Int []:
      mut arr = [a + b, a + c, b + c]
      arr
   ..
   p, q, r = 1, 2, 3
   x, y, z = addThree(p, q, r)
   w= addThree(p, q, r)[1] + z

   func addSubTwo(a b =: Int) Int []:
      let arr = [a + b, a - b]
      arr
   ..


RETURNING A DICT
   func getDetails(u = User):
      rt (name, age) [.name, .age ]
   ..
   mut x = (id, age) getDetails() # the headers can be respecified


RETURNING VARIABLES
   # check for pass table in notes
   func getReadOnly() []:
      rt read myList # unmodifiable after it has been returned
   ..
   func getVal():
      rt val myList
   ..
   func getRef():
      rt ref myList
   ..
   func getOwnership() [,]:
      rt array
   ..
   mut pat = val getVal() # redundant
   mut put = ref getRef() # redundant
   mut pit = read getReadOnly() # redundant
   let cup = ref getVal() # returned value is moved
   let cap = val getRef() # returned reference is copied
   mut cep = own getRef() # error, already has reference
   mut cip = iso getRef() # error, already has reference
   mut hola = read getVal() # returned value is moved, but cannot write


FUNCTION OBJECTS
   mut add2 = add
   mut add3 =: Func
   mut add =: func(Str)Str
   func solve(a, b, c =: func(Int Int)Int ): c(a, b)
   mut new = func(a b =: Int): rt a + b


EVENTS
   mut mathOps =: func(Int, Int)Int
   mut mathOps += add, subtract, divide, multiply # once a other functions are attached to a function, it becomes an event
   mut mathOps -= divide


CLOSURES
   func outer():
      mut a = 6
      rt func (b =: Int) : a + b # a closure can access variables in outer scope
   ..
   mut add = outer
   # nameless closures (except those returned by a function or another closure) are executed at the
   # point they are declared
   # named closures on the other hand are not executed until they are called
   func add (x y =: Int):
      func (): rt x + y
   ..
   mut sum =: Func
   mut sum = add
   mut foo =: func(Int, Int)Bool


FUNCTION AS ARGUMENTS
   func addThree(a, b, c, foo =: func(Int, Int)Bool):
      rt myFunc(a, b) + c
   ..
   addThree(1, 2, 3, func (a, b): a * b)
   # or
   addThree(1, 2, 3) do a, b: a * b

   func add(a, b): a + b
   addThree(1, 2, 3, add) # passing and already-declared function


ANONYMOUS TYPES
   func keyListener(e =: Event): e.printText()
   keyListener(
      Event:
         func printText():
            print ('Hello, World')
         ..
      ..)


LAMBDAS
    func keyListener(e =: Event): e.printText()
    keyListener(
      Event:
         func printText():
            print ('Hello, ')
         ..
      ..)
    keyListener(func(): print("World")) # lambda
    keyListener(: print("World")) # shortened lambda using 'rt'
    arr.filter(func(a): pivot > a) # anonymous functions
    arr.filter() do a: pivot > a # function argument
    arr.filter(: pivot > _1) # lambda
    numbers.filter(: _1 % _2 == 0).map(: _1 * _2).reduce(2, +) # lambda
    let reversed = sort(names, : _1 > _2 )


FUNCTION CHAINING
    let x =: students.filterOutFailed().sortByGrade()
    let y = add(4, 2) |>  subtract(_, 1) |> divide(10, _)


MATCH FUNCTION
    match check30DayMonth(month = Month):
       case _.value == 4 : print("This is April, a 30-day Month!")
       case _.value == 6 : print("This is June, a 30-day Month!")
       case _.value == 9 : print("This is September, a 30-day Month!")
       case _.value == 11 : print("This is November, a 30-day Month!")
       print("Not a 30-day Month!")
    ..


COROUTINES
   # New Proposed Coroutine with Concurrency. Thanks to Go 03/08/16
   # Go-type Coroutine
   # I dunno yet if pipe can only be primitive types. I think that will be too restrictive.
   # This needs heavy review
   # Go-type Coroutine is so powerful that it can be used to achieve concurrency, distributed computing and parallelism
   # THE 'run' CALL
   func show(s =: Str):
       for x thru [1:3]:
           print(s)

   func main():
       show("Hello")
       run show("Hi")
       show("Hullo")
   ..
   # Hello Hello Hello Hi Hi Hullo Hi Hullo Hullo
   # PIPES
   func work(pipe x =: Bool):
       print("working...")
       time.sleep(1500)
       print("done")
       x <- true
   ..
   func main():
       pipe done = Bool
       run work(done)
       <- done
   ..
   # working...done
   # BUFFERING AND CLOSING PIPES
    func task(pipe x =: Str):
        loop:
            if !closed(x):
                print("working...")
    ..
    func main():
        pipe a =: Str
        run task(a)
        time.sleep(time.second * 6)
        close(a)
        print("done")
    ..
    # SELECT
    func main():
        pipe a, b =: Str
        run func ():
            time.sleep(1000)
            a <- "One"
        ..
        run func ():
            time.sleep(2000)
            b <- "Two"
        ..
        select:
            case a: print(<- a)
            case b: print(<- b)
            print("Nothing")
        ..
    ..

    # Python-type coroutine
    func coroutine():
        for x thru 1..10:
            yield x
    ..
    print(coroutine()) # 1
    print(coroutine()) # 2
    print(coroutine()) # 3
    coroutine.reset() # resets the coroutine
    list(coroutine()) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # Simulated coroutine using sticky variables
    func addUp(a, b):
        mut sticky x
        if x == _init:
            rt x += b
        else:
            rt x = a + b
    ..
    print(addUp(3, 4))
    print(addUp(0, 5)) # gotcha! only the second argument is summed up.
    print(addUp(0, 6)) # gotcha! only the second argument is summed up.


TYPE DEFINITION
   type Car:
      mut name, model = Str
      func (name =: Str):  # Constructor implicitly contains a first parameter of type Car
         self.name = name
      ..
      func (name, model =: Str):
         self.name = name
         self.model = model
      ..
   ..


CONSTRUCTOR
    type Person:
        mut name = Str
        mut age = Int
        func (name =: Str, age =: Int):
            .name = name
            .age = age
        ..
    ..
    # A constructor without body initialises the fields with the corresponding parameter
    type Person:
        mut name = Str
        mut age = Int
        func (name, age) # which means there is no such thing as virtual constructors
    ..


CONSTRUCTOR TYPES
    # Constructor classes have only one constructor and an optional set of parameters that are also the only fields of the class
    # These fields are mutable by default and are always public.
    type Person (name, age)
    mut dave = Person("Dave", 45)
    dave.age = "David"
    type Car (model make =: Str, year = : Int) [Vehicle]


SELF REFERENCE
   type Car:
      mut name, model = Str
      func (name =: Str):
         .name = name # the self can be ommitted leaving the dot and the field
      ..
      func (name, model)
   ..
   # this is also applicable to methods where its is the type of the first parameter
   func getDetails(car =: Car): rt [.name, .model]
   func hasModel(car =: Car, model = Str): .model == model?


USING A FUNCTION AS METHOD
   func show(p =: Person): print("name: [.name], age: [.age]")
   mut nigel = Person("Nigel Nicargua")
   show(nigel)
   mut nigel.show() # using show funtion like a method since Person is the first argument
   # you can also use it on objects directly
   mut a = Person("Nigel Nicargua").getDetail()
   mut b = "hello".upper()
   mut c = 25_000.divideBy(x) # Don't do this though. :)
   mut d = (2f/4f).floor()


DESTRUCTORS
    type Car:
        mut name, model = Str
        func (name)
        func (name, model)
        func (!) : # Destructor implicitly contains a first parameter of type Car
            print('Object Destroyed!')
    ..


PROPERTIES / GETTERS SETTERS
    mut myVar1 = func set(a b c =: Int): _ = a * b * c $ func get(): rt _
    myVar1 = 1, 2, 3
    mut myVar2 =
        func set(a b =: Int): _ = a * b * c
        func get(): rt _
    myVar2 = 1, 2
    mut myVar3 = func set(a =: Int): _ = a $ func get(): rt _
    myVar3 = 1
    mut myVar4 = func set(a =: Int) $ get()
    myVar3 = 2
    mut tip = func get(): rt myVar3


TYPE CHECKING
    # Is
    if myCar === Car:
        print('myCar is a Car')
    ..
    if myCar ==: Car:
      print('myCar is a Car or its subtype')
    ..
    if myCar =<: Car:
      print('myCar is a subtype of Car')
    ..
    if myCar =>: Car:
      print('myCar is a supertype of Car')
    ..
    # Is Not
    if phone !== Phone:
        print("phone is not a Phone")
    if phone !=: Phone:
        print("phone is not a Phone or its subtype")
    if phone !<: Phone:
        print("phone is not a subtype of Phone")
    if phone !>: Phone:
        print("phone is not a supertype of Phone")


MODULES AND IMPORT
    # source files should be marked with module name
    module Math
    # a module name can be used on other files within a file-level to mean the same module
    # if the same module name is used in different file-levels, they are not the same module
    # import statement imports a module or its contents
    import Net # imports all types and funcions in a module
    import nypro.Math: add, subtract # imports only add and subtract functions from the module
    # Some modules are imported implicitly, the IO module for example
    # Other stdlib modules are imported at the top-level because they are automatically searched during a module search.
    import Net: Protocol as Proto
    import nypro..Math # if the module has the same name as the enclosing file, you can skip the filename # this behaviour is case-insensitive


TYPE ALIAS
   Int as Meter
   import marko.IO: MarkosSimplifiedRegex as Regex
   func(Str Int)Str as StrIntFunc
   mut d = StrIntFunc



METHOD CHAINING
- Method chaining is automatic, no need to return self
   type Math:
      mut value = Float
   ..
   func add(a =: Math, b c =: Float) Float:
      a.value = b + c
   ..
   func subtract(a =: Math, b c =: Float) Float:
      a.value = b - c
   ..
   mut m = Math
   m.add(1, 2).subtract(3, 4)
   mut n = "This is the first string".&"This is another string".reverse().toUpper()


INHERITANCE # Not Finalized!
    # Note that inheritable methods need =: operator when specifying their first parameter
    type Animal
    func move(a =: Animal)

    type Bird [Animal]
    @mask
    func move(a =: Bird): print("Soar!") # overides move method for Animal, a super method
    func fly()

    type Horse [Animal]
    @mask
    func move(a =: Horse): print("Gallop!") # overides move method for Animal, a super method
    func gallop()

    type Pegasus [Bird, Horse] # inherits Bird and Horse classes
    @mask
    func move(a =: Pegasus): print("Soar and Gallop!") # overides move method because of CONFLICT in  Bird and Horse

    mut eagle = Bird()
    mut horse = Horse()
    mut pegasus = Pegasus()
    move(eagle) # "Soar!"
    move(horse) # "Gallop!"
    move(pegasus) # "Soar and Gallop!"
    mut animals = Animal[Bird(), Horse(), Pegasus()]
    animals[1].move() # "Soar!"
    animals[2].move() # "Gallop!"
    animals[3].move() # "Soar and Gallop!"


OVERRIDING METHODS
    # Pluto now has an override hint called @mask. It is optional but recommended for
    # static-oriented codes. If you don't want to use the mask hint then you'll have to specify that
    # in the compiler hint or compile the code with the -mask (debatable) flag.
    func play(a =: Player): .start()
    @mask
    func play(a =: DigitalPlayer): .startAt(0)


COVARIANCE
    # Pluto supports covariance using =: operator on the first parameter in a function
    type Person (name =: Str, age =: Int)
    func showDetails(p =: Person): print("name: [.name], .age: [.age]")
    type Engineer (kind =: Str) [Person]
    type Artist (kind =: Str) [Person]

    mut person =: Person("Peter", 16)
    mut engineer =: Engineer("Civil Engineer")
    mut artist =: Artist("Painting Artist")
    # covariance in assignment
    mut person =: Person("Matthew", 25) # home type
    mut person = engineer # guest type
    mut person = artist # guest type
    # covariance in argument passing
    showDetails(person)
    showDetails(engineer)
    showDetails(artist)
    # covariance in container types
    mut arr =: Person[]
    mut arr[1:] = [person, artist, engineer]
    # covariance in overriding
    func eat(a =: Herbivore, b =: Plant):..
    @mask
    func eat(a =: Cow, b =: Grass):.. # not only is the supermethod overriden, the arguments too are covariant
    # The sae applies to the contravariance assignment operator


SUPERMETHODS AND SUBMETHODS
    # inheritable methods always use =: operator to specify the type of their first parameter
    type Listener
    type ButtonListener [Listener]
    func respond(a =: Listener) # this is a super method to the more specific method below
    @mask
    func respond(a =: ButtonListener):.. # this is a sub method to the method above


CALLING SUPER
    type Person:
        mut name = Str
        mut age = Int
        func (name, age)
    ..
    type Artist [Person]:
        mut kind = Str
        func priv (job)
        func (name, age, kind):
            super(name, age) # calls the parent constructor to initilize parameters
            self(kind)
        ..
    ..
    # or
    type Artist [Person]:
        mut kind = Str
        func ((name, age), kind)
    ..
    # or better
    type Artist ((name, age), kind) [Person]


VIRTUAL METHODS
   func respond(a =: Listener) # a method without a body is implicitly virtual and cannot be called however.
   # constructors cannot be virtual and therefore use the same syntax for shortening initialisation
   @mask
   func respond(a =: ButtonListener) # error, a virtual super method can't be overriden by a virtual sub method


COVARIANT OVERRIDE
    # You can override an inherited method using by replacing the original agruments with their subtypes
    func eat(a =: Herbivore, b =: Plant)
    @mask
    func eat(a =: Cow, b =: Grass) # valid override


ABSTRACT TYPES
   type abs Player # cannot be instantiated
   func play(a =: Player)
   func rewind(a =: Player)
   func fastForward(a =: Player)
   type CassettePlayer [Player]
   type DigitalPlayer [Player]
   # Note that an abstract type cannot be solo


DOWNCASTING
  # assuming Movie and Song extends MediaItem
   library = MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   for item thru library:
      if item === Song:
         print('Song: [song.name]')
      elsif item === Movie:
         print ('Movie: [movie.name]')
      ..
   ..


UNINHERITABLE CLASS
    # Why would I want a user not to inherit my class. I might remove this class in the near future
    type solo MyType:
        x = 'Type Cannot Be Inherited'
    ..
    # an abstract type cannot be solo


GENERICS
    # Type Parameter
    <T> # Integer and subtypes
    <T[Integer]> # Integer and Integer subtypes
    <T[<:Integer]> # Integer subtypes
    <T[>:Integer]> # Integer supertypes
    <T[Str|Int]> # Str and subtypes or Int and subtypes
    # the parametric values of a generic function/constructor call can be inferred
    # if all the generic parameters are exposed through function/constructor arguments
    func add<T>(a b c =: T): a + b + c
    # so instead of calling it like this
    add<Int>(1, 2, 3)
    # you can also do this, since the generic parametric values are inferrablfrom the arguments
    add(1, 2, 3)


DATATYPE OBJECTS
    # Just as variables and function have types, types also have types. :/
    # The type of types like Int, Float, Str is DataType
    mut var = Car("Camaro")
    typeOf(var) # Car
    typeOf(Car) # DataType
    checkIfStr(a): a === Str?
    # Note that a DataType object, assuming Artist with a parent type Person, is a DataType,
    # is a DataType(Artist) and is a DataType(Person)
    enum Letter: A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z
    A === DataType? # true
    A == A? # true
    A == Letter? # true
    let a = DataType(Car) # DataType objects are exposed thru DataType constructor and can be assigned to variables
    print(a) # Car

ENUMS
    # enum is an abstract type that contains ONLY its subtypes.
    # its subtypes are all constructor types and only extend the enum
    # also an enum object expects a subtype as value
    enum Friends: Deji, Tosin, Tola # Deji, Tosin and Tola are parameterless conctructor types
    match whichFriend(f =: Friends):
        case Deji : print("This is Deji")
        case Tosin : print("This is Tosin")
        case Tola : print("This is Tola")
    ..
    mut closeFriend =: Friends.Deji
    whichFriend(closeFriend)
    enum Number: IntegerNumber(i =: Integer), RealNumber(r =: Real) # IntegerNumber and RealNumber are constructor types
    # Enums provide access to its subtypes using the access operator
    Friends[1] # Returns a DataType object, here the DataType object is Deji
    # Iterating thru enum
    for x thru Friends:
        print(x)
    ..


PATTERN MATCHING
    # EXAMPLE: How to compute a tree-like expression
    type abs Tree
    type Leaf<T>(value =: T) [Tree]
    type Node (l = Leaf, r = Tree) [Tree]
    match sum(t =: Tree):
        case Leaf: t.value
        case Node: sum(t.l) + sum(t.r)
    ..
    mut x = Node(Leaf<Int>(1), Node(Leaf<Int>(2), Leaf<Int>(3)))
    mut y = sum(x)
    # or better
    enum Tree<T>: Leaf(value =: T), Node(l =: Leaf, r = Tree)
    match sum(t =: Tree):
        case Leaf: t.value
        case Node: sum(t.l) + sum(t.r)
    ..
    # you can use this verbose version
    mut x =: Tree<Int>.Node(Tree<Int>.Leaf(1), Tree<Int>.Node(Tree<Int>.Leaf(2), Tree<Int>.Leaf(3)))
    # or better
    mut x =: Tree.Node(Leaf(1), Node(Leaf(2), Leaf(3))) # the generic type is inferred
    mut y =: sum(x)


REGEX
    mut number =: /\d+(\.\d+(e[-+]\d+)?)?/
    mut input = "23.4e+5"
    if input ~= number: print("input is a number") $ else print("input is not a number")


EXPLICIT TYPE CASTING
   mut x =: Int(5)
   mut y =: Byte(6)
   let z =: y + Int(y)


ATOMIC EXPRESSION # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock: x = 5; y = x
   lock: if y == 5: print('y is 5')


ATOMIC BLOCKS # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock block:
      x = 5
      y = x
   ..
   # or better
   lock:
      x =: 5
      y = x
   ..
   lock if tip == top:
   print("Hello")
   print(", World!")
   ..


OPERATOR OVERLOADING
    func +(x =: Number, y = Number): x.value + y.value
    _setIndex(a =: Int): arr[a]
    _convert(a =: DataType(MyString), b = Int): b.toStr()
    # you can't add "!" infront of a mutative operator function
    func ++(a =: Number): a.value++
    # check Julia and Swift for reference


CUSTOM OPERATORS
    # Pluto, like Swift, allows you to create your own set of custom operators that are not
    # provided by the language. The oprators you can string together include
    # + - * / = < > % ^ & | ! ?
    # you have to specify operator position, associativity and prcedence for custom operators
    [op: 180, left, postfix] # this operator has a predence level of 180, left associativity and is a postfix operator
    func **(a =: Number): a.value ^ 2


TRY & ASSOCIATES
    # A try statement or block must always be paired with one or more except statement even if the except catches nothing
    func main():
        ensure:
            file.close()
        ..
        print("I'm about to open a text file and print its first 500 characters")
        mut file =: File("C:/Users/Hello/hello.txt")
        try file.open().print([1:500])
        except(fnfe =: FileNotFoundErr, ioobe =: IndexOutOfBoundErr):
            if fnfe: printErr('Can\'t find file!')
            if ioobe: printErr('Out of index error!')
        ..
    ..

    try:
        file.open()
        file.write('Hello')
    except(fnfe =: FileNotFoundErr):
        printErr('Can\'t find file!')
    ..

    try:
        raise Err() # this raises an error, but does not stop program
        err Err() # this raises an error, and stops the program after error handling
    except(e =: Err):  # catches all exception
        printErr('Error!')
    ensure:
        file.close()
    ..

    try let x =: getObject()
    except(ne = NilErr):
        printErr('x can\'t be nil!')
    ..

    try:
        if let x =: getObject(): $ else: raise NilErr()
    except() # this catches nothing

    try:
        let x =: getObject()
    except:
        printErr('x can\'t be nil!')
    ..

    try:
        file.open()
        let x =: file.readLine()
    except(ne =: NilErr):
        printErr('x can\'t be nil!')
    except(fnfe =: FileNotFoundErr):
        printErr('Can\'t find file!')
    ensure:
        file.close()
    ..


ASSERTION
    assert(x == nil)
    # definition of assert
    @macro
    assert(a):
        # TODO
    ..


ITERATORS (?)


FLOATING POINT BITWISE OPERATORS - Will Remove this!!


HINTS
    # a hint can have parameters declared in a symbol brackets
    @deprecated {msg = "MediaPlayer class should be used instead"}
    # a hint can introduce a block with colon.
    @if {plat = "Mac"} print("This is a Machintosh Computer")
    @if {plat = "Win"}:
        print("This is a Windows Computer")
    #------------------------------------
    @compiler # evaluated at compile-time
    @linker # evaluated at link-time
    @runtime # evaluated at runtime



COMPILER HINT
    @compiler {
        typing = "static"
        variable = "immutable"
        warn_me = {
            unimplemented_inherited_functions,
            unimplemented_inherited_fields
        }
    }


COMPOUND HINT
    # compound hint is a hint that contains other hints and
    # it can only be in the same module as the main function
    @compound:
        @if {plat = "Win"}:
            print("This is a Windows Computer")
        @elsif {plat = "Mac"}:
            print("This is a Machintosh Computer")
        @elsif {plat = "Linux"}:
            print("This is a Linux Computer")
    ..


NON-STANDARD STRING LITERAL HINT
    byteArray =: ba"87004"
    @strLiteral:
        re: {ByteArray(_str)}


METAVARS CONTEXT SPECIFIC ENVIRONMENT
    arr[_last] = 20
    if(x == _even)
    match check30DayMonth(month = Month):
        case _.value == 4 : print("This is April, a 30-day Month!")
        case _.value == 6 : print("This is June, a 30-day Month!")
        case _.value == 9 : print("This is September, a 30-day Month!")
        case _.value == 11 : print("This is November, a 30-day Month!")
    print("Not a 30-day Month!")
    ..
    mut sum =: add(a, b) |> add(_, x)
    mut tip =: func set(a = Int): _ = 25 $ func get(): rt _


LIST OF METAVARS
   _init # to check if sth is initialised
   _
   _last
   _even
   _odd
   _min
   _max


REFLECTION
    # dynmically determining which class to use
    @if (stage = "runtime", condition = "Main.useOldClass == true"): # ????
        type Class:
            mut value = func set(x Str): _ = x $ func get(): rt _
            func (value)
        ..
    @else
        type Class:
            mut str = func set(x =: Str): _ = x $ func get(): _
            mut num = func set(x =: Float64): _ = x $ func get(): _
            func (str)
            func (str, num)
        ..
    ..


MACROS !! Needs Work
    #
    @macro
    reverseExpression(ex):
        # TODO
    ..
    if reverseExpression(x < y) : print


COMPLEX, QUATERNION DECLARATION
    mut x = 5 + 2i # complex
    mut y = 5 + 2i + 3j + 4k # quaternion


MATHEMATICAL EXPRESSION
    let top =: m{3x - 2y/5 + r(d^5)} # operator precedence still applies
    let tip =: m{3x y z^2} # when there is no operator between 2 operands, multiplication is assumed
    mut pat = m{4y - 2x(z^2) getSalary()} # you can use functions and variables directly
    mut pet = m{4d 5f} # MathExpr doesn't support numeric literals with type prefix. 4d and 5f here means 4 * d * 5 * f
    mut pot = m{5y [getValue[2]] 3e-1 + [4d]} # Use '[' and ']' to escape literals with fp type prefix or
    # variables that use index operator. 4d here is a Double literal and getValue[2] gets the value in index 2.


SYMBOL, EXPR, HOMOICONICITY & OTHER SYMBOLIC CLASSES
    # Symbol
    # delimited by spaces and commas
    # interpolated using "[]"
    # can also be nested {x, {y, b}}
    mut buck =: {1}
    mut back = {1 2 3}
    let bean = {hello {hi {halo}}} # can be nested too
    let beak = {"hello ", [name]}
    let x = beak[1] # hello
    let y = beak.toStr() # hello Nypro
    # Expressions
    mut pat =: ex{1 + 2 * [number]}
    mut exp = parse("1 + 2 * 3")
    mut ingrid = eval(exp)
    parse(pat)
    mut math = m{3x - 2y/5 + r(d^5)}


COMPILE TIME SYMBOLS ??
    # Symbols is different from macros in that, the content is only broken down
    # as specified by the programmer, but it is evalusted at runtime as strings
    # This could be useful for PEG lib, for example, cos structures can be taken from
    # the user and then broken down at parse-time.


CPLUSPLUS SYMBOL
    mut str = cpp{void add(int a, int b) {return a + b;}}
    parse(str)
    let sum = str.add
    mut brim = sum(1, 3)


NON-STANDARD SYMBOL LITERAL HINT
    mut cxxCode = cpp{void main() {printf("Hello")}}
    @symLiteral:
        cpp = {Cpp(_sym.toStr())}


NUMERIC CLASS
    let x = UInt.max()
    let y = Int32.min()
    mut z = m{2x + 4y/3}.round() + (24.25/4).floor()


RATIONAL CLASS
    mut xianghou = 2//3
    mut dean = x.toFloat() # rational format can be changed to fp
    mut bean = 4//6 ; print(y) # 2//3
    4//2 == 1//2 # true
    4//2 == 0.5 # true


RAW CLASS
    # bits stored in multiples of 8
    let bits8 = Bits<8>
    let bits16 = Bits<16>


INTEGER BITWISE OPERATORS
    mut myVar = 2.&2 # and
    mut myVar1 = 2.|2 # or
    mut myVar3 = ~2 # exclusive or


SHIFT OPERATORS
    mut myVar = 4<<1
    mut myVar = 2>>2


BINARY LITERALS
    mut myVar = 0b11001001


HEXADECIMAL LITERALS
    let myVar = 0x5eff77


OCTAL LITERALS
    mut myVar = 0o56773


UTF-8 CHARACTERS
    let char =: '\u6E'


CLASSES OF OBJECTS
    Obj (0.7), Any (0.8)
    Func (0.7)
    Var (0.7), Indie(0.8.2)
    Array (0.7)
    Dict (0.7)
    Exp (0.7), Expr(0.8.2)
    # Nil (0.4), None (0.8.1), # Removed (0.8.2)
    Symbol(0.7)
    DataType(0.8.2)


PREDEFINED TYPES # These types are optimized as part of the lang
    Int, Int16, Int32, Int64
    UInt, UInt16, UInt32, UInt64
    Float16(0.8.2), Float/Float32 (0.4), Float64/Double (0.6.1)
    Bool (0.4)
    Str (0.4), String (0.6.1), Str (0.8.1)
    Char
    Byte
    SByte
    Comp, Comp128
    Quat, Quat256
    Num (0.4) #= redefined in (0.8.1) =#, BigInt, BigFloat (0.8.2)
    Ratio


LOGICAL vs BITWISE OPERATORS
    ! & |
    ~ .& .|


KEYWORDS
    stick (0.4) sticky  (0.6.1)
    # pub (0.4) public (0.6.1) pub
    priv (0.4) private (0.6.1) priv
    pro (0.4) protected (0.6.1) prot
    pack (0.4) package (0.6.1) pack
    pass (0.7.5)
    class (0.4)
    rt (0.7.2)
    def (Rev 0.5.2), def (0.8.2), func (0.8.2)
    let (Rev 0.5.2)
    get (Rev 0.5.2)
    set (Rev 0.5.2)
    as (0.8)
    if
    else
    elsif
    while  (0.6.1)
    eval (Rev 0.5.2) match (0.8.1)
    for
    do
    until (0.6.1)
    next (0.6.1)
    break
    label (0.7.0)
    use (0.5.2), use (0.8.2) # reintroduced
    # fixed
    thru (0.8)
    in(0.7.2)
    skip(0.8)
    ensure (0.8)
    try
    except
    self
    mut (0.8)
    nan (0.8)
    nil
    op (0.8.2)



OPERATORS
    +
    -
    *
    /
    // # for ratios
    ^
    %
    --
    ++
    =
    =:
    <:
    >:
    ::
    +=
    -=
    *=
    /=
    //=
    ^=
    %=
    ==
    !=
    ===
    !==
    ==:
    !=:
    =<:
    !<:
    =>:
    !>:
    !
    >
    <
    >=
    <=
    &
    |
    ~
    .|
    .&
    >>
    <<
-   '
    .=


SYNTACTIC SYMBOLS
    |, $ (0.8.2)
    ;
    @
    :
    ..

---------------! NOTES !------------------------
VARIABLE BINDING



LITERALS
- Literals are subexpressions that do not return unlike other subexpressions (variable access)
- or expressions (operations, function call).
Type of Literals
- Numeric
    50, 12_000_i32, 78.89e-2
- String
    "Hello", 'Hi'
- Symbol
    {Root}, {Parent {Child1 Child2}}


NIL
- There are two states an object can have, valued state or nil state. An object with valued state can
- contain primitive values or other objects, but an object with a nil state can only contain nil.
- Nil can be assigned to an object directly (a syntactic sugar for the object's nil state),
- but they cannot be returned. Although one can pass or return an object with a Nil state.
- The recieving object must handle it or else NilErr will be invoked.
    mut deal = nil # is Any~nil
    mut done = deal # error! NilErr
    mut deck = deal?? # deck now accepts nil
    # you could also do this
    mut dark = deal??0  # dark will be 0 if deal is nil


OBJECT HIERARCHY
- Any -> Indie, Array, Func,
- Array -> Dict, Tuple


CONCURRENCY


CONDITIONALS
- Value
- nil or not
- True or false
- Type (===)


ITERABLES
- Coroutines
- Functions
- Range
- Array objects
- Table objects
- Iterable SubClasses
- String
- Enums


SUBJECT OF OPERATIONS
# is signified by '_'
- Stack
- Match
- Properties


AUTOMATIC REFERENCE COUNTING
- There can only be one strong ref to an object
    type Skeleton:
        bones List<own Bone> # bones contain a list of strong Refs to Bone objects
    ..
    type Bone:
        skel Skeleton
    ..


MOVE SEMANTICS
- Move feature is automatic in areas where it makes sense to do so for example, returning a value (not reference) to a variable.
- I removed the explicit move keyword cause I think it will have some unwanted side effects. For example, moving a returned reference which is also referenced elsewhere.
- And Pluto moves at the appropriate places anyway.



DECLARATIVE PLUTO ".deplu" #27/06/16
   person:[
      name : "Nypro"
      fat : false
      tall : true
      hobby : 'programming'
      single : _ # underscore as a value signifies empty
      children : [2, 3, 4, 6]
      coord : [x : 5]
      coords : [x : 1, y : 2, z : 3]
      gamesLiked : name, releaseDate, hard [
         ["Crysis", 2007, _],
         ["Unreal Tournament", 1999, true],
         ["Portal 2", 2011, true],
      ]
   ]


DUCK TYPING EXAMPLES
   mut c
   mut a = 25
   mut b =: [1, 2, 3, 4, 5] # array
   mut c = [1, 2, 3 | 4, 5, 6] # multi dimen array
   mut d = ['Hello', 25, 1.3f, 'Hi'] # table
   func getArea(length, breadth):
      length * breadth
   ..
   mut length = 10
   mut breadth = 25
   mut rectangleArea = getArea(length, breadth)


NESTED ASSIGNMENT
- Pluto does not support nested assignments. Dunno really :p
   mut tip = 5
   mut tap = (tip *= 5)


PASS TABLE
#=
    Types                               |   Passed Around By
    ----------------------------------------------------------
    Built-in Ind Types /  Value Types   |   val
    Array Types                         |   ref
    Func Types                          |   ref
    Custom Types                        |   ref
=#
- Note that objects of relatively small Array, Func and Custom Types
- will be allocated on the stack while simulating referencing
- And this is done only if the object is iso or guaranteed to have a
- single reference


VARIABLE VS PARAMETER
- Variable declaration is nothing like parameter declaration


COMPILER WARNINGS
- When assigning to variables in other modules
- Pluto only warns when about imported naming ambiguities when the names are accessed


RUNTIME WARNINGS


COMPILATION
- '_' is compiled as a placeholder. This will be replaced at run time by a subject of operation
- some symbolic classes are evaluated at compile-time, e.g Func, MathExpr


PUNCTUATION
- Pluto needs proper use of indentations and newline to compile successfully
- This makes code reformatable to original when copied. Especially with nested if-else blocks.
- Pluto only supports consistent space-based identation. Indentation should not use below/above 2 to 5 spaces


BIG AIMS
- If Pluto is written entirely statically, then most analyses should be done statically
- with benefits of optimisations (e.g. usingg traditional arrays). Only certain checks are
- done at runtime.
- Static ARC analysis. Be careful with concurrency.


UTILITIES
IDE
- The REPL
- Advanced Refactoring
- Code Completion
- Render/Plot View
- Profiler
-------------------
Network and Streams
- terminals
- files
- TCP sockets
- pipes
-------------------
Virtual Machine
- PlutoMine
-------------------
Compilers
- Bytecode Interpreter and JIT Compiler.
