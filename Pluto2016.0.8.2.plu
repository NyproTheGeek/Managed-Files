Revised 11/08/16
# 2016.0.8.2
#=
Major Change:
   Restructuring for Multiple Dispatch
   Import is now module-based instead than type-based because of the new multiple Dispatch
   A type's method may be defined outside the type's file
   Added def to function declaration #18/08/16
   Changing assignment operator back to good ol' way, binding to nil-and-one-other-type is still enforced 19/08/16
=#

PLUTO's DESIGN PHILOSOPHY
- let it do more with less
- make it fast
- make it legible
- make it consistent
- make it flexible. Dynamic and statically typed
- make it lightweight

DESCRIPTION
Pluto is a flexible language that is both be compiled and interpreted.
It can used either as dynamically typed or a statically typed language. As a result it unifies rapid prototyping and fast performance into one cohesive syntax.

PLUTO WORLD
- PlutoSphere (advanced IDE)
- The REPL
- The AOT and JIT Compilers
- Static and Dynamic Analysis.
- AI


--! THE EXAMPLES BELOW ARE MOSTLY STATICALLY TYPED !--
SINGLE-LINE COMMENTS
   # Hello


MULTILINE COMMENTS
   #=
   I'm Pluto
   I'm cool
   =#


DOCUMENTATION
   # <code> Car </code>  class is deprecated # xml
   # [ code: 'Car' ] class is deprecated # deplu


VARIABLE DECLARATION & INITIALIZATION
   x ; x = Car('Camaro')
   y = 12f
   z = 'Hello'
   a = Car('Camaro')
   b = Car('Camaro').setDate(2014) # ok
   c = Car ; c = ('Camaro') # comma is used to separate two statements
   n = getCar('Camaro')
   o = add(2, 4)
   p = List<Car>(3) # generics
   def add (a, b, c := UInt) Int
   def add (a = 1, b = 2, c = UInt(3)) UInt


VARIABLES AND REFERENCES
   # see pass table below
   pet = own getObject() # pet now holds a sole strong ref to the object returned
   pet = iso getObject() # pet exclusively owns the object returned
   # some ops pass by val or ref implicitly
   # but you can explicitly specify
   put = val pet # assigned by value
   pat = own move(put) # ownership moved from put to pat, put is now nil
   pot = read pat # pot references object but cannot assign to it
   let pit = val put

   def subtract(let a, let b, let c := ref):
      c = a - b
      rt ref c
   dean = val subtract(x, y) # gets a copy
   cop = subtract(x, y) # gets a ref

   def add(a, b := ref):
      rt val a + b
   alm = ref add(val x, val y) # warning, return a val to a ref

   swap!(val a, val b)


OPTIONAL TYPE DECLARATION
   myNumber = Str|Int
   # every varaible is optional implicitly to None and one other type
   myNumber = '01000999'
   # might change the below behavior in the future
   myNumber = 23 # error! variable already bound to String


CONSTANT VARIABLE DECLARATION
   let x = 25
   let y = Car('Camaro')


MUTABLE VARIABLE DECLARATION
- When immutable is set on all variables, default variables become constants by default.
   x = 25 # x is immutable
   x = 52 # error!
   mut y = 52 # y is mutable
   y = 25 # ok


MULTIPLE ASSIGNMENT
   a, b, c = array[2:4]
   x, y = y, x
   a, b, c, d = [1:4]


NUMERIC FORMATTING
   x = 1_000_000
   y = 1_999.99


ARRAYS / LIST
   # major diff between lists and arrays is that, the type and size of an array are
   # inferrable at compile time, this allows for arrays to be stored like traditional array
   fin = Car[('Camaro'), ('Mustang')]
   gin = 3 Car[]
   gin = [('Camaro'), ('Mustang'), ('Maserrati')]
   tin = 3 Car [('Camaro'), ('Mustang'), ('Maserrati')]
   let ted = [1, 2, 3, 4, 5]
   top = ted
   go = Car[('Camaro'), ('Mustang')] # redundancy

   pot = Arr
   # or better
   pot = []
   pit = Arr{Int, 3} # an Int array with the size of three
   # or better
   pit = 3 Int []

   pet = [5] # this is an array with one element, 5
   put = 5 [] # you have to specify a type in order specify a size
   pat = 4 [1, 2, 3, 4]

   pat.foldleft(0, def (a, b): rt a + b) # (((0 + 1) + 2) + 3) + 4 = 10
   mat = getArray()
   net = getArray() # error, array not exposed, so '[]' must be used
   list(go) # list elements row-wise
   list(go[_col]) # list elements col-wise
   dean = Arr
   dean = [10, 8, 6 ,4, 2]


DICTIONARIES / TUPLES
   fin = ['Tola', 1.2, 50, 'Tola']
   dict = [
      'Peter Parker'   : 'Spider-man'     , 20 |
      'Steve Rogers'   : 'Captain America', 32 |
      'Tchaka Tchalla' : 'Black Panther'  , 29
   ]
   candidate = index, name [
      1 : 'Aditya' |
      2 : 'Nypro'
   ]
   list(candidate.index) # 1, 2
   aditya = Str Int Int ["Aditya Singh", 19, 6.2]
   aditya = name, age, height Str Int Int ["Aditya Singh", 19, 6.2]


ARRAY SLICING
   arr = [1, 2, 3, 4, 5, 6]
   print(arr[1:3]) # first index to the third
   print(arr[:5]) # first index to the 5th index
   print(arr[3:_last]) # 3rd index to the last
   print(arr[-3:]) # from the 3rd index but backwards
   newArr = arr[:] # all elements
   list(arr[_last:]) # list from behind


MULTIDIMENSIONAL ARRAY
   arr = [2, 2] [1, 2 | 3, 4]
   arr = [2, 2, 2] Int [1, 2 | 2, 3 || 4, 5 | 6, 7]
   arr = [,] [1, 2 | 3, 4]
   list(arr [:])
   list(arr[2, ]) # list columns in row 2
   list(arr[, 2]) # list rows in col 2
   arr = [1, 2] # vcat
   # 1 2
   arr = [1, 2 | 3, 4] # vhcat
   # 1 2
   # 3 4
   arr = [1 2] # hcat
   # 1
   # 2
   arr = [1 2 | 3 4] # hvcat
   # 1 3
   # 2 4


RAGGED ARRAY # is untidy !! Needs review
   arr = [2, ]
   arr = [0, +2]
   arr = [1, +3]
   arr = [0, 0, +3] ; arr = [0, 1, +3]
   arr = [1, 0, +4] ; arr = [1, 1, +5] ; arr = [1, 2, +6]


ARRAY OBJECT OPERATIONS
   arr1 == arr2
   arr1 < arr2
   arr3 = arr1 / 2


MATRIX-VECTOR OPERATIONS # column major order
   mX = [,] Mat.identity(4, 4)
   mY = [1, 1, 1, 0]
   mZ = [,] mX / mY
   mP = [,] [2, 4, 3 | 3, 1, 5] * [3, 10 | 4, 2 | 1, 7]
   mRows, mCols = m.size()
   mQ = [,] u’ # z is assigned transpose of matrix u


STRING TYPE
   myStr1 = "Hello"
   myStr2 = Str('Hi')
   str = AStr("This is an ascii string") # ASCII string
   myStr3 = 'Halo'
   str2 = Str


STRING INTERPOLATION
   name = 'Pluto'
   time = 2015
   tap = '[name] is a language started in [time]'
   tin = 'Hello #= Beautiful =# World'
   print("This is a number: ", 4)


STRING OPERATIONS
   'ab' + 'c' # = 'abc'
   'abc' * 2 # = 'abcabc'
   'abcabc' + 'ca' # = 'abbc'
   'abcabc' / 'c' # = ['ab', 'ab']
   ['ab', 'ab'] * 'c' # = 'abcab'


NON-STANDARD STRING LITERAL
   byteArr = ba"87004" # 8, 7, 0, 0, 4 repesent the actual byte to be placed in memory
   byteArr = bv"data\xff" # converts the values d, a, t, a, \xff into binary that fits in a byte
   myRegex = re"^(\w+)$"


ESCAPE SEQUENCE
- .[ .t .n ." .' .#
- \[ \t \n \" \' \# \. \\


MULTILINE STRINGS
   cap =
   "Hello "
   "World"


VERBATIM STRING
   '''Use \t for tab and \n for newline'''
   """Use \t for tab and \n for newline"""

CONTINUE ON NEXT line
   men = length == 0 ? 25 | 0
   mune = length == 1 ? \
      25 | 0
   meter = \
      getMeter()


IF SATEMENT
   if myMoney == 1_000_000:
      print("Yay! I'm rich!")
   ..
   if x == 3 : print('Hello') ..
   if x == 1 :
      print(x)
   elsif x == 2 :
      print(x)
   else :
      print('invalid value')
   ..
   if x : # if x does not equal nil or false
      print('x has been assigned to')
   ..


FOR LOOP
   for i thru [1:10]:
      if  i % 2 == 0 :
         print('[i] is an even number')
      else :
         next
   ..


LOOP
   loop :
      if x != 0 :
         print ('Hi')
      else :
         break
      ..
   ..


WHILE LOOP
   while myBool == true :
      print ('Hello ')
   ..


REPEAT WHILE LOOP
   repeat:
      print ("Hello ")
   while myBool == true


UNTIL LOOP # useful because you know the terminating condition
   until myBool == true:
      print("Hello ")
   ..


REPEAT UNTIL LOOP
   do: print ("Hello ") | until myBool


CONDITION LIST
   if myVar == a | == b & == c :
      print(myVar)
   ..
   if x == y == z :
      play()
   ..
   if "two-syllable word" == pit & == pot & == pet:
      print("That's wierd")
   ..
   # or better
   if pit and pot and pet == "two-syllable word":
      print("That's wierd")
   ..
   if "two-syllable word" == pit | == pot | == pet:
      print("That's wierd")
   # or better
   if pit or pot or pet == "two-syllable word":
      print("That's wierd")
   # 'and' and 'or' here are used in a different manner
   # than in Python
   if pit or (pot and pet) == "two-syllable word":
      print("That's wierd")
   ..


CONDITIONAL MULTIPLEX OPERATOR
   # single expression ternary operator
   myVar1 = myBool == true ? 5 | 6
   def divide(num, denom): rt denom == 0 ? nan | num / denom
   salary = (workYears > 5 ? 10_000 | 1_000) * rank # when conditional multiplex operator appears within an expression it must be bracketed


RANGE
   x, y, z = [1:3]
   for x thru [1:(20 - 1)]: print(x)


THRU & RANGE MULTIPLEX OPERATOR
   list([2:4])
   for x thru [1:20 - 1)]: print(x)
   y = x thru [1:30] :: x # this range multiplex operator a list of 1 to 30
   # same as
   y = [1:30]
   arr = (x thru [2:7] :: x) * 3 # when range multiplex operator appears within an expression it must be bracketed
   # same as
   arr = (x thru [2:7] :: x * 3)
   # same as
   arr = [1:30] * 3


WHERE
   arr = x thru [1:30] :: x * 3 => x % 2 == 0


COMPREHENSION LIST
   arr = x thru [1:30] :: x * 3 => x % 2 == 0


THRU/STEP
   for x thru [1:6] step 2:
      print(x)
   ..


IN
   x = 3
   if x in [1:10]:
      print(x)
   ..


NOT IN
   arr = x thru [1:30] :: x * 3 => x not in [2:5]


NIL CONDITION
   if let data = getValue() : # x is available only in the if branch
      print(data)
   else:
      print('can\'t get value')
   ..
   if let name = getChars() => name.characters.count in [4:15]:
      print ('hello')
   if x = getStr(): print(x) | else : print('x is nil')
   someone = person.getData().getAge() ? _ | printErr('someone is no one') # problematic if subject of op is a bool object
   # better
   someone = person.getData().getAge() == nil ? _ | printerr('someone is no one')
   # better still
   someone = person.getData().getAge() ?? printerr('someone is no one')

   penny = purse.change() ?? 0 # expression returns 0 if purse.change() returns nil
   myName = me.name ?? "Unknown"
   pay = (jobHours ?? 0) * 50 # when nil operator appears within an expression it must be bracketed


ONE-LINE BLOCK
   def addTwo(a, b :=  Int) Int:
      print (a + b)
      rt a + b
   ..
   def addThree(a, b, c :=  Int) Int: print (a + b + c) ; rt a + b + c
   if x == y
   if x == y : print(x)
   if x == y : print(x) | else print(y)


UNNAMED BLOCK
   block:
      m = a + b
      n = m + a + b
   ..
   # or
   do:
      m = a + b
      n = m + a + b
   ..
   # note that if do block immediately follows a function call
   # it will be interpreted as a anoymous fucntion


EXCLUSIVE BLOCK
   do x, y: # can only use x and y from the outer scope
      m = a + b
      n = m + a + b
   ..
   # note that if do block immediately follows a function call
   # it will be interpreted as a anonymous fucntion


LABELS
   [label: outer]
   for i thru [1:10]:
      for j thru range(10) :
         print('i : [i] j : [j]')
         if j == 5:
            next outer
         ..
      ..
   ..


SKIPPING BLOCKS
   [skip : 3]
   if x == 5 : print('Hello') # block is skipped after the it has been executed 3 times.


FUNCTION DEFINITION
   def add(a = Int, b = Int) Int:
      rt a + b
   ..

RETURNING A VALUE
   def add(a = Int, b = Int) Int:
      rt a + b
   ..


EXPRESSION LANGUAGE
# Pluto is an epression, the last expression in a block is always returned
    myBool = myName == "Nypro"
    def add(a, b): rt a + b
    # or
    def add(a, b): a + b
    # sometimes rt is needed to return an evaluation immediately
    # to prevent execution spilling back into parent block when not needed
    def hypot(x, y):
        x = abs(x)
        y = abs(y)
        if x > y:
            r = y/x
            rt x * sqrt(1 + r + r)
        ..
        if y == o:
            rt zero(x)
        r = x/y
        y * sqrt(1 + r + r)
    ..


GLOBAL FUNCTIONS
   # Pluto contains a lot of helpful global methods
   str = "Hello"
   length(str)
   typeMin(25)
   typeOf(Int)


LIST DECLARATION IN METHOD PARAMETER
   def add(a, b): a + b # params without types are nil by default unlike normal variables
   def add(a, b = Int): rt a + b # a is nil, b is Int
   def add(a, b :=  Int): rt a + b # both a and b are Int, :=  is left associative
   def add4(a, b := nil, c, d := Int) Int: # a and b are nil, c and d are Int
      rt a + b + c + d
   ..


CONSTANT PARAMETER
   # guarantees that the parameter won't be changed
   def add(let a, let b): c = a + b ; rt c
   # or
   def let add(a, b): c = a + b ; rt c
   # not just the params, local vars are also constant by default


ARGUMENT NAMING
   def addPerson(name = 'Aditya', age = 28)
   def sum(a, b = 1, c = 0):
      rt a + b + c
   ..
   # arg naming can be used to skip optional args
   sum(3, c = 6) # b skipped


COMPOUND METHODS
   def getValue():
      sticky x = 1, y = Int(2)
      def ():
         rt x + y
      ..
      def (a = Int):
         rt x + y + a
      ..
      def (a, b :=  Int):
         rt x + y + a + b
      ..
   ..


VARIADIC PARAMETERS
   def sum(first = Int, others = Int []):
      tmp = first + arr
      for x thru arr:
         tmp += x
      ..
      rt tmp
   ..
   # or better
   def sum(first = Int, others = Int []): rt first + others
   lion = sum(1, 2, 3, 4, 5, 6)

   def addEven(first = Int, others = Int []):
      sum = first._move
      sum += x thru others :: x => x == _even # idiomatic pluto :)
      sum
   ..
   dean = [1, 2, 3, 4, 5]
   jean = addEven(0, dean)
   joan = addEven(0, [1, 2, 3, 4, 5])
   jane = addEven(0, 1, 2, 3, 4, 5)
   def add(a = 3 []): rt sum(a) # conflicts with the function below
   def add(a, b, c): rt a + b + c # conflicts with the function above



MUTATIVE FUNCTIONS
   def add(x, y): a + b
   <T> def swap!(x, y := ref  T): x, y = y, x # use exclamtion mark for functions that can change values

   tip = add(2, 3)
   top = add(4, 5)
   swap!(tip, top)


UNOVERLOADABLE FUNCTIONS
   def add(args = [])
   <T> def add(args = [] T) T


RETURNING AN ARRAY
   def addThree (a, b, c :=  Int) 3 Int []:
      arr = [a + b, a + c, b + c]
      arr
   ..
   p, q, r= 1, 2, 3
   x, y, z= addThree(p, q, r)
   w= addThree(p, q, r)[1] + z

   def addSubTwo(a, b :=  Int) Int []:
      arr = [a + b, a - b]
      arr
   ..


RETURNING A TABLE
   def getDetails(u = User):
      rt name, age [.name, .age ]
   ..
   x = getUser()


RETURNING VARIABLES
   # check for pass table in notes
   def getReadOnly() []:
      rt read myList # unmodifiable after it has been returned
   ..
   def getVal():
      rt val myList
   ..
   def getRef():
      rt ref myList
   ..
   def getOwnership() [,]:
      rt array._move
   ..
   pat = val getVal() # redundant
   put = ref getRef() # redundant
   pit = read getReadOnly() # redundant
   cup = ref getVal() # returned value is moved
   cap = val getRef() # returned reference is copied
   cep = own getRef() # error, already has reference
   cip = iso getRef() # error, already has reference
   hola = read getVal() # returned value is moved, but cannot write


FUNCTION OBJECTS
   add2 = add
   add3 = Func{Int Int Int : Int}


CLOSURES
   def outer():
      a = 6
      rt def (b = Int) : a + b # a closure can access variables in outer scope
   ..
   add = outer
   # nameless closures (except those returned by a function or another closure) are executed at the
   # point they are declared
   # named closures on the other hand are not executed until they are called
   def add (x, y :=  Int):
      def (): rt x + y
   ..
   sum = Func
   sum = add
   tip = Func{Int Int > Bool}


PASSING FUNCTIONS AS ARGUMENT / ANONYMOUS FUNCTIONS
   def addThree(a, b, c, myFunc = Func{Int Int}):
      rt myFunc(a, b) + c
   ..
   addThree(1, 2, 3, def (a, b): a * b)
   # or
   addThree(1, 2, 3) do a, b: a * b

   def add(a, b): a + b
   addThree(1, 2, 3, add) # passing and already-declared function



ANONYMOUS TYPES
   def keyListener(e = Event): e.printText()
   keyListener(
      Event:
         def printText():
            print ('Hello, World')
         ..
      ..)


LAMBDAS
   def keyListener(e = Event): e.printText()
   keyListener(
      Event:
         def printText():
            print ('Hello, ')
         ..
      ..)
   keyListener(def (): print("World")) # lambda
   keyListener(rt print("World")) # shortened lambda using 'rt'
   myList.fold(0, def (a, b): a + b)
   myList.fold(0, rt a + b) # shortened lambda, rt must be included


COROUTINES
   # New Proposed Coroutine with Concurrency. Thanks to Go 03/08/16

   # Concurrent Coroutine
   def pinger(pipe p = String):
      loop:
         p <- "ping"

   def printer(n = Int):
      loop:
         msg = <- p
      print(msg)
      time.sleep(time.second * 1)
   ..
   def main():
      pipe p = String # pipe creation
      run pinger(p) # run pinger concurrently
      run printer(p) # run printer concurrently
      input = String
      scanln(input)
   ..
   doSth(from p = String) # can only send thru the channel
   doSth(to p = String) # can only recieve thru the channel

   # Sequential coroutine
    def coroutine():
        for x thru 1..10:
            yield x
    ..
    print(coroutine()) # 1
    print(coroutine()) # 2
    print(coroutine()) # 3
    coroutine.reset() # resets the coroutine
    list(coroutine()) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # Simuated sequential co-routine using sticky variables
    def addUp(a, b):
        sticky x
        if x == _init:
            rt x += b
        else:
            rt x = a + b
    ..
    print(addUp(3, 4))
    print(addUp(0, 5)) # gotcha! only the second argument is summed up.
    print(addUp(0, 6)) # gotcha! only the second argument is summed up.


EVENTS
   mathOps = Event{Float Float : Float}
   mathOps += add, subtract, divide
   mathOps -= divide
   buttonPressed = Event(createProject)
   buttonPressed += addNewEvent


TYPE DEFINITION
   type Car:
      name, model = Str
      def (name = Str):  # Constructor implicitly contains a first parameter of type Car
         self.name = name
      ..
      def (name, model = Str):
         self.name = name
         self.model = model
      ..
   ..


SELF REFERENCE
   type Car:
      name, model = Str
      def (name = Str):
         .name = name # the self can be ommitted leaving the dot and the field
      ..
      def (.name, .model)
   ..
   # this is also applicable to methods where its is the type of the first parameter
   def getDetails(car = Car): rt [.name, .model]
   def hasModel(car = Car, model = Str): .model == model


USING A FUNCTION AS METHOD
   def show(a = Person): print(.name)
   nigel = Person("Nigel Nicargua")
   def show(nigel)
   nigel.show() # using show funtion as a method since Person is the first argument
   def +(a = MyNum, b = Int): rt .value + b
   duke = MyNum(25)
   deck = +(duke, 20)
   duck = duke + 20


DESTRUCTORS
   type Car:
      name, model = Str
      def (.name)
      def (.name, .model)
      def (!) : # Destructor implicitly contains a first parameter of type Car
         print('Object Deleted!')
   ..


MODIFIERS IN CLASS
- No public modifer, members are all public by default
   priv a = 10
   pack b = 'HELLO'
   pass a = true # synon with protected
   prod let x = 5f # synon with internal
- proj(ect), prod(uction), prog(ram) clashes with prot(ected)

MODIFIERS CAN BE ON CLASSES AND METHODS Took
   def priv addPerson() # is accessible only within the module
   def pass getNumber() # is accessible within the module and to associated types
   type priv Company # is accessible only within the module
   def prod createSession() # is accessible only to production unit


PACKAGE ACCESS LEVEL
   pack< date = Date
   pack>> isbn = Long


READ-ONLY WRITE-ONLY ACCESS
   rpriv, rpack, rprod, rpub
   wpriv, wpack, wprod, wpub


MODIFIER BLOCK
   # modifier block is the only block in Pluto that may not be indented
   mod priv let :
   x = 4.5f
   y = 2.5f
   z = 0.0f
   ..
   # you can also chain modifier blocks together
   mod priv let:
   x = 4.5f
   y = 2.5f
   z = 0.0f
   mod pass:
   name= getName()
   age= getAge()
   ..
   mod :


MODIFIERS IN LIST DECLARATION
  priv let i, j = Int


PROPERTIES / GETTERS SETTERS
   myVar1 = def set(a, b, c :=  Int): _ = a * b * c | def get(): rt _
   myVar1 = (1, 2, 3)
   myVar2 :=
      def set(a, b :=  Int): _ = a * b * c
      def get(): rt _
   myVar2 = (1, 2)
   myVar3 = def set(a = Int): _ = a | def get(): rt _
   myVar3 = 1
   myVar4 = def set(a = Int) | get()
   myVar3 = 2
   tip = def get(): rt myVar3


TYPE CHECKING
   if myCar == Car._exact:
      print('Type is a Car')
   ..
   if myCar == Car._sub :
      print('Type is a sub-class of Car')
   ..
   if myCar == Car._super :
      print('Type is a super-class of Car')
   ..
   <T[Vehicle._sub]>
   type Transportation :
      myVehicle1 = T
      myVehicle2 = T
   ..


IMPORT / USING STATEMENT
Now module-based
   import pluto.io # imports all types and funtions in a module
   import pluto.io: Console # imports a type and its associated methods (where its the type of the first parameter) from a module
   import pluto.io: add(), subtract() # imports only add and subtract function from the module


TYPE ALIAS
   Int as Meter
   import marko.io: SimplifiedRegex as Regex


METHOD CHAINING
- Method chaining is automatic, no need to return self
   type Math:
      value = Float
   ..
   def add(a = Math, b, c :=  Float) Float:
      a.value = b + c
   ..
   def subtract(a = Math, b, c :=  Float) Float:
      a.value = b - c
   ..
   m = Math
   m.add(1, 2).subtract(3, 4)
   n = "This is the first string".&"This is another string".reverse().toUpper()


STICKY TYPES
   type sticky TempConv
   def convToFahr(a = TempConv, celsius = Float) Float
   def convToCelsius(a = TempConv, fahr = Float) Float


STICKY TYPES MEMBER
   type Person:
      name = Str
      age = Int
      sticky let race = 'Mongoloid'
      def (.name, .age)
   ..
   def sticky getRace(a = Person): .race


STICKY CONSTRUCTOR
   type sticky MyClass:
      x, y = Int
      def (): # they can't have parameters. They only initialise class fields at first use
         .x = 2
         .y = 3
      ..
   ..


STICKY LOCAL VARIABLES
  # sticky local variables are promoted to fields implicitly but can only be accessed in their
  # parent method.
  # I like sticky local variables because it brings variables closer to where they are needed
   def add(a = Int) Int:
      sticky sum = a # this variable will maintain its state whenever the function is called
      rt sum += a
   ..


HOLD VARIABLES IN LOOPS
   for x thru [1:50]:
      hold x = 1
      print(x * y)
      x++
   ..


INHERITANCE, COVARIANCE AND CONTRAVARIANCE
   type Person: name = String; age = Int; (.name, .age)
   def showDetails(person = Person): print("name: [.name], .age: [.age]")

   type Employee [Person]: job = String ; (.name, .age, .job)# Employee now inherits Person's field and associated methods
   def changeName(emp = Employee, name = Str): .name = name
   def changeName(emp = Employee, age = Str): .age = age
   def changejob(emp = Employee, job = Str): .job = job

   def main():
      jide = Employee('Jide Abass', 28, 'Clerk')
      # Covariance
      showDetails(jide) # prints "name: Jide Abass, age: 28"
      okoro = Person("Okoro Johnson", 37)
      # Contravariance
      okoro.changeJob("Manager") # error at .job
      okoro.changeName("Okoro Nwabuike") # ok, contravariance successful
      # Covariance
      library = MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   ..


INHERITANCE # Not Finalized!
   type Animal
   def move(a = Animal)

   type Bird [Animal]
   def move(a = Bird): print("Soar!") # overides move method for Animal, a super method
   def fly()

   type Horse [Animal]
   def move(a = Horse): print("Gallop!") # overides move method for Animal, a super method
   def gallop()

   type Pegasus [Bird, Horse] # inherits Bird and Horse classes
   def move(a = Pegasus): print("Soar and Gallop!") # overides move method because of CONFLICT in  Bird and Horse

   eagle = Bird()
   horse = Horse()
   pegasus = Pegasus()
   def move(eagle) # "Soar!"
   def move(horse) # "Gallop!"
   def move(pegasus) # "Soar and Gallop!"
   animals = Animal[Bird(), Horse(), Pegasus()]
   animals[1].move() # "Soar!"
   animals[2].move() # "Gallop!"
   animals[3].move() # "Soar and Gallop!"


SUPER METHODS AND SUB METHODS
   type Listener
   type ButtonListener [Listener]
   def respond(a = Listener) # this is a super method to the more specific method below
   def respond(a = ButtonListener): rt # this is a sub method to the method above


VIRTUAL METHODS
   def respond(a = Listener) # a method without a body is implicitly virtual and cannot be called
   def respond(a = ButtonListener) # error, a virtual super method can't be overriden by a virtual sub method


OVERRIDING METHODS
Pluto does not, currently, have an override keyword. Methods are overriden implicitly
This might cause some unexpected problems. Important super methods could be overiden without knowing
I'm going to look into the problem later
   def play(a = Player): .start()
   def play(a = DigitalPlayer): .startAt(0) # this play overrides its super method implicitly



ABSTRACT TYPES
   type abs Player # cannot be instantiated
   def play(a = Player)
   def rewind(a = Player)
   def fastForward(a = Player)

   type DigitalPlayer [Player]


DOWNCASTING ! Needs review
  # assuming Movie and Song extends MediaItem
   library = MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   for item thru library:
      if item === Song:
         print('Song: [song.name]')
      elsif item === Movie:
         print ('Movie: [movie.name]')
      ..
   ..


CONSTANT CLASS
   type let MyClass:
      x = 'is immutable'
      mut y = 'is mutable'
   ..


UNINHERITABLE CLASS
   type solo MyClass:
      x = 'Class Cannot Be Inherited'
   ..


GENERICS
   <T[Str|Int], U>
   type DataManager:
       T dataID
       U dataX
       U dataY
   ..
   object DataManager<Str, Car>

   <T[Integer]> type Ratio # means Integer and its subtypes
   chan : Ratio(3//2) # uses Integer
   chen : Ratio<UInt>(6//4)  # uses subtype UInt

   myMovies = List<own Movie>
   favoriteMovie = ref Movie

   <T> def add(a, b, c = T): a + b + c
   add<Int>(1, 2, 3)
   add(1f, 2f, 3f)
   add(2, 3, 4f) # error, mismatched types


ENUMS
   # can have the same name with a class in the same file
   # enums only have one unoverloadable constructor with a Symbol object param
   enum Days: MONDAY; TUESDAY; WEDNESDAY; THURSDAY; FRIDAY; SATURDAY; SUNDAY # elemental enum
   def todayIs(day = Days): # todayIs{SUNDAY}
      if day == MONDAY: print('today [day]') # today is MONDAY
      elsif day == TUESDAY: print('today is [day]') # today is TUESDAY
      elsif day == WEDNESDAY: print('today is [day]') # today is WEDNESDAY
      elsif day == THURSDAY: print('today is [day]') # today is THURSDAY
      elsif day == FRIDAY: print('today is [day]') # today is FRIDAY
      elsif day == SATURDAY: print('today is [day]') # today is SATURDAY
      elsif day == SUNDAY: print('today is [day]') # today is SUNDAY
   ..

   enum RealNum: decimal = re"\d|\d+\.\d+"; scientific = re"\d\.\d+e[\-\+*]\d" # case enum
   def checkNum(rn = RealNum): # checkNum{123.4e10}
      if rn == decimal: print('[rn.toStr()] is decimal')
      elsif rn == scientific: print('[rn.toStr()] is scientific')
   ..

   # accessing an elemental enum's element
   sym = Days[1] # SUNDAY is returned as a symbol

   # iterating thru enum
   for x thru Days:
      print(x)
   ..


REGEX
   x = Regex("\d+")
   x = re"\d+"


PATTERN MATCHING
   type User; type Account; type PayPal [Account]; type Bitcoin [Account]

   def test (name, acc): name === Str & acc === Account
   def pypl(acc): acc === PayPal ? acc | nil
   def btc(acc): acc === Bitcoin  acc | nil

   mary = User

   match mary :
      case test (mary.name, pypl (mary.account)): print ('[mary.name]: [mary.account]') # covariance in case matching
      case test (mary.name, btc (mary.account)): print ('[mary.name]: [mary.account]') # _ represent the value passed into eval block
   ..



EXPLICIT TYPE CASTING
   x = Int(5)
   y = Byte(6)
   let z = y + Int(y)


STACK EXPRESSION
   a = add (x, y) >>> subtract(_, z) # tmp represent the value passed from preceding method
   a = subtract(_, z) <<< add (x, y) # same as above


MOVE SEMANTICS
- Move feature is automated in Pluto in any place where it is possible.
- But you can still explicitly specify it.
   y = getPerson('Californio')._move


CONCURRENCY
- All singular (_var+) and associative (_var+=) operations on variables are atomic by default.
- In an assignment or initialisation operation. The whole expression is singularly atomic
- Variables are volatile by default
- And methods are sychronised by default


ATOMIC EXPRESSION
   lock: x = 5; y = x
   lock: if y == 5: print('y is 5')


ATOMIC BLOCKS
   lock block:
      x = 5
      y = x
   ..
   # or better
   lock:
      x = 5
      y = x
   ..
   lock if tip == top:
   print("Hello")
   print(" World!")
   ..


OPERATOR OVERLOADING
   # !! REVISION NEEDED
   _var++ ():
      value++
   ..
   _-var ():
      0 - value
   ..
   _var* (other = MyObj) MyObj:
      rt MyObj(.value * other.value)
   ..
   _var() (other = Int):
      value = other
   ..
   _type() (other = Int) MyObj:
      rt MyObj(other)
   ..
   _var[] (row = Int, col = Int) MyObj:
      rt my2DArr[row, col]
   ..
   _var=[] (args = Int []) MyObj:
      for x thru args:
         hold i = 1
         my1DArr[i] = x
      ..
   ..
   # Proposed
   def +(x, y): tmp;  tmp.value = x.value + y.value
   def ++!(): self.value++
   # others
   [A B C] # hcat()
   [A, B, C] # vcat()
   [A B; C D] # hvcat()
   A’ # ctranspose()
   [1:n] # thru()
   A[i] # getindex()
   A[i]=x # setindex!()
   A(x) # call()


TRY & ASSOCIATES
   def main():
      ensure:
         file.close()
      ..
      print("I'm about to open a text file and print its first 500 characters")
      file = File("C:/Users/Hello/hello.txt")
      try file.open().print([1:500])
      except(fnfe = FileNotFoundErr, ioobe = IndexOutOfBoundErr):
         if fnfe: printErr('Can\'t find file!')
         if ioobe: printErr('Out of index error!')
      ..
   ..

   try:
      file.open()
      file.write('Hello')
   except(fnfe = FileNotFoundErr):
      printErr('Can\'t find file!')
   ..

   try:
      raise Err()
   except(e = Err):
      printErr('Error!')
   ensure:
      file.close()
   ..

   try let x = getObject()
      print('x is nil')
   ..

   try:
      let x = getObject()
      raise NilErr()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   ..

   try:
      let x = getObject()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   ..

   try:
      file.open()
      let x = file.readLine()
   except(ne = NilErr):
      printErr('x can\'t be nil!')
   except(fnfe = FileNotFoundErr):
      printErr('Can\'t find file!')
   ensure:
      file.close()
   ..


ERR
Err stops application whenever it is evoked
   if num and den == 0:
      err DivideByZeroErr()
   ..


ASSERTION
   @assert(x == nil, "Hello")
   @assert(x == nil)


ITERATORS (?)


FLOATING POINT BITWISE OPERATORS (?)


HINTS
   @deprecated:
      msg: "MediaPlayer class should be used instead"
   @stub
   @if (platform: "Mac"): print("This is a Machintosh Computer") | @endif
   #------------------------------------
   @compiler # evaluated at compile-time
   @linker # evaluated at link-time
   @runtime # evaluated at runtime
   @if: [] # evaluated at compile, link and run time


COMPILER HINT
   @compiler:
      typing = "static"
      variable = "immutable"
      warn_me = {
         unimplemented_inherited_functions
         unimplemented_inherited_fields
         }
   ..


NON-STANDARD STRING LITERAL HINT
   myRegex = re"^(\w+)$"
   @strLiteral:
      re: {Regex(_str)}


METAVARS CONTEXT SPECIFIC ENVIRONMENT
   arr[_last] = 20
   if(x == _even)
   match camaro:
      case _.make == mustang.make: print("Make: [_.make]")
   ..
   sum = add(a, b) >>> add(_, x)
   tip = def set(a = Int): _ = 25 | def get(): rt _


LIST OF METAVARS
   _init # to check if sth is initialised
   _
   _last
   _even
   _odd
   _min
   _max


REFLECTION
   # dynmically determining which class to use
   @if (stage = "runtime", condition = "Main.useOldClass == true"): # ????
    type Class:
      value = def set(x Str): _ = x | def get(): rt _
      def (.value)
    ..
   @else
    type Class:
      str = def set(x Str): _ = x | def get(): _
      num = def set(x Float64): _ = x | def get(): _
      def (.str)
      def (.num)
    ..
   @endif


MACROS
   @macro subtract(a, b):
      a - b
   ..
   dune = @subtract(50, rune)


COMPLEX, QUATERNION DECLARATION
   x = 5 + 2i # complex
   y = 5 + 2i + 3j + 4k # quaternion


MATHEMATICAL EXPRESSION
    top = m{3x - 2y/5 + r(d^5)} # operator precedence still applies
    tip = m{3x y z^2} # when there is no operator between 2 operands, multiplication is assumed
    pat = m{4y - 2x(z^2) getSalary()} # you can use functions and variables directly
    pet = m{4d 5f} # MathExpr doesn't support numeric literals with type prefix. 4d and 5f here means 4 * d * 5 * f
    pot = m{5y [getSalary().round()] 3e-1 + [4d]} # for complex lang expressions you need to use []. 4d here means a Double literal


SYMBOL, EXPR, HOMOICONICITY & OTHER SYMBOLIC CLASSES
   # Symbol
   buck = {1}
   back = {1 2 3} # Symbol stores an array of string delimited by spaces
   beak = {"hello " [name]} # quotes allows spaces to be stored # interpolation is allowed as well
   bean = {hello {hi {halo}}} # can store nested words as well
   # Functions
   foo = Func{Int Int : Bool}
   # Expressions
   pet = Expr({call}, {+}, 1, ({call}, {*}, 2, 3))
   # or better
   pat = Expr{call, +, 1, {call, *, 2, 3}}
   exp = parse("1 + 2 + 3")
   ingrid = eval(exp)
   parse(pat)
   ma = m{3x - 2y/5 + r(d^5)}


CPLUSPLUS SYMBOL
   str = cpp{ void add(int a, int b) {return a + b;}}
   parse(str)
   sum = str.add
   brim = sum(1, 3)


NON-STANDARD SYMBOL LITERAL HINT
    str = cpp{ void main() {printf("Hello")}}
    @symLiteral:
        cpp= {Cpp(_str.toStr())}


NUMERIC CLASS
   x = UInt.max()
   y = Int32.min()
   z = m{2x + 4y/3}.round() + (24.25/4).floor()


RATIO CLASS RATIONAL NUMBERS
   xianghou = 2//3
   dean = x.toFloat() # rational format can be changed to fp
   bean = 4//6 ; print(y) # 2//3
   4//2 == 1//2 # true
   4//2 == 0.5 # true


RAW CLASS
   # bits stored in multiples of 8
   bits8 = Raw<8>
   bits16 = Raw<16>


INTEGER BITWISE OPERATORS
   myVar = 2.&2 # and
   myVar1 = 2.|2 # or
   myVar3 = ~2 # exclusive or


SHIFT OPERATORS
   myVar = 4<<1
   myVar = 2>>2


BINARY LITERALS
   myVar = 0b11001001


HEXADECIMAL LITERALS
   myVar = 0x5eff77


OCTAL LITERALS
   myVar = 0o56773


UTF-8 CHARACTERS
   char = '\u6E'


CLASSES OF OBJECTS
   Obj (0.7), Any (0.8)
   Func (0.7)
   Var (0.7)
   Arr (0.7)
   Tab (0.7)
   Exp (0.7), Expr(0.8.2)
   Nil (0.4), None (0.8.1)
   Symbol(0.7)


PREDEFINED TYPES # These types are optimized as part of the lang
   Int, Int16, Int32, Int64
   UInt, UInt16, UInt32, UInt64
   Float16(0.8.2), Float/Float32 (0.4), Float64/Double (0.6.1)
   Bool (0.4)
   Str (0.4), String (0.6.1), Str (0.8.1)
   Char
   Byte
   SByte
   Comp, Comp128
   Quat, Quat256
   Num (0.4) # redefined in 0.8.1 # (combines the features of BigInt, BigFloat)
   Ratio


NUMERIC LITERALS
   8
   64u64
   -255i16
   4089b
   1024sb
   512f
   0d
   123.0
   123.4
   123.4f
   123.4
   1.234e-2
   1.234e-2f
   .1 # 0.1
   1. # 1.0


LOGICAL vs BITWISE OPERATORS
   ! & |
   ~ .& .|


KEYWORDS
   stick (0.4) sticky  (0.6.1)
   # pub (0.4) public (0.6.1) pub
   priv (0.4) private (0.6.1) priv
   pro (0.4) protected (0.6.1) prot
   pack (0.4) package (0.6.1) pack
   pass (0.7.5)
   class (0.4)
   rt (0.7.2)
   # def (Rev 0.5.2)
   let (Rev 0.5.2)
   get (Rev 0.5.2)
   set (Rev 0.5.2)
   as (0.8)
   if
   else
   elsif
   while  (0.6.1)
   eval (Rev 0.5.2) match (0.8.1)
   for
   do
   until (0.6.1)
   next (0.6.1)
   break
   label (0.7.0)
   # fixed
   thru (0.8)
   in(0.7.2)
   skip(0.8)
   ensure (0.8)
   try
   except
   self
   mut (0.8)
   nan (0.8)
   nil
   def (0.8.2)


OPERATORS
   +
   -
   *
   /
   // # for ratios
   ^
   %
   --
   ++
   =
   +=
   -=
   *=
   /=
   //=
   ^=
   %=
   ==
   !=
   ===
   !===
   !
   >
   <
   >=
   <=
   &
   |
   ~
   .|
   .&
   >>
   <<
-   '
   .=


SYNTACTIC SYMBOLS
   |
   *
   ~
   @
   .
   :

---------------! NOTES !------------------------
VARIABLE BINDING
- Variables can only be bound to a type once.
- Unlike Julia or Python, a variable can't be associated with more than one concrete type through out its life time
   pat
   pat = 25
   pat = "Hello" # error! pat already bound to Int32


CONDITIONALS
- Value
- nil or not
- True or false


ITERABLES
- Coroutines
- Functions
- Range
- Array objects
- Table objects
- Iterable SubClasses
- String
- Enums


SUBJECT OF OPERATIONS
# is signified by '_'
- Stack
- Match
- Properties


AUTOMATIC REFERENCE COUNTING
- There can only be one strong ref to an object
   type Skeleton:
      bones List<own Bone> # bones contain a list of strong Refs to Bone objects
   ..
   type Bone:
      skel Skeleton
   ..


DECLARATIVE PLUTO ".deplu" #27/06/16
   person:[
      name : "Nypro"
      fat : false
      tall : true
      hobby : 'programming'
      single : _ # underscore as a value signifies empty
      children : [2, 3, 4, 6]
      coord : [x : 5]
      coords : [x : 1, y : 2, z : 3]
      gamesLiked : name, releaseDate, hard [
         ["Crysis", 2007, _],
         ["Unreal Tournament", 1999, true],
         ["Portal 2", 2011, true],
      ]
   ]


DUCK TYPING EXAMPLES
   c
   a = 25
   b = [1, 2, 3, 4, 5] # array
   c = [1, 2, 3 | 4, 5, 6] # multi dimen array
   d = ['Hello', 25, 1.3f, 'Hi'] # table
   def getArea(length, breadth):
      length * breadth
   ..
   length = 10
   breadth = 25
   rectangleArea = getArea(length, breadth)


NESTED ASSIGNMENT
- Pluto does not support nested assignments.
   tip = 5
   tap = (tip *= 5)


NIL VARIABLES
- Access to nil variables should be caught at compile time.
- Run-time ones are also caught, NilErr
   x
   print(x) # raises NilErr
   print(x ?? "Error! x is nil")


PASS TABLE
#=
   Types                              |   Passed Around By
   ----------------------------------------------------------
   Built-in Ind Types /  Value Types  |   val
   Arr Types                          |   ref
   Func Types                         |   ref
   Custom Types                       |   ref
=#


VARIABLE VS PARAMETER
- Variable declaration is nothing like parameter declaration


COMPILER WARNINGS
- When assigning to variables in other modules


COMPILATION
- '_' is compiled as a placeholder. This will be replaced at run time by a subject of operation
- some symbolic classes are evaluated at compile-time, e.g Func, MathExpr


PUNCTUATION
- Pluto needs proper use of indentations and newline to compile successfully
- This makes code reformatable to original when copied with newlines stripped.
- Pluto only supports 4-space identation
