# 20/10/16
RUNTIME STRUCTURE
Stacked
    Stack{
        Register{
            locals,
            constants,
            funcs
        }
    }
Heaped
    Globals{
        globalObjects,
        outerObjects
    }
    FuncMap::Map{
        index,
        vectorOfFunctions
    }
    Function{
        numberOfArgs,
        vectorOfObjects,
        vectorOfAttachedFunctions
    }
    TypeMap::Map{
        index,
        size,
        vectorOfParentTypes
    }
    Instructions1{
        programPositionIndex,
        vectorOfInstructions
    }


FUNCTION LOADING
- globals
- locals
- constants
- outers

ANY
-

PRIMITIVES
- bool
- int, i8, i16, i32, i64, uint, u8, u16, u32, u64
- f32, f64

BASE OBJECTS
- buffers (iso)
- maps
- hashes
- strings -> type + ascii_flag, byte_size, cp_length, UTF-8
- chars -> type + ascii_flag, byte_size, UTF-32
- primitiveObject
- complexObject

TYPE FIELD
- unsigned 32-bit
- Primitive - [R(Type) 1()]
    1(Object|Value) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(Primitive)
- Complex - [R(Type) 1()]
    1(Object) 1(Dynamic) 1(Strict|Covariant) 1(Nil|Valued) 3(Complex)
- Map - [R(Type) 1()]
    1(Object) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(Complex)
- Hash - [R(Type) 1()]
    1(Object) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(PrimitiveHash|ComplexHash|HybridHash)
- Buffer - [R(Type) 1()]
    1(Object) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(PrimitiveBuffer|ComplexBuffer)
- Str - [R(Type) 1(Ascii|Unicode)]
    1(Object) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(Complex)
- Chars - [R(Type) 1(Ascii|Unicode)]
    1(Object) 1(Dynamic) 1(Strict|Covariant)  1(Nil|Valued) 3(Complex)

STRUCTURES
-

THREAD STACK SIZES
- Stack_1 -> 2Kb
- Stack_2 -> 4Kb
- Stack_3 -> 12Kb
- Stack_4 -> 48Kb
- Stack_5 -> 240Kb
- Stack_6 -> 480Kb
- Stack_7 -> 1.44Mb
- Stack_8 -> 5.76Mb
- Stack_9 -> 28.8Mb
- Stack_10 -> 57.6Mb


FUTURE OPTIMISATIONS
- Allocating and managing heap buckets
- Tail call optimizations
    func fac(n):
        if n < 2: rt 1
        else: n * fac(n-1)
    ..
    # ITERATION
    func fac(n):
        label top:
        var acc = 1
        if n < 2: rt acc
        acc = n * acc
        n = n - 1
        next top # for expressiveness only. next only works for loops.
    ..
    # -----------------
    func foo(a, b):
        if b == 1: rt a
        else: rt foo(a * a + a, b)
    ..
    # ITERATION
    func foo(a, b):
        label top:
        if b == 1: rt a
        else:
            a = a * a + a
            b = b - 1
            next top # for expressiveness only. next only works for loops.
        ..
    ..

- Making fibers and threads work together
