Revised 02/10/16
# 0.0.83
#=
Major Change:

=#

PLUTO's DESIGN PHILOSOPHY
- let it do more with less
- make it fast
- make it legible
- make it consistent
- make it flexible (dynamic and static)
- make it lightweight

DESCRIPTION
Pluto is an interpreted language that supports optional typing without sacrificing performance as a result.
Pluto supports both object-oriented and procedural programming. This is in part achieved by closely associating types with multiple dispatch in functions.
Some of Pluto's features include list comprehenshion, generics, closure, lambdas, mutiple dispatch


--! THE EXAMPLES BELOW ARE MOSTLY STATICALLY TYPED !--
SINGLE-LINE COMMENTS
   # Hello


MULTILINE COMMENTS
    #=
    I'm Pluto
    I'm cool
    =#
    # Pluto will support nested multiline comments :)


DOCUMENTATION
   ## <code> Car </code>  class is deprecated # xml
   ##= [ code: 'Car' ] class is deprecated # deplu
   =##

VARIABLE DECLARATION & INITIALIZATION
    # Unlike Python, Pluto requires explicit variable declaration before usage
    var x # is a mutable
    let y # is a constant
    func add(a, b): rt a + b # function parameters are implicitly mutable
    func swap!(var a, var b): a, b = [b, a] # error! var should not be explicitly specified in their declaration
    var e ; e = Car('Camaro') # semi-colon is used to separate statements
    var y = 12f
    var z = 'Hello'
    var a =: Car('Camaro')
    var b = Car('Camaro').setDate(2014)
    var n = getCar('Camaro')
    var o = add(2, 4)
    var p = List{Car}(3) # generics


FUNCTION DEFINITION (1)
    func add(a, b):
        rt a + b


EXPRESSION-ORIENTED
    # Pluto is an expression-based language. If an expression evaluates to something, it is returned
    let myBool = myName == "Nypro"
    func add(a, b): a + b
    # sometimes rt is needed to return an evaluation immediately
    # to prevent execution spilling back into parent block when not needed
    func compare(x, y):
        if x == y:
            rt 0
        if x > y:
            rt 1
        -1
    ..


SPECIFYING TYPES
    var p = Person("Bradley") # loosely-bound assignment, variable can be assigned to another type later.
    var p = Person # error! You can't do strict binding with '=' operator
    var p =: Person # Strictly bound to Person and Person's subtypes.
    var p :: Person # Strictly bound to Person only.
    var a =: Int[] # The container can only be populated with instances of Int or its subtype.
    var b :: Int[] # The container can only be populated with instances of Int.
    let d = "Hello, world!" # loosely-bound variables can also be constant, even though they are promoted to Strictly
    var r = 25; r =: 0.3 # error! loosely-bound variables cannot be changed later to strict variables and vice-versa


OPTIONAL TYPE DECLARATION
    var myNumber :: Str|Int
    var myNumber = '01000999'
    var myNumber = 23


VARIABLES AND REFERENCES
    # Value types such as Int, FLoat, etc. are passed around by value, reference and container types are passed
    # around by reference
    # see pass table below
    var pat :: ref getObject() # pat holds strong ref to the object returned
    var pet :: wref pet # pet holds weak ref to the object returned
    var pet = iso getObject() # pet exclusively refers to the object returned (if it is a value object)
    let put =: val pet # assigned by value
    var pot =: read pat # read is a type of ref that allow reading only from referenced object
    # side effect of read:
    # if later in the future a variable is changed to read, it will lead to having to change code that have assigned to it, which can be a lot. :'(
    let pit :: val put
    func subtract(let a let b let c =: ref):
        c = a - b
        rt ref c
    ..
    var dean = val subtract(x, y) # gets a copy
    let cop = subtract(x, y) # gets a ref
    func add(a b = ref):
        rt val a + b
    let alm = ref add(val x, val y) # warning, return a val to a ref
    swap!(val a, val b)
    var x = ref iso getName() # error!
    var y = val wref getName() # ok, y gets a weak ref of name.


CHAINED DECLARATION
    var x = 5, y = 6 # Must be of the same type
    var x, y :: [1, 2]
    x, y = y, x # Swap operation
    let a, b, c, d = ,,[:4]
    var x =: Array -> [1, 2, 3, 4], y =: Array


CHAINED ASSIGNMENT
    # Covariant assignment
    var person =: Person = Artist("Dan", 21, "Painter")
    # Type casting
    var num =: MyNumber = 25.34f
    # Its is advised to always bracket expressions with more than one assignment operator
    # _setList() call
    let list =: List = (MyList = [1, 2, 3])
    # Anonymous object
    func divideAList(num :: Int):
        (MyList = [1, 2, 3, 4]) /= num
    var x =: y =: 5 pass


NUMERIC LITERALS
    var d = 2_u # UInt64
    var x = 1_000_000 # Int64
    var z = 0.1 # FLoat64


ACCESS MODIFIERS
    # No public modifer, members are all public by default
    var priv a = 10 # accessible only within the module
    var pack b :: 'HELLO' # accessible within the file level
    var pass c =: true # synon with Java's protected
    var prod d :: 5f # synon with C#'s internal # I'm contemplating on its removal
    # access modifiers can be used with types and functions too
    func pack addPerson()
    func pass getNumber()
    type priv Company
    type prod Artist <: Person


READ-ONLY WRITE-ONLY ACCESS MODIFIERS
    rpriv, rpass, rpack, rprod # rpub and wpub useless
    wpriv, wpass, wpack, wprod


ACCESS MODIFIER BLOCK
    # modifier block is the only block in Pluto that may not be indented and it doesn't create a scope
	mod let priv:
		x = 4.5
		y :: 2.5
		z = 0.0
	..
	# you can also chain modifier blocks together
	mod let priv:
		x = 4.5
		y = 2.5
		z = 0.0
	mod pass:
		name = getName()
		age = getAge()
	..


TUPLES
    var x, y = 5, 6
    let d = [getTuple()] # packing a tuple
    let arr = [for x thru [1:10]: 5x] # packing a generator
    var tup = ,,getList() # unpacking a list
    var tep = ,,generate() # unpacking a generator
    let prop =
        get(): prop
        set(a, b): prop = a * b
    prop = 1, 2
    x, prop = 1, (2, 3)

LISTS
   var fin = Car[('Camaro'), ('Mustang')]
   var fan =: [Car('Camaro'), Bike('Ducati')]
   var gin = 3 Car[] ; var gin = Car[('Camaro'), ('Mustang'), ('Maserrati')]
   var tin =: 3 [Car('Camaro'), Car('Mustang'), Car('Maserrati')]
   let ted :: [1, 2, 3, 4, 5]
   var top = ted
   var go =: 5 Vehicle[Car("Camaro"), SuperBike("Ducati Multistrada"), Plane("Boeing 747")] # covariance in container
   var go[1] = Car("Camaro")
   var go[2:] = Car[('Mustang'), ('Maserrati')] # starts filling from index 2

   var pot = Array
   # or better
   var pot = []

   var pit = Array{Int, 3} # an Int array with the size of three
   # or better
   var pit = 3 Int []

   # Immutable List Content
   let array = 5 Int [1, 2, 3, 4, 5] # List can't grow, content can't change
   var list = 5 Int [1, 2, 3, 4, 5] # List can grow, content can change

   var pet = [5] # this is an array with one element, 5
   let put = 5 []
   let four = 4
   let pat = four Int [1, 2, 3, 4]

   let pat.foldleft(0, func (a, b): rt a + b) # (((0 + 1) + 2) + 3) + 4 = 10
   var mat = getArray()
   var net = getArray() # error, array not exposed, so '[]' must be used
   var dean = Array
   var dean = [10, 8, 6 ,4, 2]


MULTIDIMENSIONAL LIST
    var arr2D = [,]
    var arr3D = [,,]
    var arr = 2*2 [[1, 2] [3, 4]]
    var d = Map{Int, Str}; #= or =# var x = Int:Str [,]
    println(arr[:])
    println(arr[2,:]) # print columns in row 2
    println(arr[:,2]) # print rows in col 2
    var arr = [1, 2] # vcat
    # 1 2
    var arr = [[1, 2] [3, 4]] # vhcat
    # 1 2
    # 3 4
    var arr = [1 2] # hcat # might change the to just vhcat
    # 1
    # 2
    var arr = [[1 2] [3 4]] # hvcat # might change the to just vcat and vhcat
    # 1 3
    # 2 4


DICTIONARIES
    var dict3D = [
        people :[
            tony: [4, 5, 6]
            brad: [1, 2, 3]
        ]
        animals:[
            bingo: [1, 5, 6]
            servo: [3, 6, 9]
        ]
    ]
    dict3D[people, tony, 1] = 5
    dict3D[people, tony] = [1, 2, 3]
    for kind, name, number thru dict3D:
        print("[kind]: [name]: [number], ")


LIST ACCESS
   var array :: [1, 2, 3, 4, 5, 6]
   var view =: array[1:4] # view becomes a generator to array
   var slice =: val array[1:4] # slice gets a copy of the array's content.
   println(array[1:2:6]) # first index to the third, while skiping every second index
   print(array[:5]) # first index to the 5th index
   println(array[3:-1]) # 3rd index to the last
   println(array[-3:]) # from the 3rd index starting from the back
   var newArray = array[:] # all elements
   println(array[-1:]) # print from behind


MATRIX-VECTOR OPERATIONS # column major order
    var mP = 2*3 [2, 4, 3 | 3, 1, 5] * [3, 10 | 4, 2 | 1, 7]
    var mX =: Mat.identity(2, 2)
    var mY = 2*4 Int [ # might change the to just vhcat
        [1 1 1 0]
        [0 1 1 1]
    ]

    let mZ :: mX / mY
    var mRows, mCols = mZ.dimen()
    let mQ = mXâ€™ # z is assigned transpose of matrix u


VECTORIZATION AND ARRAYS
    # Element-wise operations
    var mA =: [[2, 4, 3] [3, 1, 5]]
    var mB =: [[3 10] [4 2] [1 7]]
    var mC = mA .* mB # element-wise multiplication
    let mD =: mA ./ mB ./ mC


STRING TYPE
   var myStr1 = "Hello"
   var myStr2 = Str('Hi')
   var str =: AStr("This is an ascii string") # ASCII string
   var myStr3 = 'Halo'
   var str2 =: Str
   let length = "Hello".len()


STRING INTERPOLATION
   var name = 'Pluto'
   var time =: 2015
   var msg =: '[name] is a language started in [time]'
   var hello = 'Hello #= Beautiful =# World'
   println("This is a number: ", 4)


STRING OPERATIONS PROPOSAL
   var apple = 'ab' + 'c' # = 'abc'
   var mango = 'abc' * 2 # = 'abcabc'
   var grape = 'abcabc' - 'ca' # = 'abbc'
   var guava = 'abcabc' / 'c' # = ['ab', 'ab']
   var peach = ['ab', 'ab'] * 'c' # = 'abcab'


NON-STANDARD STRING LITERAL
   let byteArr = ba"87004" # 8, 7, 0, 0, 4 represent the actual byte to be placed in memory
   var byteArr = bv"data\xff" # converts the values d, a, t, a, \xff into binary that fits in a byte
   let specVersion = ver"0.8.2"
   let hex =: x'efa039'


ESCAPE SEQUENCE
- \[ \t \n \"" \'' \# \. \\



MULTILINE STRINGS
    let greeting =: "Hello,"
        " world!"


VERBATIM STRING
    '''Use \t for tab and \n for newline'''
    """Use \t for tab and \n for newline"""


MULTILINE EXPRESSIONS
    # expressions that are not naturally enclosed like arrays or function calls can be continued
    # on separate lines by enclosing the whole expression in a bracket
    # or by ending each line with a backslash before continuing the expression on the next line.
    var yay = (2 * (a / 2)
        + b)
    # or
    let mune = length == 1 ? 25 \
        || 0

SANDWICHED STATEMENTS
    # sometimes one would want to write a series of statement where it is not expected.
    # In such case, the list of statements can be encapsulated in a bracket.
    func clean(input =: Str): input.filter do x : var sticky y; y != x ? (y = x; true) || false # idiomatic


IF SATEMENT
    if myMoney == 1_000_000:
        println("Yay! I'm rich!")
    ..
    if x == 3 : println('Hello') ..
    if x == 1 :
        println(x)
    elsif x == 2 :
        println(x)
    else :
        println('invalid value')
    ..
    if x == 3 where y == 2 & z == 1: println("I rock!")
    if x: # if x is not nil or false
        println('x has a value')
    ..
    if x != nil: # if x is not nil
        println('x has a value')
    ..
    if x =: getX()~ != nil: println("x is not nil")  # if variables are implicitly mutable
    if !let x =: getX()~: println("x is nil")
    if let mySalary = getSalary()~, let myAllowance = getAllowance()~: letsParty()


CHAINED CONDITION (Oh My!)
    # 'and' and 'or' here are used in a different manner
    # than in Python
    if x < y & y < z:.. # notice!
    if x < y < z:..

    if x == y & y == z:.. # notice!
    if x and y == z:..
    if x == y == z:..

    if x == y & y < z:.. # notice!
    if x == y and < z:..

    if x == y & a == b:.. # good. unique operands


FOR LOOP
    for i thru [1:10]: # for variables are implicitly hold and always mutable
        if  i % 2 == 0 :
            println('[i] is an even number')
        else :
            next
    ..
    let interestingNumbers = [
        Prime: [2, 3, 5, 7, 11, 13]
        Fibonacci: [1, 1, 2, 3, 5, 8]
        Square: [1, 4, 9, 16, 25, 36]
    ]
    var largest
    for x, y thru interestingNumbers:
            if y > largest: largest = y
    println(largest)

    # Nested for loop
    for x thru [1:10]:
        for y thru [1:10]:
            println('x: [x], y: [y]')
    # Better way
    for x thru [1:10] for y thru [1:10]:
        println('x: [x], y: [y]')
    # Parallel for loop
    for x, y thru [1:10], [10:1]:
        println('x: [x], y: [y]')

NO BREAK
    for x thru list:
        if x < y:
            break
    nobreak:
        return y
    return -1


GENERATORS, LIST AND TUPLES
    # for loops are generatrs and their results does not create a list or a tuple
    var x = for i thru [1:10]: 4i # error! # in the furture the variable becomes a a generator holding the operation
    var x = [for i thru [1:10]: 4i] # creates an array from the generator
    var x = ,,for i thru [1:10]: 4i # creates a tuple from the generator


HOLD VARIABLES IN LOOPS
    for x thru [1:50]:
        var hold x = 1
        println(x * y)
        x++
    ..
    func recursive(y):
        var hold x = 24 # You can use hold variables in recursive functions too
        if y < 0: println(y)
        else: recursive(x - y)
    ..


LOOP
   loop :
      if x != 0 :
         print ('Hi')
      else :
         break
      ..
   ..


WHILE LOOP
   while myBool == true :
      print ('Hello ')
   ..


REPEAT WHILE LOOP
   repeat:
      print ("Hello ")
   while myBool == true


UNTIL LOOP # useful because you know the terminating condition but I might remove it tho (??)
   until myBool == true:
      println("Hello ")
   ..


REPEAT UNTIL LOOP
   repeat: print ("Hello ") \\ until myBool


CONDITIONAL/TERNARY OPERATOR
    # ternary operator
    var myVar1 = myBool == true ? 5 || 6
    func divide(num, denom): rt denom == 0 ? nan || num / denom
    var salary = (workYears > 5 ? 10_000 || 1_000) * rank # when conditional ternary expression appears
    # within another expression, it must be bracketed
    # conditional operator
    var state = isSick == true
    if isSick == true : println("go to the doctor") # error! redundancy
    func clean(input =: Str): input.filter do x : var sticky y; y != x ? (y = x; true) || false # idiomatic


RANGE
   let x, y, z = [1:3]
   for x thru [1:(20 - 1)]: println(x)
   let x = ['a':'z'].append(['A':'Z'])


THRU
   for x thru [1:20 - 1)]: println(x)
   var y = [for x thru [1:30]: -2x] # a for comprehension that returns a list of 1 to 30 same as
   var y = [1:30]
   # sometimes u need to access just a field in each element of a list
   var d = [thru attendanceList.name]


WHERE
   if p.age == 20 where p.name == "Allen": p # not really useful here
   # same as
   if p.age == 20 & p.name == "Allen": p
   for x, y thru books for a thru x where a.startsWith("The"): x # chained where


FOR COMPREHENSION
   var list = for x thru [1:30] where x % 2 == 0: x * 3
   for x, y thru books for a thru x where a.startsWith("The"): x
   var array = [for x thru [1:10]: 3x]

STEP
    # Used with iterables that have step method
    for x thru [1:2:9]: # 1, 3, 5, 7, 9
        println(x)
    ..


IN
    var x = 3
    if x in [1:10]:
        println(x)
    ..


NOT IN
    var arr = for x thru [1:30] where x not in [2:5]: x * 3


NIL STATE AND OPERATOR
    # There are two states an object can have, valued state or nil state. An object with valued state can
    # contain primitive values or other objects, but an object with a nil state only has nil.
    var name = nil # flexible variable initialised to nil
    var state =: Str # covariant variable uncreated
    let name =: Str.nil # covariant variable explicitly initialised to nil
    var penny = purse.change() ~ 0 # This expression returns 0 if returned value from purse.change() is in a nil object
    var pay = (jobHours~0) * 50 # when nil operator appears within an expression it should be bracketed
    let balance = remote.(account~Account("Empty")).getBalance() # Needs to be handled if returned nil is not of a particular object
    let balance = remote.getAccount('Barney') ~ println('Hello') # when nil is returned, a msg is printed, but since print returns nothing, the nil is retained.
    var z = game() ~ rt 'Bad' # this return from the function


ONE-LINE BLOCK
   func addTwo(a b =: Int)=:Int:
      print (a + b)
      rt a + b
   ..
   func addThree(a b c =: Int): print (a + b + c) ; rt a + b + c
   if x == y
   if x == y: println(x)
   if x == y: println(x) \\ else : println(y)
   if state == "Play": play() \\ if state == "Stop": stop()


NAMELESS BLOCK
   func doSth():
       var x, y, z = [1, 2, 3]
       use x, y: # can only access x znd y
           println("[x] : [y]")
   ..
   func doSth():
       var x, y, z = [1, 2, 3]
       use: # cannot access variabes from outer scope
           println("[x] : [y]") # error!
   ..
   func doSth():
       var x, y, z :: [1, 2, 3]
       func(): # can only access any variable from outer scopes
           println("[x] : [y]") # error!
   ..


LABELS
   [label: outer]
   for i thru [1:10]:
      for j thru range(10) :
         println('i : [i] j : [j]')
         if j == 5:
            next outer
         ..
      ..
   ..


SKIPPING BLOCKS
   [skip : 3]
   if x == 5 : println('Hello') # block is skipped after the it has been executed 3 times.


FUNCTION DEFINITION (2)
   func add(a =: Int, b =: Int)=:Int: # a return type can be specified after the parameer bracket
      rt a + b
   ..
   # a parameter can have default value. Before nko
   func add(a :: 0, b :: 0)=:Int:
      rt a + b
   ..


RETURNING A VALUE
   func add(a =: Int, b =: Int)=:Int:
      rt a + b
   ..
   func add(a =: Int, b =: Int)::Int: rt a + b


STICKY LOCAL VARIABLES
  # I like sticky local variables because it brings variables closer to where they are needed
   func add(a =: Int)=:Int:
      sticky sum = a # this variable will maintain its state whenever add function is called
      rt sum += a
   ..


USEFUL FUNCTIONS
    # Pluto comes with some helpful global methods
    var str = "Hello"
    len(str)
    typeMin(25)
    typeOf(Int)
    enumerate()
        for i, color thru enumerate(colors):
            println(i, color)
    reversed()


HIDDEN VARIABLES
    var gl = 5
    func doSomething():
        var gl = 5
        outer.gl = 'Hi'
        println(outer.gl)
    ..


CHAINED DECLARATION IN FUNCTION PARAMETER
   func add(a, b): a + b # parameters a and b are deferred-inferred, their types will be inferred when they are called.
   func add(a, b :: Int): rt a + b # a is deferred-inferred, b is Int
   func add(a b =: Int): rt a + b # both a and b are Int, = is left associative here
   func add4(a b, c d =: Int)=:Int: # a and b are deferred-inferred, c and d are Int
      rt a + b + c + d
   ..


CONSTANT PARAMETER
    # function parameters are mutable by default, but they can be made immutable by specifying let
    func add(let a, let b): let c = a + b ; rt c


ARGUMENT NAMING
   func addPerson(name :: 'Aditya', age = 28)
   func sum(a, b :: 1, c = 0):
      rt a + b + c
   ..
   # arg naming can be used to skip optional args
   sum(3, c = 6) # b skipped


VARIADIC PARAMETERS
   func ben(args =: Int []):
      printl('Array!')
   ..
   func ben(args =: Int...):
      printl('Varargs!')
   ..
   ben([4, 5, 6]) # Array!
   ben(4, 5, 6) # Varargs!
   func ben(a, b, c):.. # Function conflicts with varargs


MUTATIVE FUNCTIONS
    func add(x, y): a + b
    func swap!<T>(x y =: ref T): x, y = y, x # use exclamation mark for functions
    # that can mutate objects passed to them
    var tip = add(2, 3)
    var top = add(4, 5)
    swap!(tip, top)


UNOVERLOADABLE FUNCTIONS
   func add(args = [])
   func add<T>(args =: T[])=:T


RETURNING AN ARRAY
   func addThree (a b c =: Int) 3 Int []:
      a + b, a + c, b + c
   p, q, r =: [1, 2, 3]
   x, y, z = addThree(p, q, r)
   w = addThree(p, q, r)[1] + z

   func addSubTwo(a b =: Int)::Int []: [a + b, a - b]


RETURNING A TUPLE
   func getDetails(u =: User):
      rt self.name, self.age
   ..
   var x = getDetails() # the headers can be respecified


RETURNING VARIABLES
   # check for pass table in notes
   func getReadOnly() []:
      rt read myList # unmodifiable after it has been returned
   ..
   func getVal():
      rt val myList
   ..
   func getRef():
      rt ref myList
   ..
   func getOwnership() [|]:
      rt array
   ..
   var pat =: val getVal() # redundant
   var put :: ref getRef() # redundant
   var pit :: read getReadOnly() # redundant
   let cup =: ref getVal() # returned value is moved
   let cap =: val getRef() # returned reference is copied
   var cep =: wref getRef() # error, already has reference
   var cip = iso getRef() # error, already has reference
   var hola = read getVal() # returned value is moved, but cannot write


FUNCTION OBJECTS
    func add(a, b): rt a + b
    var add2 = add
    var add3 =: Func
    var add =: func(Str, Int)::Int
    func solve(a, b, c =: func(Int Int)=:Int ): c(a, b)
    var new = func(a b =: Int): rt a + b


EVENTS
    func add(a, b): a + b
    add += subtract, divide, multiply
    add -= multiply
    var xeno = add(1, 5) # normal function call
    emit add(1, 3) # use emit keyword to event call a function


CLOSURES
   func outer():
      var a = 6
      rt func (b =: Int) : a + b # a closure can access variables in outer scope
   ..
   var add = outer
   # nameless closures (except those returned by a function or another closure) are executed at the
   # point they are declared
   # named closures on the other hand are not executed until they are called
   func add (x y =: Int):
      func (): rt x + y
   ..
   var sum =: Func
   var sum = add
   var foo =: func(Int, Int)


FUNCTION AS ARGUMENTS
   func addThree(a, b, c, foo =: func(Int, Int)):
      rt myFunc(a, b) + c
   ..
   addThree(1, 2, 3, func (a, b): a * b)
   # or
   addThree(1, 2, 3) do a, b: a * b

   func add(a, b): a + b
   addThree(1, 2, 3, add) # passing and already-declared function

   numberList.filter() do x: pivot > x # if a function has no argument, you can omit the brackets before the do statement
   numberList.filter do x: pivot > x


ANONYMOUS OBJECTS/TYPES
    type <: Thread(
        func start():
            println("This is a thread")
    ).start()

    type <: Person(
        func save(name):
            self.name = name
            println('Hello [self.name]')
        ..
        func delete():
            self.name = ""
    )


LAMBDAS
    keyListener(func(): println("World")) # lambda
    keyListener(: println("World")) # shortened lambda using 'rt'
    arr.filter(func(a): pivot > a) # anonymous functions
    arr.filter do a: pivot > a # function argument
    arr.filter(: pivot > [1]) # lambda
    let reversed = sort(names, : [1] > [2] )


MATCH FUNCTION
    match check30DayMonth(month = Month):
       when self.value == 4 : println("This is April, a 30-day Month!")
       when self.value == 6 : println("This is June, a 30-day Month!")
       case self.value == 9 : println("This is September, a 30-day Month!")
       else self.value == 11 : println("This is November, a 30-day Month!")
       println("Not a 30-day Month!")
    ..
    match chekGreetins(a, b):
        when 'Hello', 'World!': println(a, b)


COROUTINES
   # New Proposed Coroutine with Concurrency. Thanks to Go 03/08/16
   # Go-type Coroutine
   # I dunno yet if pipe can only be primitive types. I think that will be too restrictive.
   # This needs heavy review
   # Go-type Coroutine is so powerful that it can be used to achieve concurrency, distributed computing and parallelism
   # THE 'run' CALL
   func show(s =: Str):
       for x thru [1:3]:
           println(s)

   func main():
       show("Hello")
       run show("Hi")
       show("Hullo")
   ..
   # Hello Hello Hello Hi Hi Hullo Hi Hullo Hullo
   # PIPES
   func work(flo x =: Bool):
       println("working...")
       time.sleep(1500)
       println("done")
       x << true
   ..
   func main():
       flo done = Bool
       run work(done)
       << done
   ..
   # working...done
   # BUFFERING AND CLOSING PIPES
    func task(flo x =: Str):
        loop:
            if !closed(x):
                println("working...")
    ..
    func main():
        flo a =: Str
        run task(a)
        time.sleep(time.second * 6)
        close(a)
        println("done")
    ..
    # SELECT
    func main():
        flo a, b =: Str
        run func ():
            time.sleep(1000)
            a << "One"
        ..
        run func ():
            time.sleep(2000)
            b << "Two"
        ..
        select:
            case a: println(<< a)
            case b: println(<< b)
            println("Nothing")
        ..
    ..

    # Python-type coroutine
    func coroutine():
        for x thru 1..10:
            yd x
    ..
    println(coroutine()) # 1
    println(coroutine()) # 2
    println(coroutine()) # 3

    # Simulated coroutine using sticky variables
    func addUp(b):
        var sticky x = 0
        x += b
    ..
    println(addUp(4))
    println(addUp(5))
    println(addUp(6))


TYPE DEFINITION
    type Car:
        var name, model = Str
    ..
    func Car(name =: Str):  # Constructor implicitly contains a first parameter of type Car
        self.new(name)
    ..
    func Car(name model =: Str):
        self.new(name, model)
    ..
    func Car(~): println("Object Destroyed") # Normal Destructor
    func Car(!): println("xception Occured and Object Destroyed") # Exception Destructor


CONSTRUCTOR
    type Person:
        var name = Str
        var age = Int
    ..
    func Person(name =: Str, age =: Int):
        self.new(name, age) # Only constructors can create a new object
    # new() is a special function that creates an object with nilled fields and can map
    # arguments to fields.
    # Constructors that access the self.new() method directly can only be defined in the same
    # module as the type.
    func Person(name =: Str):
        self(name, 0) # you can call a another construtor through self
    # You can shorten a trivial constructor like the one above
    func Person(name)


DEFAULT CONSTRUCTOR
    # If a type doesn't provide a constructor, an implicit default constructor
    type Lamp:
        var color
    var a =: Lamp() # creates a Lamp objecta and calls the default constructor on it
    var b =: Lamp # declares a variable as Lamp, no object created
    b.color = 'blue' # but as soon as it is accessed, Lamp object is created with nilled fields.


CONSTRUCTOR TYPES
    # Constructor classes have only one constructor with arguments that map to fields
    # These fields are mutable by default and are always public.
    type Person (name, age)
    func show(p =: Person): println(self.name, self.age)


USING A FUNCTION AS METHOD (UFCS)
    func show(p =: Person): println("name: [self.name], age: [self.age]")
    var nigel = Person("Nigel Nicargua")
    show(nigel)
    nigel.show() # using show function like a method since Person is the first argument
    # you can also use it on objects directly
    var b = "hello".upper()
    var c = 25_000.divideBy(x) # Don't do this though. :)


DESTRUCTORS
    type Car:
        var name, model = Str
    func (~): println("Object Destroyed") # Normal Destructor
    func (!): println("xception Occured and Object Destroyed") # Exception Destructor
    # Destructors can only bedefined within te same module as the type.


ABSTRACT TYPES
   type ab Player # cannot be instantiated
   func play(pl =: Player)
   func rewind(pl =: Player)
   func fastForward(pl =: Player)
   type CassettePlayer <: Player
   type DigitalPlayer <: Player
   # Abstract types can be constructor type too, but this doesn't mean they can be instantiated
   # The constructor is used here to show the types fields
   type ab Person(name, age)
   type ab Thread
   func start(th =: Thread) # This is a virtual function
   func stop(th =: Thread):.. # Abstract types can contain implementations too
   func execute(th =: Thread): self.run()
   # Note that an abstract cannot use :: to assign its first parameter
   # because that signifies ony the instance of the class can use it
   # however abstract class cannot be instantiated.
   type ab Person(name, age)
   func show(p :: Person) # error!


FIELD MODIFIERS
    var hide x = 25
    var sticky y = 'State'
    type Singleton:
        var hide sticky count =: Int = 0
        var hide sticky single =: Singleton
        var value = Int
    ..
    func priv Singleton():
        if self.count == 0:
            count++
            rt single = self.new(value)
        single
    ..
    func Singleton(value =: Int):
        var x :: self()
        x.value = value
    ..


PROPERTIES / GETTERS SETTERS
    var myVar1 :: set(a b c =: Int): myVar1 = a * b * c \\ get(): rt myVar1
    myVar1 = (1, 2, 3)
    var myVar2 =
        set(a b =: Int): myVar2 = a * b * c
        get(): rt myVar2
    myVar2 = (1, 2)
    var myVar3 = set(a =: Int): myVar3 = a \\ get(): rt myVar3
    myVar3 = 1
    var myVar4 = set(a =: Int) \\ get()
    myVar3 = 2
    var tip = get(): rt myVar3


TYPE CHECKING
    # Is
    if myCar === Car:
        println('myCar is a Car')
    ..
    if myCar ==: Car:
      println('myCar is a Car or its subtype')
    ..
    if myCar =<: Car:
      println('myCar is a subtype of Car')
    ..
    if myCar =>: Car:
      println('myCar is a supertype of Car')
    ..
    # Is Not
    if phone !== Phone:
        println("phone is not a Phone")
    if phone !=: Phone:
        println("phone is not a Phone or its subtype")
    if phone !<: Phone:
        println("phone is not a subtype of Phone")
    if phone !>: Phone:
        println("phone is not a supertype of Phone")


MODULES AND IMPORT
    module MyMath
    #......
    import MyMath
    var x :: MyMath.pi * 2
    #......
    import MyMath: pi
    var y =: pi * 2
    #.......
    import MyMath: Rational as Ratio, add, pi
    let y = Ratio(4, 6)
    let z :: add(5, pi)
    #......
    import MyMath: *
    let a =: Ratio(2, 4)
    let b =: Complex(3, 5)
    let c = pi * 2


TYPE ALIAS
   Int as Meter
   func(Str Int) as StrIntFunc
   var f = StrIntFunc


METHOD CHAINING
    type Math:
        var value = Float
    ..
    func add(a =: Math, b c =: Float)=:Float:
        a.value = b + c
    ..
    func subtract(a =: Math, b c =: Float)=:Float:
        a.value = b - c
    ..
    var math = Math
    var result = math.add(1, 2).subtract(3, 4)
    # When a method returns nothing, it attaches back to object
    myProfile.post('status').accept('friend_request').mark("messages", isRead: true)


INHERITANCE # Not Finalized!
    # Note that inheritable methods need =: operator when specifying their first parameter
    type Animal
    func move(an =: Animal):..

    type Bird <: Animal
    @mask
    func move(bd =: Bird): println("Soar!") # overides move method for Animal, a super method
    func fly(bd :: Bird):..

    type Horse <: Animal
    @mask
    func move(hr =: Horse): println("Gallop!") # overides move method for Animal, a super method
    func gallop(hr :: Horse):..

    type Pegasus <: Bird, Horse # inherits Bird and Horse classes
    @mask
    func move(pg =: Pegasus): println("Gallop and Soar!") # overides move method because of CONFLICT in  Bird and Horse
    func gallopAndSoar(pg :: Pegasus):..

    var eagle = Bird()
    var horse = Horse()
    var pegasus = Pegasus()
    move(eagle) # "Soar!"
    move(horse) # "Gallop!"
    move(pegasus) # "Soar and Gallop!"
    var animals = Animal[Bird(), Horse(), Pegasus()]
    animals[1].move() # "Soar!"
    animals[2].move() # "Gallop!"
    animals[3].move() # "Soar and Gallop!"


OVERRIDING METHODS
    # Pluto now has an override hint called @mask. It is optional but recommended for
    # static-oriented codes. If you don't want to use the mask hint then you'll have to specify that
    # in the compiler hint or compile the code with the -nomask (debatable) flag.
    func play(a =: Player): .start()
    @mask
    func play(a =: DigitalPlayer): .startAt(0)


COVARIANCE
    # Pluto supports covariance thru the =: operator.
    type Person (name =: Str, age =: Int)
    func showDetails(p =: Person): println("name: [.name], .age: [.age]")
    type Engineer (kind =: Str) <: Person
    type Artist (kind =: Str) <: Person

    var person =: Person("Peter", 16)
    var engineer =: Engineer("Civil Engineer")
    var artist =: Artist("Painting Artist")
    # covariance in assignment
    var person =: Person("Matthew", 25) # home type
    var person = engineer # guest type
    var person = artist # guest type
    # covariance in argument passing
    showDetails(person)
    showDetails(engineer)
    showDetails(artist)
    # covariance in container types
    var arr =: Person[]
    var arr[1:] = [person, artist, engineer]
    # covariance in overriding
    func eat(a =: Herbivore, b =: Plant):..
    @mask
    func eat(a =: Cow, b =: Grass):.. # not only is the supermethod overriden, the arguments too are covariant


MULTIPLE LEVELS OF COVARIANCE
    # A structure with multiple type declaration can also allow covariance on each parameter
    type ab List:#= IMPLEMENTATION HERE=#..
    type ArrayList <: List:#= IMPLEMENTATION HERE=#..
    func getIndex(l =: List, i = Integer)
    getIndex(ArrayList = [1, 2, 3], 3_i16) # arg1 is a subtype of List and arg2 is a subtype of Integer
    # Covariant override is an example of multiple level of covariance
    func eat(a =: Herbivore, b =: Plant)
    @mask
    func eat(a =: Cow, b =: Grass) # valid override


CONTRAVARIANCE
    # Contravariance is not really supported in Pluto, except in generics type parameters
    func doSomething<T<:Person, U>
    # To do an upcasting, you can use a trick like this.
    type Person(name =: Str.nil, age =: Int.nil)
    type Employee((name =: Str.nil, age = Int.nil), job =: Str.nil, company =: Company.nil)
    func cast(emp :: Employee, pers =: Person):
        self.name = pers.name; self.age = pers.age
    var p =: Person("Dan", 25)
    var emp =: Employee = p



SUPERMETHODS AND SUBMETHODS
    # inheritable methods always use =: operator to specify the type of their first parameter
    type Listener
    type ButtonListener <: Listener
    func respond(bl =: Listener) # this is a super method to the more specific method below
    @mask
    func respond(bl =: ButtonListener):.. # this is a sub method to the method above


TYPE CASTING
    # Type casting is done using -> operator
    # Some cast operations have already been provided for built-in types.
    var a :: Int(5)
    var b :: Float -> a # b == 5.0
    # cast()
    type MyInteger(value =: Int)
    func cast(mi :: MyInteger, i =: Int): self.value = i
    func cast(mi :: MyInteger, f =: Float): self.value = (Int = f)
    var x :: MyInteger -> 5
    x = 6.23
    # Upcasting is not implicity supported in Pluto, one simulate this by casting
    type Person(name =: Str, age =: Int)
    type Employee(super(name =: Str, age = Int), job =: Str, company =: Company)
    func cast(emp :: Employee, pers =: Person):
        self.name = pers.name; self.age = pers.name
    var p =: Person("Dan", 25)
    var emp =: Employee -> p


CALLING SUPER
    type Person:
        var name :: Str
        var age :: Int
        func (name, age)
    ..
    type Artist <: Person:
        var kind = Str
    ..
    func Artist(name, age, kind):
        self.new(super(name, age), kind)
    # or
    func Artist(super(name, age), kind)
    # or
    type Artist(super(name, age), kind) <: Person


VIRTUAL METHODS
    func respond(a =: Listener) # a method without a body is implicitly virtual and cannot be called however.
    # conArtisttructors cannot be virtual and therefore use the same syntax for shortening initialisation
    @mask
    func respond(a =: ButtonListener) # error, a virtual super method can't be overriden by a virtual sub method
    func respond(a =: Listener):.. # This is not a virtual function, it is an empty one


DOWNCASTING
  # assuming Movie and Song extends MediaItem
   var library =: MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   for item thru library:
      if item === Song:
         println('Song: [song.name]')
      elsif item === Movie:
         print ('Movie: [movie.name]')
      ..
   ..


UNINHERITABLE CLASS
    # Why would I want a user not to inherit my class. I might remove this class in the near future
    type solo MyType:
        let x = 'Type Cannot Be Inherited'
    ..
    # an abstract type cannot be solo


GENERICS
    # Type Parameter
    =:Integer # Integer and Integer subtypes
    <:Integer # Integer subtypes
    >:Integer # Integer supertypes
    {=:Str|Int} # Str and subtypes or Int and subtypes
    func add(a b c =: $T): a + b + c
    add{Int}(1, 2, 3)
    # A function can use its type generic parameter :)
    type ArrayList(list =: $T[].nil)
    func add(al =: ArrayList, elem =: T):
        self.list += elem
    # You totally omit the type arguments if they can be inferred before use
    type ArrayList(list =: $T[])
    func setList(al =: ArrayList, t =: T[]): .list = t
    var list =: ArrayList # type argument not specified
    list = ["Hi", "Hello", "Hullo"]
    # If the types cannot be inferred before usage, an error is thrown. GenericTypeUnknown
    # Triangular dispatch
    var x =: $T<:ColorValue
    var y =: $U<:Image{T}


DATATYPE OBJECTS
    # Just as variables and functions have types, types also have types. :/
    # The type of types like Int, Float, Str is DataType
    var car = Car("Camaro")
    typeOf(var) # Car
    typeOf(Car) # DataType
    checkIfStr(a): a === Str?
    # Note that a DataType object, assuming Artist with a parent type Person, is a DataType,
    # is a DataType(Artist) and is a DataType(Person)
    enum Letter: A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z
    A === DataType? # true
    A == A? # true
    A == Letter? # true
    let a = DataType(Car) # DataType objects are exposed thru DataType constructor and can be assigned to variables
    println(a) # Car


ENUMS
    # enum is an abstract type that contains ONLY its subtypes.
    # its subtypes are all constructor types and only extend the enum
    # also an enum object expects a subtype as value
    enum Friends: Deji, Tosin, Tola # Deji, Tosin and Tola are parameterless conctructor types
    match whichFriend(f =: Friends):
        when Deji : println("This is Deji")
        case Tosin : println("This is Tosin")
        case Tola : println("This is Tola")
    ..
    var closeFriend =: Friends.Deji
    whichFriend(closeFriend)
    enum Number: IntegerNumber(i =: Integer), RealNumber(r =: Real) # IntegerNumber and RealNumber are constructor types
    # Enums provide access to its subtypes using the access operator
    Friends[1] # Returns a DataType object, here the DataType object is Friends.Deji
    # Iterating thru enum
    for x thru Friends:
        println(x)
    ..


PATTERN MATCHING
    # EXAMPLE: How to compute a tree-like expression
    type ab Tree
    type Leaf(value =: $T) <: Tree
    type Node(l = Leaf, r = Tree) <: Tree
    match sum(t =: Tree):
        when === Leaf: t.value
        when === Node: sum(t.l) + sum(t.r)
    ..
    var x = Node(Leaf(1), Node(Leaf(2), Leaf(3)))
    var y = sum(x)
    # or using enums
    enum Tree: Leaf(value =: $T), Node(l =: Leaf, r = Tree)
    match sum(t =: Tree):
        when === Leaf: t.value
        when === Node: sum(t.l) + sum(t.r)
    ..
    var x =: Tree{Int}.Node(Tree{Int}.Leaf(1), Tree{Int}.Node(Tree{Int}.Leaf(2), Tree{Int}.Leaf(3))) # Yeah not so clear
    var y =: sum(x)


REGEX
    var number =: /\d+(\.\d+(e[-+]\d+)?)?/
    var input = "23.4e+5"
    if input =~ number: println("input is a number") \\ else println("input is not a number")


ATOMIC EXPRESSION # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock: x = 5; y = x
   lock: if y == 5: println('y is 5')


ATOMIC BLOCKS # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock block:
      x = 5
      y = x
   ..
   # or better
   lock:
      x =: 5
      y = x
   ..
   lock if tip == top:
   println("Hello")
   println(", World!")
   ..


OPERATOR OVERLOADING
    var xenon =: Person -> Dragon()
    array[1] = 24
    cast()
    setIndex()
    setList()
    setHList()
    getIndex()
    func +(x =: Number, y = Number): x.value + y.value
    # you can't add "!" infront of a mutative operator function
    func ++(a =: Number): a.value++


CUSTOM OPERATORS
    # Pluto, like Swift, allows you to create your own set of custom operators that are not
    # provided by the language. The operators you can string together include
    # + - * / = < > % ^ & | ! ?
    # you have to specify operator position, associativity and precedence for custom operators
    [op: 180, left, postfix] # this operator has a predence level of 180, left associativity and is a postfix operator
    func **(a =: Number): a.value ^ 2


TRY & ASSOCIATES
    # A try statement or block must always be paired with one or more except statement even if the except catches nothing
    func main():
        ensure:
            file.close()
        ..
        println("I'm about to open a text file and print 500 numbers to it")
        var file =: File("C:/Users/Hello/hello.txt")
        try file.open().println([1:500])
        catch(fnfe =: FileNotFoundEx, ioobe =: IndexOutOfBoundEx):
            if fnfe: printErr('Can\'t find file!')
            elif ioobe: printErr('Out of index error!')
        ..
        # ensure can be used in inner scope
        let x = 3, y = 4, z = 5
        use x, y:
            let a =: x * y
            ensure println("a goes out of scope here")
    ..

    try:
        file.open()
        file.write('Hello')
    catch(fnfe =: FileNotFoundEx):
        printErr('Can\'t find file!')
    ..

    try:
        throw Exception() # this throws an error, but does not stop program
    catch(e =: Exception):  # catches all exception
        printErr('Error!')
    ensure:
        file.close()
    ..

    try let x =: getObject()
catch(ne = NilEx):
        printErr('x can\'t be nil!')
    ..

    try:
        if let x =: getObject(): \\ else: raise NilEx()
    catch() # this catches nothing

    try:
        file.open()
        let x =: file.readLine()
    catch(ne =: NilEx):
        printErr('x can\'t be nil!')
    catch(fnfe =: FileNotFoundEx):
        printErr('Can\'t find file!')
    ensure:
        file.close()
    ..


ASSERTION
# syntax of macro still in works
    @assert x == nil
    # definition of assert
    @macro
    assert(a):
        # TODO
    ..


ITERATORS (?)


FLOATING POINT BITWISE OPERATORS - Will Remove this!!


HINTS
    # a hint can have parameters declared in a symbol brackets
    @deprecated {msg = "MediaPlayer class should be used instead"}
    # a hint can introduce a block with colon.
    @if {plat = "Mac"} println("This is a Machintosh Computer")
    @if {plat = "Win"}:
        println("This is a Windows Computer")
    #------------------------------------
    @compiler # evaluated at compile-time
    @linker # evaluated at link-time
    @runtime # evaluated at runtime



COMPILER HINT
    @compiler {
        typing = "static"
        variable = "immutable"
        warn_me = {
            unimplemented_inherited_functions,
            unimplemented_inherited_fields
        }
    }


COMPOUND HINT
    # compound hint is a hint that contains other hints and
    # it can only be in the same module as the main function
    @compound:
        @if {plat = "Win"}:
            println("This is a Windows Computer")
        @elsif {plat = "Mac"}:
            println("This is a Machintosh Computer")
        @elsif {plat = "Linux"}:
            println("This is a Linux Computer")
    ..


METAOBJECTS
    # MetaObjects can be in form of functions or variables
    # Some metaObjects can be overloaded, some others can't
    # The instance attached to a metaObject can be inferred
    # based on the context of expression
    arr[_last] = 20 # _last here refers to arr._last
    # some structures such as match, enum, etc. support "subject in context" metaObject
    # which is represented with "_"
    match check30DayMonth(month = Month):
        case self.value == 4 : println("This is April, a 30-day Month!")
        case self.value == 6 : println("This is June, a 30-day Month!")
        case self.value == 9 : println("This is September, a 30-day Month!")
        case self.value == 11 : println("This is November, a 30-day Month!")
    println("Not a 30-day Month!")
    ..
    var sum =: add(a, b) |> add(_, x)
    var tip =: set(a = Int): _ = 25 \\ get(): rt _
    type ArrayList<T>(list =: T[])
    func _setList(::, t =: T[]): .list = t
    var list =: ArrayList = ["Hi", "Hello", "Hullo"]


VALUE METAVAR
    # Returned value must be a primitive value
    # This represents the objects value
    func _value(num =: MyNumber): rt num.value
    var x = MyNumber(12)
    println("[x] is my number")
    var myMap =: Map<MyNumber, Int> # sorted by MyNumber's _value


REFLECTION
    # dynamically determining which class to use
    @if (stage = "runtime", condition = "Main.useOldClass == true"): # ??
        type Class:
            var value = func set(x Str): _ = x \\ func get(): rt _
            func (value)
        ..
    @else
        type Class:
            var str = set(x =: Str): _ = x \\ get(): _
            var num = set(x =: Float64): _ = x \\ get(): _
            func (str)
            func (str, num)
        ..
    ..


MACROS !! Needs Work
    #
    @macro
    reverseExpression(ex):
        # TODO
    ..
    if @{reverseExpression x < y} : println('O.O')


COMPLEX, QUATERNION DECLARATION
    var x = 5 + 2i # complex
    var y = 5 + 2i + 3j + 4k # quaternion


MATHEMATICAL EXPRESSION
    let top =: 3x - 2y/5 + r(d^5)
    let tip =: 3x y z^2


SYMBOL, EXPR, HOMOICONICITY & OTHER SYMBOLIC CLASSES
    # Symbol
    # delimited by spaces and commas
    # interpolated using "[]"
    # can also be nested {x, {y, b}}
    var buck =: {1}
    var back = {1 2 3}
    let bean = {hello {hi {halo}}} # can be nested too
    let beak = {"hello ", [name]}
    let x = beak[1] # hello
    let y = beak._value # hello Nypro
    # Expressions
    var pat =: ex{1 + 2 * [number]}
    var exp = parse("1 + 2 * 3")
    var ingrid = eval(exp)
    parse(pat)
    var math = m{3x - 2y/5 + r(d^5)}


COMPILE TIME SYMBOLS ??
    # Symbols is different from macros in that, the content is only broken down
    # as specified by the programmer, but it is evalusted at runtime as strings
    # This could be useful for PEG lib, for example, cos structures can be taken from
    # the user and then broken down at parse-time.


CPLUSPLUS SYMBOL
    var str = cpp{void add(int a, int b) {return a + b;}}
    parse(str)
    let sum = str.add
    var brim = sum(1, 3)


NON-STANDARD SYMBOL LITERAL HINT
    var cxxCode = cpp{void main() {printf("Hello")}}
    @symLiteral:
        cpp = {Cpp(_value)}


NON-STANDARD STRING LITERAL HINT
    var byteArray =: ba"87004"
    @strLiteral:
        re = {ByteArray(_value)}


NON_STANDARD NUMERIC LITERAL HINT
    var price =: 1_359.99_\\
    @numLiteral:
        \\ = {Dollar(_value)}


NUMERIC CLASS
    let x = UInt.max()
    let y = Int32.min()
    var z = m{2x + 4y/3}.round() + (24.25/4).floor()


RATIONAL CLASS
    var xianghou = 2//3
    var dean = x.toFloat() # rational format can be changed to fp
    var bean = 4//6 ; println(y) # 2//3
    4//2 == 1//2 # true
    4//2 == 0.5 # true


BITS TYPE
    # bits stored in multiples of 8
    let bits8 = Bits(8)
    let bits16 = Bits(16)


BUFFER TYPE
    # This might allow Array implementation to be separated from storage and to allow
    # Arrays to be implemented completely in Pluto.
    # It stores objects in adjacent memory
    let intStore5 = Buffer(16, 5) # first arg is alignment, secong arg is size


INTEGER BITWISE OPERATORS
    var x = 2!&5 # and
    var y = 3!|6 # or
    var z = !~6 # not
    var a = !^7 # exclusive or
    var b = a!>7 # bit shift left
    var c = b!<7 # bit shift right


BINARY LITERALS
    var myVar = 0b11001001 # deprecated


HEXADECIMAL LITERALS
    let myVar = 0x5eff77 # deprecated


OCTAL LITERALS
    var myVar = 0o56773 # deprecated


UTF-8 CHARACTERS
    let char =: '\u6E'


CLASSES OF OBJECTS
    Obj (0.7), Any (0.8)
    Func (0.7)
    Var (0.7), Indie(0.8.2)
    Array (0.7)
    Dict (0.7)
    Exp (0.7), Expr(0.8.2)
    # Nil (0.4), None (0.8.1), # Removed (0.8.2)
    Symbol(0.7)
    DataType(0.8.2)


PREDEFINED TYPES # These types are optimized as part of the lang
    Int, Int16, Int32, Int64
    UInt, UInt16, UInt32, UInt64
    Float16(0.8.2), Float/Float32 (0.4), Float64/Double (0.6.1)
    Bool (0.4)
    Str (0.4), String (0.6.1), Str (0.8.1)
    Char
    Byte
    SByte
    Comp, Comp128
    Quat, Quat256
    Num (0.4) #= redefined in (0.8.1) =#, BigInt, BigFloat (0.8.2)
    Ratio


LOGICAL vs BITWISE OPERATORS
    ! & |
    :~ :& :| :^


KEYWORDS
    stick (0.4) sticky  (0.6.1)
    # pub (0.4) public (0.6.1) pub
    priv (0.4) private (0.6.1) priv
    pro (0.4) protected (0.6.1) prot
    pack (0.4) package (0.6.1) pack
    pass (0.7.5)
    class (0.4), type()
    rt (0.7.2)
    def (Rev 0.5.2), def (0.8.2), func (0.8.2)
    let (Rev 0.5.2)
    get (Rev 0.5.2)
    set (Rev 0.5.2)
    as (0.8)
    if
    else
    elsif
    while  (0.6.1)
    eval (Rev 0.5.2) match (0.8.1)
    for
    do
    until (0.6.1)
    next (0.6.1)
    break
    label (0.7.0)
    use (0.5.2), use (0.8.2) # reintroduced
    # fixed
    thru (0.8)
    in(0.7.2)
    skip(0.8)
    ensure (0.8)
    try
    catch
    self
    var (0.8)
    nan (0.8)
    nil
    op (0.8.2)
    abs, ab(0.8.2)



OPERATORS
    +
    -
    *
    /
    // # for ratios
    ^
    %
    --
    ++
    .+
    .-
    .*
    ./
    .^
    .%
    .--
    .++
    =
    =:
    <:
    >:
    ::
    +=
    -=
    *=
    /=
    //=
    ^=
    %=
    .+=
    .-=
    .*=
    ./=
    .//=
    .^=
    .%=
    ==
    !=
    ===
    !==
    ==:
    !=:
    =<:
    !<:
    =>:
    !>:
    =~
    !~
    !
    >
    <
    >=
    <=
    &
    |
    :~
    :|
    :&
    :^
    >>
    <<
-   '
    .=


SYNTACTIC SYMBOLS
    |, \\ (0.8.2)
    ;
    @
    :
    ..

---------------! NOTES !------------------------
VARIABLE BINDING



LITERALS
- Literals are subexpressions that do not return unlike other subexpressions (variable access)
- or expressions (operations, function call).
Type of Literals
- Numeric
    50, 12_000_i32, 78.89e-2
- String
    "Hello", 'Hi'
- Symbol
    {Root}, {Parent {Child1 Child2}}


NIL
- There are two states an object can have, valued state or nil state. An object with valued state can
- contain primitive values or other objects, but an object with a nil state can only contain nil.
- Nil can be assigned to an object directly (a syntactic sugar for the object's nil state),
- but they cannot be returned. Although one can pass or return an object with a Nil state.
- The recieving object must handle it or else NilErr will be invoked.
    var deal = nil # is Any.nil
    var done = deal # error! NilErr
    var deck = deal~ # deck now accepts nil
    # you could also do this
    var dark = deal~0  # dark will be 0 if deal is nil


OBJECT HIERARCHY
- Any -> Indie, Array, Func,
- DataType


CONCURRENCY


CONDITIONALS
- Value
- nil or not
- True or false
- Type (===)


ITERABLES
- Coroutines
- Functions
- Range
- Array objects
- Table objects
- Iterable SubClasses
- String
- Enums


SUBJECT OF OPERATIONS
# is signified by '_'
- Stack
- Match
- Properties


AUTOMATIC REFERENCE COUNTING
- There can only be one strong ref to an object
    type Skeleton:
        bones List<own Bone> # bones contain a list of strong Refs to Bone objects
    ..
    type Bone:
        skel Skeleton
    ..


MOVE SEMANTICS
- Move feature is automatic in areas where it makes sense to do so for example, returning a value (not reference) to a variable.
- I removed the explicit move keyword because I think it will have some unwanted side effects. For example, moving a returned reference which is also referenced elsewhere.
- And Pluto moves at the appropriate places anyway.


DECLARATIVE PLUTO ".deplu" #27/06/16
   person:[
      name : "Nypro"
      fat : false
      tall : true
      hobby : 'programming'
      single : _ # underscore as a value signifies empty
      children : [2, 3, 4, 6]
      coord : [x : 5]
      coords : [x : 1, y : 2, z : 3]
      gamesLiked : name, releaseDate, hard [
         ["Crysis", 2007, _],
         ["Unreal Tournament", 1999, true],
         ["Portal 2", 2011, true],
      ]
   ]


DUCK TYPING EXAMPLES
   var c
   var a = 25
   var b =: [1, 2, 3, 4, 5] # array
   var c = [1, 2, 3 | 4, 5, 6] # multi dimen array
   var d = ['Hello', 25, 1.3f, 'Hi'] # table
   func getArea(length, breadth):
      length * breadth
   ..
   var length = 10
   var breadth = 25
   var rectangleArea = getArea(length, breadth)


NESTED ASSIGNMENT
- Pluto does not support nested assignments. Dunno really :p
   var tip = 5
   var tap = (tip *= 5)


PASS TABLE
#=
    Types                               |   Passed Around By
    ----------------------------------------------------------
    Built-in Ind Types /  Value Types   |   val
    Array Types                         |   ref
    Func Types                          |   ref
    Custom Types                        |   ref
=#
- Note that objects of relatively small Array, Func and Custom Types
- will be allocated on the stack while simulating referencing
- And this is done only if the object is iso or guaranteed to have a
- single reference


VARIABLE VS PARAMETER
- Variable declaration is nothing like parameter declaration


COMPILER WARNINGS
- When assigning to variables in other modules
- Pluto only warns when about imported naming ambiguities when the names are accessed


RUNTIME WARNINGS


COMPILATION
- '_' is compiled as a placeholder. This will be replaced at run time by a subject of context
- some symbolic types are evaluated at compile-time, e.g. MathExpr


PUNCTUATION
- Pluto needs proper use of indentations and newline to compile successfully
- This makes code reformatable to original when copied. Especially with nested if-else blocks.
- Pluto only supports consistent space-based identation. Indentation should not use below/above 2 to 5 spaces


BIG AIMS
- If Pluto is written statically, then most of the analyses should be done statically
- with benefits of optimisations (e.g. usingg traditional arrays). Only certain checks are
- done at runtime.
- Static ARC analysis. Be careful with concurrency.


UTILITIES
IDE
- The REPL
- Advanced Refactoring
- Code Completion
- Render/Plot View
- Step-through Debugger
- Profiler
-------------------
Network and Streams
- terminals
- files
- TCP sockets
- pipes
-------------------
Virtual Machine
- PlutoMine
-------------------
Compilers
- Bytecode/AST Interpreter and JIT Compiler.


QUIRKS
- DataType vs Generics (dataType is a runtime object, generics is a static meta object.)
- Macro and its relationship wih the AST
- Multi-line Expression
- Returning list or iterator for stuffs like
    var x = [:50]
- Whether nullable objects should be declared nullable, or all object should be nullable by default
- Chained conditions can be written in 4 ways. (update) Now reduced to 3 but wih one producing an error if used certain way
