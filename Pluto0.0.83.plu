Revised 02/10/16
# 0.0.83
#=
Major Change:
    Restructuring for Multiple Dispatch
    Import is now module-based, rather than being type-based, due to the introduction of multiple dispatch
    A type's method may be defined outside the type's file
    Added def to function declaration #18/08/16; changed to func, which was what I started with initially #29/06/16
    Changing assignment operator back to = instead of :=
    Binding to nil-and-one-other-type is still done implicitly 19/08/16; nil is now an object state #30/08/16
    The block punstuation is now $, it helps resolve some ambiguity in statements like repeat play() | while state == "Play" | x == y ? y | z
        repeat: play() $ while state == "Play" | x == y ? y $ z
    Added mut for mutable variable declaration; solves some scoping issues.
    Pluto is an interpreted statically-typed language that requires no type annotation. #31/08/16
    ^^^Scratch that. Pluto is an interpreted hybrid language with a static and dynamic type system. #31/08/16; Pluto is not necessarily interpreted. #22/09/16
=#

PLUTO's DESIGN PHILOSOPHY
- let it do more with less
- make it fast
- make it legible
- make it consistent
- make it flexible (dynamic and static)
- make it lightweight

DESCRIPTION
Pluto is an interpreted language that supports optional typing without sacrificing performance as a result.
Pluto supports both object-oriented and procedural programming. This is in part achieved by closely associating types with multiple dispatch in functions.
Some of Pluto's features include list comprehenshion, generics, closure, lambdas, mutiple dispatch


--! THE EXAMPLES BELOW ARE MOSTLY STATICALLY TYPED !--
SINGLE-LINE COMMENTS
   # Hello


MULTILINE COMMENTS
    #=
    I'm Pluto
    I'm cool
    =#
    # Pluto will support nested multiline comments :)


DOCUMENTATION
   # <code> Car </code>  class is deprecated # xml
   # [ code: 'Car' ] class is deprecated # deplu


VARIABLE DECLARATION & INITIALIZATION
    # Unlike Python, Pluto requires explicit variable declaration before usage
    mut x # is a mutable
    let y # is a constant
    func add(a, b): rt a + b # function parameters are implicitly mutable
    func swap!(mut a, mut b): a, b = [b, a] # error! mut should not be explicitly specified in their declaration
    mut e ; e = Car('Camaro') # semi-colon is used to separate statements
    mut y = 12f
    mut z = 'Hello'
    mut a =: Car('Camaro')
    mut b = Car('Camaro').setDate(2014)
    mut n = getCar('Camaro')
    mut o = add(2, 4)
    mut p = List<Car>(3) # generics


FUNCTION DEFINITION (1)
    func add(a, b):
        rt a + b


EXPRESSION-ORIENTED
    # Pluto is an expression-based language. If an expression evaluates to something, it is returned
    let myBool = (myName == "Nypro"?)
    func add(a, b): a + b
    # sometimes rt is needed to return an evaluation immediately
    # to prevent execution spilling back into parent block when not needed
    func compare(x, y):
        if x == y:
            rt 0
        if x > y:
            rt 1
        -1
    ..


SPECIFYING TYPES
    mut p = Person("Bradley") # loosely-bound assignment, variable can be assigned to another type later.
    mut p = Person # error! You can't do strict binding with '=' operator
    mut p =: Person # Strictly bound to Person and Person's subtypes.
    mut p :: Person # Strictly bound to Person only.
    mut a =: Int[] # The container can only be populated with instances of Int or its subtype.
    mut b :: Int[] # The container can only be populated with instances of Int.
    let d = "Hello, world!" # loosely-bound variables can also be constant, even though they are promoted to Strictly
    mut r = 25; r =: 0.3 # error! loosely-bound variables cannot be changed later to strict variables and vice-versa


OPTIONAL TYPE DECLARATION
    mut myNumber :: Str|Int
    mut myNumber = '01000999'
    mut myNumber = 23


VARIABLES AND REFERENCES
    # Value types such as Int, FLoat, etc. are passed around by value, reference and container types are passed
    # around by reference
    # see pass table below
    mut pet :: own getObject() # pet now holds a sole strong ref to the object returned
    mut pet = iso getObject() # pet exclusively refers to the object returned (if it is a value object)
    let put =: val pet # assigned by value
    mut pot =: read pat # read is a type of ref that allow reading only from referenced object
    # side effect of read:
    # if later in the future a variable is changed to read, it will lead to having to change code that have assigned to it, which can be a lot. :'(
    let pit :: val put
    func subtract(let a let b let c =: ref):
        c = a - b
        rt ref c
    ..
    mut dean = val subtract(x, y) # gets a copy
    let cop = subtract(x, y) # gets a ref
    func add(a b = ref):
        rt val a + b
    let alm = ref add(val x, val y) # warning, return a val to a ref
    swap!(val a, val b)
    # there is nothing like ref iso or ref own, there is however val iso and val own.
    mut x = ref iso getName() # error!
    mut y = val own getName() # ok, y gets a copy of name and owns it.


CHAINED DECLARATION
    mut x = 5, y = 6 # Must be of the same type
    mut x, y :: [1, 2]
    x, y = [y, x] # Swap operation
    let a, b, c, d = [:4]
    mut x =: Array -> [1, 2, 3, 4], y =: Array


CHAINED ASSIGNMENT
    # Covariant assignment
    mut person =: Person = Artist("Dan", 21, "Painter")
    # Type casting
    mut num =: MyNumber = 25.34f
    # Its is advised to always bracket expressions with more than one assignment operator
    # _setList() call
    let list =: List = (MyList = [1, 2, 3])
    # Anonymous object
    func divideAList(num :: Int):
        (MyList = [1, 2, 3, 4]) /= num
    mut x =: y =: 5


NUMERIC LITERALS
    mut d = 2 # Int
    let r = 2.5 # Double
    let e = 2f # Float
    let m = 3d # DoubleS
    let y = 4_567.32f # Float
    mut x = 1_000_000 # Int
    let y = 1_999.99 # Double
    mut v = 12_000_i32 # Int32
    mut w = 145_ui18 # UInt16
    mut z = .1 # Double
    mut p = .2e-2f # Float
    mut d = 1.56_f32 # Float


ACCESS MODIFIERS
    # No public modifer, members are all public by default
    mut priv a = 10 # accessible only within the module
    mut pack b :: 'HELLO' # accessible within the file level
    mut pass c =: true # synon with Java's protected
    mut prod d :: 5f # synon with C#'s internal # I'm contemplating on its removal
    # access modifiers can be used with types and functions too
    func pack addPerson()
    func pass getNumber()
    type priv Company
    type prod Artist [Person]


PACKAGE LEVEL ACCESS MODIFIERS # Might remove this, it looks dangerous!!! :P
    mut pack< date :: Date
    mut pack>> isbn = Long


READ-ONLY WRITE-ONLY ACCESS MODIFIERS
    rpriv, rpass, rpack, rprod # rpub and wpub useless
    wpriv, wpass, wpack, wprod


ACCESS MODIFIER BLOCK
    # modifier block is the only block in Pluto that may not be indented and it doesn't create a scope
    mod let priv:
    mut x = 4.5f
    mut y :: 2.5f
    mut z = 0.0f
    ..
    # you can also chain modifier blocks together
    mod let priv:
    mut x = 4.5f
    let y = 2.5f
    mut z = 0.0f
    mod pass:
    mut name = getName()
    let age = getAge()
    ..


ARRAYS
   #  An array can grow.
   mut fin = Car[('Camaro'), ('Mustang')]
   mut fan =: [Car('Camaro'), Bike('Ducati')]
   mut gin = 3 Car[] ; mut gin = Car[('Camaro'), ('Mustang'), ('Maserrati')]
   mut tin =: 3 [Car('Camaro'), Car('Mustang'), Car('Maserrati')]
   let ted :: [1, 2, 3, 4, 5]
   mut top = ted
   mut go =: 5 Vehicle[Car("Camaro"), SuperBike("Ducati Multistrada"), Plane("Boeing 747")] # covariance in container
   mut go[1] = Car("Camaro")
   mut go[2:] = Car[('Mustang'), ('Maserrati')] # starts filling from index 2

   mut pot = Array
   # or better
   mut pot = []

   mut pit = Array<Int, 3> # an Int array with the size of three
   # or better
   mut pit = 3 Int []

   mut pet = [5] # this is an array with one element, 5
   let put = 5 []
   let pat = 4 [1, 2, 3, 4]

   let pat.foldleft(0, func (a, b): rt a + b) # (((0 + 1) + 2) + 3) + 4 = 10
   mut mat = getArray()
   mut net = getArray() # error, array not exposed, so '[]' must be used
   print(go) # list elements row-wise
   print(go[_col]) # list elements col-wise
   mut dean = Array
   mut dean = [10, 8, 6 ,4, 2]


MULTIDIMENSIONAL ARRAY
    mut arr2D = [|]
    mut arr3D = [||]
    mut arr = 2x2 [1, 2 | 3, 4]
    let arr = 2x2x2 Int [1, 2 | 2, 3 || 4, 5 | 6, 7]
    mut arr = [1, 2 | 3, 4]
    mut d =: List<List<Int>> ; #= better =# mut x =: Int[|] # A multidimensional array is a dictionary
    mut d = Map<Int, Str> ; #= better =# mut x = Int Str [|]
    print(arr [:])
    print(arr[2, ]) # print columns in row 2
    print(arr[, 2]) # print rows in col 2
    mut arr = [1, 2] # vcat
    # 1 2
    mut arr = [1, 2 | 3, 4] # vhcat
    # 1 2
    # 3 4
    mut arr = [1 2] # hcat # might change the to just vhcat
    # 1
    # 2
    mut arr = [1 2 | 3 4] # hvcat # might change the to just vcat and vhcat
    # 1 3
    # 2 4


DICTIONARIES
    # A multidimensional array is automatically a dictionary
    mut tuple = ['Tola', 1.2]
    let candidate = [
        1, 'Aditya' |
        2, 'Nypro'
    ]
    print(candidate.key(1)) # Aditya
    print(candidate[1]) # 1, "Aditya"
    let aditya = Str Int Int ["Aditya Singh", 19, 6.2]
    let aditya = Str Int Int ["Aditya Singh", 19, 6.2]
    for index, name thru candidate:
        print("[index] : [candidate]")
    # Dictionaries of higher dimension (greater than 2)
    mut dict3D = [
        "People",
            "Tony", 4, 5, 6 |
            "Brad", 1, 2, 3 ||
        "Animals",
            "Bingo", 1, 5, 6 |
            "Servo", 3, 6, 9 ||
    ]
    dict3D["People", "Tony", 1] = 5
    dict3D["People", "Tony"] = [1, 2, 3]
    for kind, name, number thru dict3D:
        put("[kind]: [name]: [number], ")
    # Note that 'for x thru interestingNumbers' will iterate over the entire elements in the array, while 'for x, y thru interestingNumbers' will iterate thru the key-value pairs in the array


ARRAY SLICING
   arr :: [1, 2, 3, 4, 5, 6]
   print(arr[1:3]) # first index to the third
   put(arr[:5]) # first index to the 5th index
   print(arr[3:_last]) # 3rd index to the last
   print(arr[-3:]) # from the 3rd index starting from the back
   newArr = arr[:] # all elements
   print(arr[_last:]) # print from behind


ACCESSING ARRAYS
    mut attendanceList = Student[("Dave", 25), ("Tony", 45), ("Spencer", 18)]
    mut names =: attendanceList.[name] # returns a list of name fields in the list
    mut ages = attendanceList.[age] # returns a list of age fields in the list


MATRIX-VECTOR OPERATIONS # column major order
    mut mP = 2x3 [2, 4, 3 | 3, 1, 5] * [3, 10 | 4, 2 | 1, 7]
    mut mX =: Mat.identity(2, 2)
    mut mY = 2x4 Int [ # might change the to just vhcat
        1 1 1 0 |
        0 1 1 1 |
    ]

    let mZ :: mX / mY
    mut mRows, mCols = mZ.dimen()
    let mQ = mX’ # z is assigned transpose of matrix u


VECTORIZATION AND ARRAYS
    # Element-wise operations
    mut mA =: [2, 4, 3 | 3, 1, 5]
    mut mB =: [3, 10 | 4, 2 | 1, 7]
    mut mC = mA .* mB # element-wise multiplication
    let mD =: mA ./ mB ./ mC


STRING TYPE
   mut myStr1 = "Hello"
   mut myStr2 = Str('Hi')
   mut str =: AStr("This is an ascii string") # ASCII string
   mut myStr3 = 'Halo'
   mut str2 =: Str
   let length = "Hello".len()


STRING INTERPOLATION
   mut name = 'Pluto'
   mut time =: 2015
   mut msg =: '[name] is a language started in [time]'
   mut hello = 'Hello #= Beautiful =# World'
   print("This is a number: ", 4)


STRING OPERATIONS PROPOSAL
   mut apple = 'ab' + 'c' # = 'abc'
   mut mango = 'abc' * 2 # = 'abcabc'
   mut grape = 'abcabc' - 'ca' # = 'abbc'
   mut guava = 'abcabc' / 'c' # = ['ab', 'ab']
   mut peach = ['ab', 'ab'] * 'c' # = 'abcab'


NON-STANDARD STRING LITERAL
   let byteArr = ba"87004" # 8, 7, 0, 0, 4 represent the actual byte to be placed in memory
   mut byteArr = bv"data\xff" # converts the values d, a, t, a, \xff into binary that fits in a byte
   let specVersion = ver"0.8.2"


ESCAPE SEQUENCE
- \[ \t \n \" \' \# \. \\


MULTILINE STRINGS
    let greeting =: "Hello,"
        " world!"


VERBATIM STRING
    '''Use \t for tab and \n for newline'''
    """Use \t for tab and \n for newline"""



MULTILINE EXPRESSIONS
    # expressions that are not naturally enclosed like arrays or function calls can be continued
    # on separate lines by enclosing the whole expression in a bracket
    # or by ending each line with a backslash before continuing the expression on the next line.
    mut yay = (2 * (a / 2)
        + b)
    # or
    let mune = length == 1 ? 25 \
        :: 0
    mut d = "I am a star 28" \ # even for expressions like this you have to use '\'
        .split(/\s/) \
        .join \
        .filter(: _1 !~ \d)


SANDWICHED STATEMENTS
    # sometimes one would want to write a series of statement where it is not expected.
    # In such case, the list of statements can be encapsulated in a bracket.
    func clean(input =: Str): input.filter do x : mut sticky y; y != x ? (y = x; true) :: false # idiomatic


IF SATEMENT
    if myMoney == 1_000_000:
        print("Yay! I'm rich!")
    ..
    if x == 3 : print('Hello') ..
    if x == 1 :
        print(x)
    elsif x == 2 :
        print(x)
    else :
        print('invalid value')
    ..
    if x == 3 => y == 2 => z == 1: print("I rock!") # relative chained conditions,
    # following condition is not evaluated unless preceding condition is true
    # It is quite similar to & here but its essence is best discovered when used with for thru statements
    # NIL #
    # checking if an object is not nil, requires
    # the '~' operator. This is, in part, due to the ambiguity
    # with Bool objects. "if bool: print(bool)" would have been
    # ambigous otherwise. Not knowing whether it checks for not-nil
    # or it checks for true
    if x: # if x is not nil or false
        print('x has a value')
    ..
    if x~: # if x is not nil
        print('x has a value')
    ..
    if x =: getX()~: print("x is not nil")  # if variables are implicitly mutable
    if !let x =: getX()~: print("x is nil")
    if let mySalary = getSalary()~, let myAllowance = getAllowance()~: letsParty()


CHAINED CONDITION (Oh My!)
    if x > 0 & x < 10: print("Hello") # error! operand repetition redundancy
    # or
    if x > 0 & < 10: print("Hello") # Ok
    #......
    x == y & y == 5 ? # error! operand repetition redundancy
    # or
    x == y & == 5 ? # 0k
    # or
    x and y == 5 ? # Ok
    #......
    # 'and' and 'or' here are used in a different manner
    # than in Python
    if "two-syllable word" == pit and == pot:
        print("That's weird")
    # or better
    if pit and pot == "two-syllable word":
        print("That's weird")

    if pit or (pot and pet) == "two-syllable word":
        print("That's weird")

    if x > y and z
    if x > y & > z


FOR LOOP
    for i thru [1:10]: # for variables are implicitly hold and always mutable
        if  i % 2 == 0 :
            print('[i] is an even number')
        else :
            next
    ..
    let interestingNumbers = [
        "Prime", 2, 3, 5, 7, 11, 13     |
        "Fibonacci", 1, 1, 2, 3, 5, 8   |
        "Square", 1, 4, 9, 16, 25
    ]
    mut largest
    for x, y thru interestingNumbers:
            if y > largest: largest = y
    print(largest)


HOLD VARIABLES IN LOOPS
    for x thru [1:50]:
        mut hold x = 1
        print(x * y)
        x++
    ..
    func recursive(y):
        mut hold x = 24 # You can use hold variables in recursive functions too
        if y < 0: print(y)
        else: recursive(x - y)
    ..


LOOP
   loop :
      if x != 0 :
         print ('Hi')
      else :
         break
      ..
   ..


WHILE LOOP
   while myBool == true :
      print ('Hello ')
   ..


REPEAT WHILE LOOP
   repeat:
      print ("Hello ")
   while myBool == true


UNTIL LOOP # useful because you know the terminating condition but I might remove it tho (??)
   until myBool == true:
      print("Hello ")
   ..


REPEAT UNTIL LOOP
   repeat: print ("Hello ") $ until myBool


CONDITIONAL/TERNARY OPERATOR
    # ternary operator
    mut myVar1 = myBool == true ? 5 :: 6
    func divide(num, denom): rt denom == 0 ? nan :: num / denom
    mut salary = (workYears > 5 ? 10_000 :: 1_000) * rank # when conditional ternary expression appears
    # within another expression, it must be bracketed
    # conditional operator
    mut state = isSick == true? # evaluation returns either true or false, not to be used in an if condition
    if isSick == true? : print("go to the doctor") # error! redundancy
    func clean(input =: Str): input.filter do x : mut sticky y; y != x ? (y = x; true) :: false # idiomatic


RANGE
   let x, y, z = [1:3]
   for x thru [1:(20 - 1)]: print(x)
   let x = ['a':'z'].append(['A':'Z'])


THRU
   for x thru [1:20 - 1)]: print(x)
   mut y = for x thru [1:30]: x # a for comprehension that returns a list of 1 to 30 same as
   mut y = [1:30]


WHERE
   if p.age == 20 => p.name == "Allen": p # not really useful here
   # same as
   if p.age == 20 & p.name == "Allen": p
   for x, y thru books => a thru x => a.startsWith("The"): x # chained where


FOR COMPREHENSION
   mut list = for x thru [1:30] => x % 2 == 0: x * 3
   for x, y thru books => a thru x => a.startsWith("The"): x


STEP
    # Used with iterables that have step method
    for x thru [1:2:9]: # 1, 3, 5, 7, 9
        print(x)
    ..


IN
    mut x = 3
    if x in [1:10]:
        print(x)
    ..


NOT IN
    mut arr = for x thru [1:30] => x not in [2:5]: x * 3


NIL STATE AND OPERATOR
    # There are two states an object can have, valued state or nil state. An object with valued state can
    # contain primitive values or other objects, but an object with a nil state only has nil.
    mut name = nil # Flexible variables can be assigned nil
    let name =: Str.nil # Strictly bound variables cannot, the nil must be of a particular object
    mut penny = purse.change()~0 # This expression returns 0 if returned value from purse.change() is in a nil object
    mut pay = (jobHours~0) * 50 # when nil operator appears within an expression it should be bracketed
    let balance = remote.(account~Account("Empty")).getBalance() # Needs to be handled if returned nil is not of a particular object


ONE-LINE BLOCK
   func addTwo(a b =: Int) Int:
      print (a + b)
      rt a + b
   ..
   func addThree(a b c =: Int): print (a + b + c) ; rt a + b + c
   if x == y
   if x == y: print(x)
   if x == y: print(x) $ else : print(y)
   if state == "Play": play() $ if state == "Stop": stop()


NAMELESS BLOCK
   func doSth():
       mut x, y, z = [1, 2, 3]
       use x, y: # can only access x znd y
           print("[x] : [y]")
   ..
   func doSth():
       mut x, y, z = [1, 2, 3]
       use: # cannot access variabes from outer scope
           print("[x] : [y]") # error!
   ..
   func doSth():
       mut x, y, z :: [1, 2, 3]
       func(): # can only access any variable from outer scopes
           print("[x] : [y]") # error!
   ..


LABELS
   [label: outer]
   for i thru [1:10]:
      for j thru range(10) :
         print('i : [i] j : [j]')
         if j == 5:
            next outer
         ..
      ..
   ..


SKIPPING BLOCKS
   [skip : 3]
   if x == 5 : print('Hello') # block is skipped after the it has been executed 3 times.


FUNCTION DEFINITION (2)
   func add(a =: Int, b =: Int) Int: # a return type can be specified after the parameer bracket
      rt a + b
   ..
   # a parameter can have default value. Before nko
   func add(a :: 0, b :: 0) Int:
      rt a + b
   ..


RETURNING A VALUE
   func add(a =: Int, b =: Int) Int:
      rt a + b
   ..


STICKY LOCAL VARIABLES
  # I like sticky local variables because it brings variables closer to where they are needed
   func add(a =: Int) Int:
      sticky sum = a # this variable will maintain its state whenever add function is called
      rt sum += a
   ..


GLOBAL FUNCTIONS
   # Pluto comes with some helpful global methods
   mut str = "Hello"
   len(str)
   typeMin(25)
   typeOf(Int)


CHAINED DECLARATION IN FUNCTION PARAMETER
   func add(a, b): a + b # parameters a and b are deferred-inferred, their types will be inferred when they are called.
   func add(a, b :: Int): rt a + b # a is deferred-inferred, b is Int
   func add(a b =: Int): rt a + b # both a and b are Int, = is left associative here
   func add4(a b, c d =: Int) Int: # a and b are deferred-inferred, c and d are Int
      rt a + b + c + d
   ..


CONSTANT PARAMETER
    # function parameters are mutable by default, but they can be made immutable by specifying let
    func add(let a, let b): let c = a + b ; rt c


ARGUMENT NAMING
   func addPerson(name :: 'Aditya', age = 28)
   func sum(a, b :: 1, c = 0):
      rt a + b + c
   ..
   # arg naming can be used to skip optional args
   sum(3, c = 6) # b skipped


VARIADIC PARAMETERS
   func sum(first =: Int, others =: Int []):
      mut tmp = first + arr
      for x thru arr:
         tmp += x
      ..
      rt tmp
   ..
   # or better
   func sum(first =: Int, others =: Int []): rt first + others
   mut lion = sum(1, 2, 3, 4, 5, 6)
   mut tiger = sum(1, 2, 3, [4, 5, 6])
   mut array = [1, 2, 3, 4, 5]
   let leopard = sum(0, array)
   # Conflicts
   func add(a = 3 []): rt sum(a) # conflicts with the function below
   func add(a, b, c): rt a + b + c # conflicts with the function above


MUTATIVE FUNCTIONS
    func add(x, y): a + b
    func swap!<T>(x y =: ref T): x, y = [y, x] # use exclamation mark for functions
    # that can mutate objects passed to them
    mut tip = add(2, 3)
    mut top = add(4, 5)
    swap!(tip, top)


UNOVERLOADABLE FUNCTIONS
   func add(args = [])
   func add<T>(args =: T[]) T


RETURNING AN ARRAY
   func addThree (a b c =: Int) 3 Int []:
      [a + b, a + c, b + c]
   p, q, r =: [1, 2, 3]
   x, y, z = addThree(p, q, r)
   w = addThree(p, q, r)[1] + z

   func addSubTwo(a b =: Int) Int []: [a + b, a - b]


RETURNING A TUPLE
   func getDetails(u = User):
      rt [.name, .age ]
   ..
   mut x = getDetails() # the headers can be respecified


RETURNING VARIABLES
   # check for pass table in notes
   func getReadOnly() []:
      rt read myList # unmodifiable after it has been returned
   ..
   func getVal():
      rt val myList
   ..
   func getRef():
      rt ref myList
   ..
   func getOwnership() [|]:
      rt array
   ..
   mut pat =: val getVal() # redundant
   mut put :: ref getRef() # redundant
   mut pit :: read getReadOnly() # redundant
   let cup =: ref getVal() # returned value is moved
   let cap =: val getRef() # returned reference is copied
   mut cep =: own getRef() # error, already has reference
   mut cip = iso getRef() # error, already has reference
   mut hola = read getVal() # returned value is moved, but cannot write


FUNCTION OBJECTS
   mut add2 = add
   mut add3 =: Func
   mut add =: func(Str)
   func solve(a, b, c =: func(Int Int)Int ): c(a, b)
   mut new = func(a b =: Int): rt a + b


EVENTS
    func add(a, b): a + b
    add += subtract, divide, multiply
    add -= multiply
    mut xeno = add(1, 5) # normal function call
    emit add(1, 3) # use emit keyword to event call a function


CLOSURES
   func outer():
      mut a = 6
      rt func (b =: Int) : a + b # a closure can access variables in outer scope
   ..
   mut add = outer
   # nameless closures (except those returned by a function or another closure) are executed at the
   # point they are declared
   # named closures on the other hand are not executed until they are called
   func add (x y =: Int):
      func (): rt x + y
   ..
   mut sum =: Func
   mut sum = add
   mut foo =: func(Int, Int)


FUNCTION AS ARGUMENTS
   func addThree(a, b, c, foo =: func(Int, Int)):
      rt myFunc(a, b) + c
   ..
   addThree(1, 2, 3, func (a, b): a * b)
   # or
   addThree(1, 2, 3) do a, b: a * b

   func add(a, b): a + b
   addThree(1, 2, 3, add) # passing and already-declared function

   numberList.filter() do x: pivot > x # if a function has no argument, you can omit the brackets before the do statement
   numberList.filter do x: pivot > x


ANONYMOUS OBJECTS/TYPES
    MusicPlayer("user/lib/songs/music.mp3").play() # Mind you, unlike Java, this expression returns
    # the return value of the method instead of the invoking object itselfs
    func divideAList(num :: Int):
        (MyList = [1, 2, 3, 4]) /= num

    ([Thread]: # Thread is abstract
        func run():
            print("This is a thread")).start()

    func keyListener(p =: Person): e.save("Steve"); e.delete() # Person is not abstract
    keyListener(
        ([Person]:
            func save(name):
                .name = name
                print('Hello [name]')
            ..
            func delete():
                .name = "")
    )


LAMBDAS
    keyListener(func(): print("World")) # lambda
    keyListener(: print("World")) # shortened lambda using 'rt'
    arr.filter(func(a): pivot > a) # anonymous functions
    arr.filter do a: pivot > a # function argument
    arr.filter(: pivot > _1) # lambda
    numbers.filter(: _1 % _2 == 0).map(: _1 * _2).reduce(2, +) # lambda
    let reversed = sort(names, : _1 > _2 )


FUNCTION CHAINING
    let x =: students.filterOutFailed()>>sortByGrade()
    mut d :: 4(2).subtract(1, 2)>> divide(10, 5)
    let y = add(4, 2) |> subtract(_, 1) |> divide(10, _)


MATCH FUNCTION
    match check30DayMonth(month = Month):
       case _.value == 4 : print("This is April, a 30-day Month!")
       case _.value == 6 : print("This is June, a 30-day Month!")
       case _.value == 9 : print("This is September, a 30-day Month!")
       case _.value == 11 : print("This is November, a 30-day Month!")
       print("Not a 30-day Month!")
    ..


COROUTINES
   # New Proposed Coroutine with Concurrency. Thanks to Go 03/08/16
   # Go-type Coroutine
   # I dunno yet if pipe can only be primitive types. I think that will be too restrictive.
   # This needs heavy review
   # Go-type Coroutine is so powerful that it can be used to achieve concurrency, distributed computing and parallelism
   # THE 'run' CALL
   func show(s =: Str):
       for x thru [1:3]:
           print(s)

   func main():
       show("Hello")
       run show("Hi")
       show("Hullo")
   ..
   # Hello Hello Hello Hi Hi Hullo Hi Hullo Hullo
   # PIPES
   func work(pipe x =: Bool):
       print("working...")
       time.sleep(1500)
       print("done")
       x <- true
   ..
   func main():
       pipe done = Bool
       run work(done)
       <- done
   ..
   # working...done
   # BUFFERING AND CLOSING PIPES
    func task(pipe x =: Str):
        loop:
            if !closed(x):
                print("working...")
    ..
    func main():
        pipe a =: Str
        run task(a)
        time.sleep(time.second * 6)
        close(a)
        print("done")
    ..
    # SELECT
    func main():
        pipe a, b =: Str
        run func ():
            time.sleep(1000)
            a <- "One"
        ..
        run func ():
            time.sleep(2000)
            b <- "Two"
        ..
        select:
            case a: print(<- a)
            case b: print(<- b)
            print("Nothing")
        ..
    ..

    # Python-type coroutine
    func coroutine():
        for x thru 1..10:
            yield x
    ..
    print(coroutine()) # 1
    print(coroutine()) # 2
    print(coroutine()) # 3
    coroutine.reset() # resets the coroutine
    print(coroutine()) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    # Simulated coroutine using sticky variables
    func addUp(b):
        mut sticky x = 0
        x += b
    ..
    print(addUp(4))
    print(addUp(5))
    print(addUp(6))


TYPE DEFINITION
   type Car:
      mut name, model = Str
      func (name =: Str):  # Constructor implicitly contains a first parameter of type Car
         self.name = name
      ..
      func (name, model =: Str):
         self.name = name
         self.model = model
      ..
      func (!): print("Object Destroyed") # Destructor
   ..


TYPE PLACEHOLDER
    # if the method of a type is directly beneath its definition, then a =: or :: can be used to
    # as a placeholder for the type
    type Greeting
    func greet(=:, lang =: Language)
    func greet(=:, cntry =: Country)
    func greet(::) # This function is not inheritable


CONSTRUCTOR
    type Person:
        mut name = Str
        mut age = Int
        func (name =: Str, age =: Int):
            .name = name
            .age = age
        ..
    ..
    # A constructor without body initialises the fields with the corresponding parameter
    type Person:
        mut name = Str
        mut age = Int
        func (name, age) # which means there is no such thing as virtual constructors
    ..


DEFAULT CONSTRUCTOR
    # If a type doesn't provide a constructor, an implicit default constructor
    type Lamp
    mut a =: Lamp() # or
    mut a =: Lamp # Both are valid
    # If it provides however, then an implicit default constructor is not provided
    type Lamp:
        mut color =: Str
        func (color)
    mut a =: Lamp("Blue")
    mut b =: Lamp # error! default cnstructor needs to be provided
    # A default cnstrustor can be createdby making all the parameters in te cnstrictor optional
    type Lamp:
        mut color =: Str
        func (color =: Str.nil) # color parameter is now optional
    mut a =: Lamp


CONSTRUCTOR TYPES
    # Constructor classes have only one constructor and an optional set of parameters that are also the only fields of the class
    # These fields are mutable by default and are always public.
    type Person (name, age)
    func show(=:): print(=:name, ' ', .age)
    mut dave = Person("Dave", 45)
    dave.age = "David"
    type Car (model make =: Str, year =: Int) [Vehicle]


SELF REFERENCE
    type Car:
        mut name, model = Str
        func (name =: Str):
            .name = name # the self can be ommitted leaving the dot and the field
        ..
        func (name, model)
    ..
    # this is also applicable to methods where its is the type of the first parameter
    func getDetails(c =: Car): rt [.name, .model]
    func hasModel(=:, model =: Str): .model == model?
    # you can also use self in a functional way
    func showInfo(=:): print(getDetails(self))


USING A FUNCTION AS METHOD
    func show(p =: Person): print("name: [.name], age: [.age]")
    mut nigel = Person("Nigel Nicargua")
    show(nigel)
    mut nigel.show() # using show function like a method since Person is the first argument
    # you can also use it on objects directly
    mut a = Person("Nigel Nicargua").getDetail()
    mut b = "hello".upper()
    mut c = 25_000.divideBy(x) # Don't do this though. :)
    mut d = (2f/4f).floor()


DESTRUCTORS
    type Car:
        mut name, model = Str
        func (name)
        func (name, model)
        func (!) : # Destructor implicitly contains a first parameter of type Car
            print('Object Destroyed!')
    ..


ABSTRACT TYPES
   type ab Player # cannot be instantiated
   func play(=:)
   func rewind(=:)
   func fastForward(=:)
   type CassettePlayer [Player]
   type DigitalPlayer [Player]
   # Abstract types can be constructor type too, but this doesn't mean they can be instantiated
   # The constructor is used here to show the types fields
   type ab Person(name, age)
   type ab Thread
   func run(=:) # This is a virtual function
   func stop(=:):.. # Abstract types can contain implementations too
   func execute(=:): .run()
   # Note that an abstract cannot use :: to assign its first parameter
   # because that signifies ony the instance of the class can use it
   # however abstract class cannot be instantiated.
   type ab Person(name, age)
   func show(::) # error!


PROPERTIES / GETTERS SETTERS
    mut myVar1 :: func set(a b c =: Int): _ = a * b * c $ func get(): rt _
    myVar1 = (1, 2, 3)
    mut myVar2 =
        func set(a b =: Int): _ = a * b * c
        func get(): rt _
    myVar2 = (1, 2)
    mut myVar3 = func set(a =: Int): _ = a $ func get(): rt _
    myVar3 = 1
    mut myVar4 = func set(a =: Int) $ get()
    myVar3 = 2
    mut tip = func get(): rt myVar3


TYPE CHECKING
    # Is
    if myCar === Car:
        print('myCar is a Car')
    ..
    if myCar ==: Car:
      print('myCar is a Car or its subtype')
    ..
    if myCar =<: Car:
      print('myCar is a subtype of Car')
    ..
    if myCar =>: Car:
      print('myCar is a supertype of Car')
    ..
    # Is Not
    if phone !== Phone:
        print("phone is not a Phone")
    if phone !=: Phone:
        print("phone is not a Phone or its subtype")
    if phone !<: Phone:
        print("phone is not a subtype of Phone")
    if phone !>: Phone:
        print("phone is not a supertype of Phone")


MODULES AND IMPORT
    module MyMath
    #......
    import MyMath
    mut x :: MyMath.pi * 2
    #......
    import MyMath: pi
    mut y =: pi * 2
    #.......
    import MyMath: Rational as Ratio, add, pi
    let y = Ratio(4, 6)
    let z :: add(5, pi)
    #......
    import MyMath: *
    let a =: Ratio(2, 4)
    let b =: Complex(3, 5)
    let c = pi * 2


TYPE ALIAS
   Int as Meter
   func(Str Int) as StrIntFunc
   mut f = StrIntFunc


METHOD CHAINING
- Method chaining is automatic, no need to return self
    type Math:
        mut value = Float
    ..
    func add(a =: Math, b c =: Float) Float:
        a.value = b + c
    ..
    func subtract(a =: Math, b c =: Float) Float:
        a.value = b - c
    ..
    mut m = Math
    m.add(1, 2).subtract(3, 4)
    mut n = "This is the first string".&"This is another string".reverse().toUpper()


INHERITANCE # Not Finalized!
    # Note that inheritable methods need =: operator when specifying their first parameter
    type Animal
    func move(=:):..

    type Bird [Animal]
    @mask
    func move(=:): print("Soar!") # overides move method for Animal, a super method
    func fly(::):..

    type Horse [Animal]
    @mask
    func move(=:): print("Gallop!") # overides move method for Animal, a super method
    func gallop(::):..

    type Pegasus [Bird, Horse] # inherits Bird and Horse classes
    @mask
    func move(=:): print("Gallop and Soar!") # overides move method because of CONFLICT in  Bird and Horse
    func gallopAndSoar(::):..

    mut eagle = Bird()
    mut horse = Horse()
    mut pegasus = Pegasus()
    move(eagle) # "Soar!"
    move(horse) # "Gallop!"
    move(pegasus) # "Soar and Gallop!"
    mut animals = Animal[Bird(), Horse(), Pegasus()]
    animals[1].move() # "Soar!"
    animals[2].move() # "Gallop!"
    animals[3].move() # "Soar and Gallop!"


OVERRIDING METHODS
    # Pluto now has an override hint called @mask. It is optional but recommended for
    # static-oriented codes. If you don't want to use the mask hint then you'll have to specify that
    # in the compiler hint or compile the code with the -nomask (debatable) flag.
    func play(a =: Player): .start()
    @mask
    func play(a =: DigitalPlayer): .startAt(0)


COVARIANCE
    # Pluto supports covariance thru the =: operator.
    type Person (name =: Str, age =: Int)
    func showDetails(p =: Person): print("name: [.name], .age: [.age]")
    type Engineer (kind =: Str) [Person]
    type Artist (kind =: Str) [Person]

    mut person =: Person("Peter", 16)
    mut engineer =: Engineer("Civil Engineer")
    mut artist =: Artist("Painting Artist")
    # covariance in assignment
    mut person =: Person("Matthew", 25) # home type
    mut person = engineer # guest type
    mut person = artist # guest type
    # covariance in argument passing
    showDetails(person)
    showDetails(engineer)
    showDetails(artist)
    # covariance in container types
    mut arr =: Person[]
    mut arr[1:] = [person, artist, engineer]
    # covariance in overriding
    func eat(a =: Herbivore, b =: Plant):..
    @mask
    func eat(a =: Cow, b =: Grass):.. # not only is the supermethod overriden, the arguments too are covariant


MULTIPLE LEVELS OF COVARIANCE
    # A structure with multiple type declaration can also allow covariance on each parameter
    type ab List<T>
    type ArrayList<T>[List]
    func getIndex(l =: List, i = Integer)
    getIndex(ArrayList = [1, 2, 3], 3_i16) # arg1 is a subtype of List and arg2 is a subtype of Integer
    # Covariant override is an example of multiple level of covariance
    func eat(a =: Herbivore, b =: Plant)
    @mask
    func eat(a =: Cow, b =: Grass) # valid override


CONTRAVARIANCE
    # Contravariance is not really supported in Pluto, except in generics type parameters
    func doSomething<T<:Person, U>
    # To do an upcasting, you can use a trick like this.
    type Person(name =: Str.nil, age =: Int.nil)
    type Employee((name =: Str.nil, age = Int.nil), job =: Str.nil, company =: Company.nil)
    func _convert<T>:Employee>(::, sup =: T): .name = sup.name; .age = sup.age
    mut p =: Person("Dan", 25)
    mut emp =: Employee = p


SUPERMETHODS AND SUBMETHODS
    # inheritable methods always use =: operator to specify the type of their first parameter
    type Listener
    type ButtonListener [Listener]
    func respond(a =: Listener) # this is a super method to the more specific method below
    @mask
    func respond(a =: ButtonListener):.. # this is a sub method to the method above


TYPE CASTING
    # Type casting is done using = operator
    # Some cast operations have already been provided for built-in types.
    mut a :: Int(5)
    mut b :: Float = a # b == 5.0f
    # The type cast metaObject is _convert()
    type MyInteger(value =: Int)
    func _convert(::, i =: Int): .value = i
    func _convert(::, f =: Float): .value = (Int = f)
    mut x :: MyInteger = 5
    x = 6.23f
    # Upcasting is not implicity supported in Pluto, so one can use _convert
    type Person(name =: Str.nil, age =: Int.nil)
    type Employee((name =: Str.nil, age = Int.nil), job =: Str.nil, company =: Company.nil)
    func _convert<T>:Employee>(::, sup =: T): .name = sup.name; .age = sup.age
    mut p =: Person("Dan", 25)
    mut emp =: Employee = p


CALLING SUPER
    type Person:
        mut name :: Str
        mut age :: Int
        func (name, age)
    ..
    type Artist [Person]:
        mut kind = Str
        func priv (job)
        func (name, age, kind):
            super(name, age) # calls the parent constructor to initilize parameters
            self(kind)
        ..
    ..
    # or
    type Artist [Person]:
        mut kind :: Str
        func ((name, age), kind)
    ..
    # or better
    type Artist ((name, age), kind) [Person]


VIRTUAL METHODS
    func respond(a =: Listener) # a method without a body is implicitly virtual and cannot be called however.
    # constructors cannot be virtual and therefore use the same syntax for shortening initialisation
    @mask
    func respond(a =: ButtonListener) # error, a virtual super method can't be overriden by a virtual sub method
    func respond(a =: Listener):.. # This is not a virtual function, it is an empty one


DOWNCASTING
  # assuming Movie and Song extends MediaItem
   mut library =: MediaItem [Movie("Zack Snyder's Sucker Punch"), Song("Lazy - Bruno Mars"), Song("Radioactive - Imagine Dragons"), Movie("Zack Snyder's 300")]
   for item thru library:
      if item === Song:
         print('Song: [song.name]')
      elsif item === Movie:
         print ('Movie: [movie.name]')
      ..
   ..


UNINHERITABLE CLASS
    # Why would I want a user not to inherit my class. I might remove this class in the near future
    type solo MyType:
        let x = 'Type Cannot Be Inherited'
    ..
    # an abstract type cannot be solo


GENERICS
    # Type Parameter
    <T> # Inferred
    <T=:Integer> # Integer and Integer subtypes
    <T<:Integer> # Integer subtypes
    <T>:Integer> # Integer supertypes
    <T=:Str|Int> # Str and subtypes or Int and subtypes
    func add<T>(a b c =: T): a + b + c
    add<Int>(1, 2, 3)
    # A function can use its type generic parameter :)
    type ArrayList<T>(list =: T[].nil)
    func add(=:, elem =: T):
        .list += elem
    # You totally omit the type arguments if they can be inferred before use
    type ArrayList<T>(list =: T[])
    func _setList(::, t =: T[]): .list = t
    mut list =: ArrayList # type argument not specified
    list = ["Hi", "Hello", "Hullo"]
    # If the types cannot be inferred before usage, an error is thrown. GenericTypeUnknown
    # Triangular dispatch
    func colorSpace<T<:ColorValue, U<:Image<T>>()


DATATYPE OBJECTS
    # Just as variables and functions have types, types also have types. :/
    # The type of types like Int, Float, Str is DataType
    mut var = Car("Camaro")
    typeOf(var) # Car
    typeOf(Car) # DataType
    checkIfStr(a): a === Str?
    # Note that a DataType object, assuming Artist with a parent type Person, is a DataType,
    # is a DataType(Artist) and is a DataType(Person)
    enum Letter: A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z
    A === DataType? # true
    A == A? # true
    A == Letter? # true
    let a = DataType(Car) # DataType objects are exposed thru DataType constructor and can be assigned to variables
    print(a) # Car


ENUMS
    # enum is an abstract type that contains ONLY its subtypes.
    # its subtypes are all constructor types and only extend the enum
    # also an enum object expects a subtype as value
    enum Friends: Deji, Tosin, Tola # Deji, Tosin and Tola are parameterless conctructor types
    match whichFriend(f =: Friends):
        case Deji : print("This is Deji")
        case Tosin : print("This is Tosin")
        case Tola : print("This is Tola")
    ..
    mut closeFriend =: Friends.Deji
    whichFriend(closeFriend)
    enum Number: IntegerNumber(i =: Integer), RealNumber(r =: Real) # IntegerNumber and RealNumber are constructor types
    # Enums provide access to its subtypes using the access operator
    Friends[1] # Returns a DataType object, here the DataType object is Friends.Deji
    # Iterating thru enum
    for x thru Friends:
        print(x)
    ..


PATTERN MATCHING
    # EXAMPLE: How to compute a tree-like expression
    type ab Tree
    type Leaf<T>(value =: T) [Tree]
    type Node (l = Leaf, r = Tree) [Tree]
    match sum(t =: Tree):
        case Leaf: t.value
        case Node: sum(t.l) + sum(t.r)
    ..
    mut x = Node(Leaf<Int>(1), Node(Leaf<Int>(2), Leaf<Int>(3)))
    mut y = sum(x)
    # or better
    enum Tree<T>: Leaf(value =: T), Node(l =: Leaf, r = Tree)
    match sum(t =: Tree):
        case Leaf: t.value
        case Node: sum(t.l) + sum(t.r)
    ..
    # you can use this verbose version
    mut x =: Tree<Int>.Node(Tree<Int>.Leaf(1), Tree<Int>.Node(Tree<Int>.Leaf(2), Tree<Int>.Leaf(3)))
    # or better
    mut x =: Tree.Node(_.Leaf(1), _.Node(_.Leaf(2), _.Leaf(3))) # the generic type is inferred
    mut y =: sum(x)


REGEX
    mut number =: /\d+(\.\d+(e[-+]\d+)?)?/
    mut input = "23.4e+5"
    if input =~ number: print("input is a number") $ else print("input is not a number")


ATOMIC EXPRESSION # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock: x = 5; y = x
   lock: if y == 5: print('y is 5')


ATOMIC BLOCKS # Will Remove this and follow goroutines implementation # lock can still be used for mutex in goroutine implementation
   lock block:
      x = 5
      y = x
   ..
   # or better
   lock:
      x =: 5
      y = x
   ..
   lock if tip == top:
   print("Hello")
   print(", World!")
   ..


OPERATOR OVERLOADING
    func +(x =: Number, y = Number): x.value + y.value
    func _setIndex(a =: Int): arr[a]
    func _value(a =: MyNumber): a.value
    # you can't add "!" infront of a mutative operator function
    func ++(a =: Number): a.value++
    # check Julia and Swift for reference


CUSTOM OPERATORS
    # Pluto, like Swift, allows you to create your own set of custom operators that are not
    # provided by the language. The operators you can string together include
    # + - * / = < > % ^ & | ! ?
    # you have to specify operator position, associativity and precedence for custom operators
    [op: 180, left, postfix] # this operator has a predence level of 180, left associativity and is a postfix operator
    func **(a =: Number): a.value ^ 2


TRY & ASSOCIATES
    # A try statement or block must always be paired with one or more except statement even if the except catches nothing
    func main():
        ensure:
            file.close()
        ..
        print("I'm about to open a text file and print its first 500 characters")
        mut file =: File("C:/Users/Hello/hello.txt")
        try file.open().print([1:500])
        except(fnfe =: FileNotFoundErr, ioobe =: IndexOutOfBoundErr):
            if fnfe: printErr('Can\'t find file!')
            if ioobe: printErr('Out of index error!')
        ..
        # ensure can be used in inner scope
        let x = 3, y = 4, z = 5
        use x, y:
            let a =: x * y
            ensure print("a goes out of scope here")
    ..

    try:
        file.open()
        file.write('Hello')
    except(fnfe =: FileNotFoundErr):
        printErr('Can\'t find file!')
    ..

    try:
        raise Err() # this raises an error, but does not stop program
        err Err() # this raises an error, and stops the program after error handling
    except(e =: Err):  # catches all exception
        printErr('Error!')
    ensure:
        file.close()
    ..

    try let x =: getObject()
    except(ne = NilErr):
        printErr('x can\'t be nil!')
    ..

    try:
        if let x =: getObject(): $ else: raise NilErr()
    except() # this catches nothing

    try:
        let x =: getObject()
    except:
        printErr('x can\'t be nil!')
    ..

    try:
        file.open()
        let x =: file.readLine()
    except(ne =: NilErr):
        printErr('x can\'t be nil!')
    except(fnfe =: FileNotFoundErr):
        printErr('Can\'t find file!')
    ensure:
        file.close()
    ..


ASSERTION
# syntax of macro still in works
    @{assert x == nil}
    # definition of assert
    @macro
    assert(a):
        # TODO
    ..


ITERATORS (?)


FLOATING POINT BITWISE OPERATORS - Will Remove this!!


HINTS
    # a hint can have parameters declared in a symbol brackets
    @deprecated {msg = "MediaPlayer class should be used instead"}
    # a hint can introduce a block with colon.
    @if {plat = "Mac"} print("This is a Machintosh Computer")
    @if {plat = "Win"}:
        print("This is a Windows Computer")
    #------------------------------------
    @compiler # evaluated at compile-time
    @linker # evaluated at link-time
    @runtime # evaluated at runtime



COMPILER HINT
    @compiler {
        typing = "static"
        variable = "immutable"
        warn_me = {
            unimplemented_inherited_functions,
            unimplemented_inherited_fields
        }
    }


COMPOUND HINT
    # compound hint is a hint that contains other hints and
    # it can only be in the same module as the main function
    @compound:
        @if {plat = "Win"}:
            print("This is a Windows Computer")
        @elsif {plat = "Mac"}:
            print("This is a Machintosh Computer")
        @elsif {plat = "Linux"}:
            print("This is a Linux Computer")
    ..


METAOBJECTS
    # MetaObjects can be in form of functions or variables
    # Some metaObjects can be overloaded, some others can't
    # The instance attached to a metaObject can be inferred
    # based on the context of expression
    arr[_last] = 20 # _last here refers to arr._last
    # some structures such as match, enum, etc. support "subject in context" metaObject
    # which is represented with "_"
    match check30DayMonth(month = Month):
        case _.value == 4 : print("This is April, a 30-day Month!")
        case _.value == 6 : print("This is June, a 30-day Month!")
        case _.value == 9 : print("This is September, a 30-day Month!")
        case _.value == 11 : print("This is November, a 30-day Month!")
    print("Not a 30-day Month!")
    ..
    mut sum =: add(a, b) |> add(_, x)
    mut tip =: func set(a = Int): _ = 25 $ func get(): rt _
    type ArrayList<T>(list =: T[])
    func _setList(::, t =: T[]): .list = t
    mut list =: ArrayList = ["Hi", "Hello", "Hullo"]


LIST OFS METAOBJECTS
    _
    _last
    _min
    _max
    _setList()
    _convert()


VALUE METAVAR
    # Returned value must be a primitive value
    # This represents the objects value
    func _value(num =: MyNumber): rt num.value
    mut x = MyNumber(12)
    print("[x] is my number")
    mut myMap =: Map<MyNumber, Int> # sorted by MyNumber's _value


REFLECTION
    # dynamically determining which class to use
    @if (stage = "runtime", condition = "Main.useOldClass == true"): # ??
        type Class:
            mut value = func set(x Str): _ = x $ func get(): rt _
            func (value)
        ..
    @else
        type Class:
            mut str = func set(x =: Str): _ = x $ func get(): _
            mut num = func set(x =: Float64): _ = x $ func get(): _
            func (str)
            func (str, num)
        ..
    ..


MACROS !! Needs Work
    #
    @macro
    reverseExpression(ex):
        # TODO
    ..
    if @{reverseExpression x < y} : print('O.O')


COMPLEX, QUATERNION DECLARATION
    mut x = 5 + 2i # complex
    mut y = 5 + 2i + 3j + 4k # quaternion


MATHEMATICAL EXPRESSION
    let top =: m{3x - 2y/5 + r(d^5)} # operator precedence still applies
    let tip =: m{3x y z^2} # when there is no operator between 2 operands, multiplication is assumed
    mut pat = m{4y - 2x(z^2) getSalary()} # you can use functions and variables directly
    mut pet = m{4d 5f} # MathExpr doesn't support numeric literals with type prefix. 4d and 5f here means 4 * d * 5 * f
    mut pot = m{5y [getValue[2]] 3e-1 + [4d]} # Use '[' and ']' to escape literals with fp type prefix or
    # variables that use index operator. 4d here is a Double literal and getValue[2] gets the value in index 2.


SYMBOL, EXPR, HOMOICONICITY & OTHER SYMBOLIC CLASSES
    # Symbol
    # delimited by spaces and commas
    # interpolated using "[]"
    # can also be nested {x, {y, b}}
    mut buck =: {1}
    mut back = {1 2 3}
    let bean = {hello {hi {halo}}} # can be nested too
    let beak = {"hello ", [name]}
    let x = beak[1] # hello
    let y = beak._value # hello Nypro
    # Expressions
    mut pat =: ex{1 + 2 * [number]}
    mut exp = parse("1 + 2 * 3")
    mut ingrid = eval(exp)
    parse(pat)
    mut math = m{3x - 2y/5 + r(d^5)}


COMPILE TIME SYMBOLS ??
    # Symbols is different from macros in that, the content is only broken down
    # as specified by the programmer, but it is evalusted at runtime as strings
    # This could be useful for PEG lib, for example, cos structures can be taken from
    # the user and then broken down at parse-time.


CPLUSPLUS SYMBOL
    mut str = cpp{void add(int a, int b) {return a + b;}}
    parse(str)
    let sum = str.add
    mut brim = sum(1, 3)


NON-STANDARD SYMBOL LITERAL HINT
    mut cxxCode = cpp{void main() {printf("Hello")}}
    @symLiteral:
        cpp = {Cpp(_value)}


NON-STANDARD STRING LITERAL HINT
    mut byteArray =: ba"87004"
    @strLiteral:
        re = {ByteArray(_value)}


NON_STANDARD NUMERIC LITERAL HINT
    mut price =: 1_359.99_$
    @numLiteral:
        $ = {Dollar(_value)}


NUMERIC CLASS
    let x = UInt.max()
    let y = Int32.min()
    mut z = m{2x + 4y/3}.round() + (24.25/4).floor()


RATIONAL CLASS
    mut xianghou = 2//3
    mut dean = x.toFloat() # rational format can be changed to fp
    mut bean = 4//6 ; print(y) # 2//3
    4//2 == 1//2 # true
    4//2 == 0.5 # true


BITS TYPE
    # bits stored in multiples of 8
    let bits8 = Bits(8)
    let bits16 = Bits(16)


BUFFER TYPE
    # This might allow Array implementation to be separated from storage and to allow
    # Arrays to be implemented completely in Pluto.
    # It stores objects in adjacent memory
    let intStore5 = Buf(16, 5) # first arg is alignment, secong arg is size


INTEGER BITWISE OPERATORS
    mut myVar = 2&:2 # and
    mut myVar1 = 2|:2 # or
    mut myVar3 = ~:2 # not
    mut myVar3 = ^:2 # exclusive or


SHIFT OPERATORS
    mut myVar = 4<<1
    mut myVar = 2>>2


BINARY LITERALS
    mut myVar = 0b11001001 # deprecated


HEXADECIMAL LITERALS
    let myVar = 0x5eff77 # deprecated


OCTAL LITERALS
    mut myVar = 0o56773 # deprecated


UTF-8 CHARACTERS
    let char =: '\u6E'


CLASSES OF OBJECTS
    Obj (0.7), Any (0.8)
    Func (0.7)
    Var (0.7), Indie(0.8.2)
    Array (0.7)
    Dict (0.7)
    Exp (0.7), Expr(0.8.2)
    # Nil (0.4), None (0.8.1), # Removed (0.8.2)
    Symbol(0.7)
    DataType(0.8.2)


PREDEFINED TYPES # These types are optimized as part of the lang
    Int, Int16, Int32, Int64
    UInt, UInt16, UInt32, UInt64
    Float16(0.8.2), Float/Float32 (0.4), Float64/Double (0.6.1)
    Bool (0.4)
    Str (0.4), String (0.6.1), Str (0.8.1)
    Char
    Byte
    SByte
    Comp, Comp128
    Quat, Quat256
    Num (0.4) #= redefined in (0.8.1) =#, BigInt, BigFloat (0.8.2)
    Ratio


LOGICAL vs BITWISE OPERATORS
    ! & |
    :~ :& :| :^


KEYWORDS
    stick (0.4) sticky  (0.6.1)
    # pub (0.4) public (0.6.1) pub
    priv (0.4) private (0.6.1) priv
    pro (0.4) protected (0.6.1) prot
    pack (0.4) package (0.6.1) pack
    pass (0.7.5)
    class (0.4), type()
    rt (0.7.2)
    def (Rev 0.5.2), def (0.8.2), func (0.8.2)
    let (Rev 0.5.2)
    get (Rev 0.5.2)
    set (Rev 0.5.2)
    as (0.8)
    if
    else
    elsif
    while  (0.6.1)
    eval (Rev 0.5.2) match (0.8.1)
    for
    do
    until (0.6.1)
    next (0.6.1)
    break
    label (0.7.0)
    use (0.5.2), use (0.8.2) # reintroduced
    # fixed
    thru (0.8)
    in(0.7.2)
    skip(0.8)
    ensure (0.8)
    try
    except
    self
    mut (0.8)
    nan (0.8)
    nil
    op (0.8.2)
    abs, ab(0.8.2)



OPERATORS
    +
    -
    *
    /
    // # for ratios
    ^
    %
    --
    ++
    .+
    .-
    .*
    ./
    .^
    .%
    .--
    .++
    =
    =:
    <:
    >:
    ::
    +=
    -=
    *=
    /=
    //=
    ^=
    %=
    .+=
    .-=
    .*=
    ./=
    .//=
    .^=
    .%=
    ==
    !=
    ===
    !==
    ==:
    !=:
    =<:
    !<:
    =>:
    !>:
    =~
    !~
    !
    >
    <
    >=
    <=
    &
    |
    :~
    :|
    :&
    :^
    >>
    <<
-   '
    .=


SYNTACTIC SYMBOLS
    |, $ (0.8.2)
    ;
    @
    :
    ..

---------------! NOTES !------------------------
VARIABLE BINDING



LITERALS
- Literals are subexpressions that do not return unlike other subexpressions (variable access)
- or expressions (operations, function call).
Type of Literals
- Numeric
    50, 12_000_i32, 78.89e-2
- String
    "Hello", 'Hi'
- Symbol
    {Root}, {Parent {Child1 Child2}}


NIL
- There are two states an object can have, valued state or nil state. An object with valued state can
- contain primitive values or other objects, but an object with a nil state can only contain nil.
- Nil can be assigned to an object directly (a syntactic sugar for the object's nil state),
- but they cannot be returned. Although one can pass or return an object with a Nil state.
- The recieving object must handle it or else NilErr will be invoked.
    mut deal = nil # is Any.nil
    mut done = deal # error! NilErr
    mut deck = deal~ # deck now accepts nil
    # you could also do this
    mut dark = deal~0  # dark will be 0 if deal is nil


OBJECT HIERARCHY
- Any -> Indie, Array, Func,
- DataType


CONCURRENCY


CONDITIONALS
- Value
- nil or not
- True or false
- Type (===)


ITERABLES
- Coroutines
- Functions
- Range
- Array objects
- Table objects
- Iterable SubClasses
- String
- Enums


SUBJECT OF OPERATIONS
# is signified by '_'
- Stack
- Match
- Properties


AUTOMATIC REFERENCE COUNTING
- There can only be one strong ref to an object
    type Skeleton:
        bones List<own Bone> # bones contain a list of strong Refs to Bone objects
    ..
    type Bone:
        skel Skeleton
    ..


MOVE SEMANTICS
- Move feature is automatic in areas where it makes sense to do so for example, returning a value (not reference) to a variable.
- I removed the explicit move keyword because I think it will have some unwanted side effects. For example, moving a returned reference which is also referenced elsewhere.
- And Pluto moves at the appropriate places anyway.


DECLARATIVE PLUTO ".deplu" #27/06/16
   person:[
      name : "Nypro"
      fat : false
      tall : true
      hobby : 'programming'
      single : _ # underscore as a value signifies empty
      children : [2, 3, 4, 6]
      coord : [x : 5]
      coords : [x : 1, y : 2, z : 3]
      gamesLiked : name, releaseDate, hard [
         ["Crysis", 2007, _],
         ["Unreal Tournament", 1999, true],
         ["Portal 2", 2011, true],
      ]
   ]


DUCK TYPING EXAMPLES
   mut c
   mut a = 25
   mut b =: [1, 2, 3, 4, 5] # array
   mut c = [1, 2, 3 | 4, 5, 6] # multi dimen array
   mut d = ['Hello', 25, 1.3f, 'Hi'] # table
   func getArea(length, breadth):
      length * breadth
   ..
   mut length = 10
   mut breadth = 25
   mut rectangleArea = getArea(length, breadth)


NESTED ASSIGNMENT
- Pluto does not support nested assignments. Dunno really :p
   mut tip = 5
   mut tap = (tip *= 5)


PASS TABLE
#=
    Types                               |   Passed Around By
    ----------------------------------------------------------
    Built-in Ind Types /  Value Types   |   val
    Array Types                         |   ref
    Func Types                          |   ref
    Custom Types                        |   ref
=#
- Note that objects of relatively small Array, Func and Custom Types
- will be allocated on the stack while simulating referencing
- And this is done only if the object is iso or guaranteed to have a
- single reference


VARIABLE VS PARAMETER
- Variable declaration is nothing like parameter declaration


COMPILER WARNINGS
- When assigning to variables in other modules
- Pluto only warns when about imported naming ambiguities when the names are accessed


RUNTIME WARNINGS


COMPILATION
- '_' is compiled as a placeholder. This will be replaced at run time by a subject of context
- some symbolic types are evaluated at compile-time, e.g. MathExpr


PUNCTUATION
- Pluto needs proper use of indentations and newline to compile successfully
- This makes code reformatable to original when copied. Especially with nested if-else blocks.
- Pluto only supports consistent space-based identation. Indentation should not use below/above 2 to 5 spaces


BIG AIMS
- If Pluto is written statically, then most of the analyses should be done statically
- with benefits of optimisations (e.g. usingg traditional arrays). Only certain checks are
- done at runtime.
- Static ARC analysis. Be careful with concurrency.


UTILITIES
IDE
- The REPL
- Advanced Refactoring
- Code Completion
- Render/Plot View
- Step-through Debugger
- Profiler
-------------------
Network and Streams
- terminals
- files
- TCP sockets
- pipes
-------------------
Virtual Machine
- PlutoMine
-------------------
Compilers
- Bytecode/AST Interpreter and JIT Compiler.


QUIRKS
- DataType vs Generics (dataType is a runtime object, generics is a static meta object.)
- Macro and its relationship wih the AST
- Multi-line Expression
- Returning list or iterator for stuffs like
    mut x = [:50]
- Whether nullable objects should be declared nullable, or all object should be nullable by default
- Chained conditions can be written in 4 ways. (update) Now reduced to 3 but wih one producing an error if used certain way
